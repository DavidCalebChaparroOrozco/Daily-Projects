# Daily-Projects
This repository contains my daily projects, challenging me to create something new every day. From small utilities to full-fledged applications, they reflect my growth as a developer. Each project has a brief description of technologies, challenges and lessons. It is a record of my progress and a constantly evolving portfolio.
* Day 01:  Polar Plots in Python with Matplotlib by Neural Nine
  * Today we learn how to work with polar coordinates and how to create polar plots in Python using Matplotlib.
* Day 02: Spotify Oldies Dataset 🎶: A Treasury of Classics [Kaggle](https://www.kaggle.com/datasets/kanchana1990/spotify-oldies-dataset/data)
  * Today I'm going to work with a dataset called Spotify Oldies Dataset: A Treasury of Classics.
* Day 03: Pomodoro Timer GUI
  * In this project, I developed a graphical user interface (GUI) for a Pomodoro Timer using Tkinter in Python. The Pomodoro Technique is a time management method that uses a timer to break down work into intervals, traditionally 25 minutes in length, separated by short breaks. This GUI application allows users to start, reset, and skip timers for Pomodoro sessions, short breaks, and long breaks, providing visual feedback on the remaining time for each interval. It serves as a practical tool for enhancing productivity and focus during work or study sessions.
* Day 04: To Do App
  * Today, I created a To Do application using Flask and SQLAlchemy. This app allows users to add, edit, and delete tasks, as well as mark them as completed or in progress. Users can also search and filter tasks by various criteria such as title, completion status, priority, and due date. Additionally, the app supports sorting tasks by ID, title, or completion status, and offers bulk actions to mark tasks as completed, in progress, or not completed. It's a simple yet practical tool for managing daily tasks efficiently.
* Day 05: ContactManager
  * This project involves creating a contact manager application using Python's Tkinter library. The ContactManager allows users to add, edit, view, and delete contacts. It provides features such as pagination, searching, importing/exporting contacts from/to CSV files, and input validation for contact details. It offers a user-friendly interface for managing contact information effectively.
* Day 06: Income Prediction Adult Income [Kaggle](https://www.kaggle.com/datasets/wenruliu/adult-income-dataset)
  * In today's project, I implemented a machine learning model to predict adult income using the Adult Income dataset. The dataset contains various demographic and employment-related features such as age, education level, occupation, and work hours per week, along with the target variable indicating whether an individual earns more than $50,000 annually. I utilized the Random Forest algorithm to train the model and extracted feature importance scores to identify the key factors influencing income prediction. The model achieved an accuracy of  0.86%, demonstrating its capability to classify individuals into different income groups. This project enhances my understanding of supervised learning techniques and their application in real-world scenarios.
* Day 07: Pokedex GUI Application
  * In this project, I developed a graphical user interface (GUI) application for a Pokedex using Python's Tkinter library. The Pokedex is a digital encyclopedia that catalogues information about different species of Pokémon, a popular franchise of fictional creatures.
* Day 08: Flet Chat Application
  * Created a chat application using Flet library in Python. This application allows users to join a chat room, send and receive messages in real-time. It features a graphical user interface (GUI) for displaying chat messages, input field for sending messages, and user authentication. The application utilizes Flet components for UI design and integrates functionalities for sending, receiving, and displaying messages efficiently. It serves as a practical tool for real-time communication and collaboration among users.
* Day 09: Video Game Sales [Kaggle](https://www.kaggle.com/datasets/gregorut/videogamesales/data)
  * Today's project delves into the world of video game sales analysis. Leveraging the Video Game Sales dataset from Kaggle, I explore trends and patterns in the gaming industry. This dataset contains information on video game sales across different platforms, regions, genres, and years, providing valuable insights into consumer preferences and market dynamics. Through data exploration, visualization, and potentially predictive modeling, I aim to uncover hidden gems and understand what makes a successful video game title. Stay tuned for the journey through pixels and polygons! 🎮✨
* Day 10: Summarize News Articles
  * Worked on a project to summarize news articles using web scraping and natural language processing libraries like newspaper3k and TextBlob.
* Day 11: Sudoku Solver
  * In this project, I've crafted a Sudoku solver leveraging the backtracking algorithm in Python. This application empowers users to input incomplete Sudoku puzzles, generating a valid solution for the board. To enhance user experience, I integrated the Tkinter graphical library to craft an interactive interface. Through this interface, users can input Sudoku numbers and witness the solution unfold step by step. This project not only offers an efficient solution for Sudoku puzzles but also serves as an educational tool to delve into backtracking algorithms and Python-based interactive user interfaces.
* Day 12: Snake Pygame
  * In today's project, I built a classic Snake game using Pygame, a popular Python library for creating 2D games. The Snake game is a timeless arcade classic where the player controls a snake that moves around the screen, eating food to grow longer while avoiding collisions with itself and the boundaries of the game area.
* Day 13: Titanic Dataset 🚢 [Kaggle](https://www.kaggle.com/c/titanic)
  * Today, we delve into the exciting world of data analysis with the famous Titanic dataset. This dataset, available on Kaggle, provides information about the passengers aboard the Titanic, including details such as age, gender, ticket class, fare paid, and more. Our task is to explore this dataset, understand its key features, and possibly develop predictive models to determine the likelihood of a passenger's survival based on various factors. Through this project, we will not only enhance our data analysis skills but also honor the memory of the Titanic passengers by extracting meaningful insights from this historic dataset.
* Day 14: Email Python
  * Today's project involves creating a Python script for sending automated emails. Leveraging libraries such as smtplib, schedule, and dotenv, we develop a script capable of sending daily inspirational emails to a specified email address. The script reads quotes from a file, selects a random quote, and sends it via SMTP protocol. Utilizing environment variables for storing email credentials ensures security and flexibility. By scheduling the script to run periodically using the schedule library, we automate the process of sending daily inspiration to recipients, fostering motivation and positivity. This project not only demonstrates practical use cases of Python for automation but also serves as a reminder of the power of uplifting messages in our daily lives.
* Day 15: Guess the Number
  * Today's project involves creating a number guessing game using Python's Tkinter library for building the graphical user interface (GUI). The game prompts the player to guess a randomly generated number between 1 and 99 within a limited number of attempts. Through input validation and dynamic feedback, the game guides the player to adjust their guesses until they either correctly identify the number or exhaust their attempts. This project not only showcases interactive GUI development with Tkinter but also reinforces concepts of random number generation, user input handling, and game logic implementation. It provides an entertaining and engaging experience for players while honing programming skills in Python. Can you beat the odds and guess the secret number? Let the guessing game begin! 🎲
* Day 16: Virtual Bookshelves
  * In this project, I'll create a virtual bookshelf management system using Python and SQLite. The application will allow users to add, remove, update, and view books in their virtual bookshelves. Each book will have attributes such as title, author, year published, and genre. The system will utilize SQLite for database management and provide a user-friendly interface for interacting with the bookshelves. This project aims to simulate real-world bookshelf management scenarios and provide users with a convenient way to organize their reading materials. Let's embark on the journey of building virtual bookshelves to enhance our reading experiences! 📚✨
* Day 17: RSS Feed Reader
  * In this project, I'll develop an RSS feed reader using Python and BeautifulSoup. The RSS feed reader will be capable of fetching and parsing RSS feeds from various sources. It will extract relevant information such as titles, descriptions, and links from the feeds, presenting them in a user-friendly format. By implementing this RSS feed reader, I aim to enhance my skills in web scraping, XML parsing, and data presentation. Stay tuned for an efficient tool to stay updated with the latest news and content from your favorite websites! 📰🚀
* Day 18: Customer Manager JSON
  * In this project, I've developed a customer management system using Python and JSON. The system allows users to store and manage information about customers, including names, email addresses, cities, etc. It implements functionalities such as searching for customers by name, updating contact information, deleting customers, and adding new customers. Leveraging JSON as the data storage format ensures portability and simplicity in data management. This project enhances my skills in file handling, data manipulation, and user interface design. It serves as a practical tool for organizing customer data efficiently and facilitating effective communication and interaction with clients. Let's embark on the journey of customer management and streamline the process of customer engagement! 📊👥
* Day 19: Expense Tracking App
  * Created an expense tracking application using Python's Tkinter library. This app allows users to record their expenses, including item name, price, and purchase date. Users can add, edit, delete, and view expense records, providing a convenient way to manage their finances. Additionally, the app calculates the total expense and remaining balance, offering insights into spending habits. It serves as a practical tool for budgeting and financial management. 📊💰
* Day 20: Hangman
  * Implemented the classic Hangman game using Python and Flask. Players can guess letters to reveal a hidden word within a limited number of attempts. The game features a user-friendly interface and supports error handling for invalid inputs. Test your vocabulary and strategic thinking in this timeless word-guessing challenge! 🎩🔤
* Day 21: Image Editor
  * In this project, I developed an image editor using Python and Tkinter. The Image Editor allows users to open image files, apply filters such as black and white, blur, sharpen, and more, flip and rotate images, draw lines over the images, change pen color, erase drawn lines, and save edited images. It provides a user-friendly interface for basic image editing tasks and serves as a practical tool for enhancing and modifying images. Let your creativity flow with the Image Editor! 🎨🖼️
* Day 22: Faker User
  * In this project, I utilized the Faker library in Python to generate synthetic user data. From names and email addresses to phone numbers and job titles, Faker User creates realistic user profiles effortlessly. Whether for testing, prototyping, or data augmentation, Faker User streamlines the process of generating diverse and customizable datasets.
* Day 23: Simple Stock Price (Steamlit)
  * Today's project revolves around creating a Simple Stock Price application using Streamlit. This application enables users to visualize stock price data, including closing prices, volume, and candlestick charts, for various companies. Leveraging the yfinance library, the app fetches historical stock data and presents it in an interactive and user-friendly manner. Users can select a company from a dropdown menu, view different metrics, and analyze performance metrics such as returns, volatility, and Sharpe ratio. With its intuitive interface and insightful visualizations, this project serves as a valuable tool for investors and enthusiasts alike to track and analyze stock market trends.
* Day 24: Quality Of Wine [Kaggle](https://www.kaggle.com/datasets/uciml/red-wine-quality-cortez-et-al-2009)
  * Exploring the quality of wine dataset from Kaggle, I aim to analyze factors influencing the quality of red wine. Leveraging data analysis and visualization techniques, I seek to uncover patterns and relationships among various chemical properties and wine quality ratings. By applying machine learning algorithms, I intend to develop predictive models to classify wine quality based on its attributes. This project provides insights into the intricate world of wine quality assessment and demonstrates the application of data science in the domain of viticulture. Cheers to discovering the essence of fine wine! 🍷📊
* Day 25: Extract Dominant Colors
  * In this project, I'll delve into the fascinating realm of image processing to extract the dominant colors from images. Utilizing Python libraries such as ColorThief and Matplotlib, I'll develop a script capable of identifying the primary colors present in an image. By analyzing color palettes and visualizing dominant hues, this endeavor aims to provide insights into the aesthetic composition of images. Join me as I explore the vibrant spectrum of colors and uncover the beauty hidden within digital imagery. 🎨🖼️
* Day 26: Tree Node
  * On day 26, I focused on the implementation of a fundamental data structure, the tree node. Through Python, I constructed a TreeNode class capable of representing nodes within a binary search tree. With the aid of methods like insertion and various traversal techniques (preorder, inorder, and postorder), I delved into the intricacies of managing and navigating through binary trees. This exploration lays the groundwork for comprehending more complex tree-based algorithms and data structures, providing a solid foundation for further study in computer science and programming. 🌳🔍
* Day 27: ML with FastAPI
  * Today we learn how to easily turn machine learning models into usable APIs using FastAPI in Python.
* Day 28: Tutorial Guide (Python Types Intro) [FastAPI](https://fastapi.tiangolo.com/python-types/)
  * On day 28, we delve into an essential aspect of Python programming - types. This tutorial guide provides an introduction to Python types, focusing particularly on their usage within the FastAPI framework. Understanding Python types is crucial for developing robust and maintainable code, and integrating this knowledge with FastAPI facilitates the creation of efficient and scalable web APIs. By exploring the intricacies of Python types within the context of FastAPI, we equip ourselves with powerful tools for building robust and type-safe applications. 🐍✨
* Day 29: Parking Space Counter
  * We implemented a parking space counter application using Python and OpenCV. This project enables users to define parking spaces on an image, count full and empty parking spots, and visualize the counts in real-time. The application leverages computer vision techniques to identify parking space boundaries and utilizes event handling to interactively mark full and empty spaces. This project serves as a practical example of applying Python and OpenCV for image processing and computer vision tasks, demonstrating their utility in real-world applications such as parking management systems. 🅿️🚗🅿️
* Day 30: [TensorFlow](https://www.tensorflow.org/tutorials/keras/classification) Guide (Beginner ~ ML Basics with Keras)
  * Explore the fundamentals of machine learning with TensorFlow and Keras in this beginner's guide. This guide provides a comprehensive overview of TensorFlow, a powerful open-source machine learning framework developed by Google. Through practical examples and step-by-step tutorials, you'll learn how to build and train neural networks using Keras, a high-level neural networks API that runs on top of TensorFlow. From basic concepts to hands-on implementation, this guide is designed to introduce you to the essentials of machine learning and empower you to start building your own ML models with TensorFlow and Keras. 🤖📚🔍
* Day 31: Spam Emails Dataset [Kaggle](https://www.kaggle.com/datasets/venky73/spam-mails-dataset/code)
  * We explored a Spam Emails Dataset available on Kaggle. This dataset contains a collection of emails labeled as spam or ham (not spam). Leveraging this dataset, we embarked on a data analysis and preprocessing journey using Python and pandas. Through this process, we gained insights into the structure of the data and performed necessary preprocessing steps to prepare it for machine learning tasks. By delving into real-world data and preparing it for analysis, we honed our data manipulation and preprocessing skills, essential for any data science or machine learning project. 📧🔍🛠️
* Day 32: Dijkstra's Algorithm Implementation
  * We implemented the Dijkstra algorithm, which is a design algorithm used to find the shortest path between nodes in a graph. The implementation is made in Python and uses a linear array to precisely search the graph and calculate the shortest distance from the starting point to all other points. Dijkstra's algorithm is widely used in a variety of applications, including network protocol routing  and  video game routing. By applying this algorithm, we increased 's design understanding  and strengthened our algorithmic problem-solving skills. 📈🔍💡
* Day 33: Technical Test "Add Two Numbers" and "FizzBuzz" [LeetCode](https://leetcode.com/problems/)
  * Add Two Numbers: We tackled the "Add Two Numbers" problem from LeetCode, which involves adding two non-empty linked lists representing non-negative integers. The digits are stored in reverse order, and each node contains a single digit. We implemented a Python solution that traverses both linked lists simultaneously, summing the corresponding digits and handling any carry. This problem enhances our understanding of linked list manipulation and problem-solving skills.
  [Problem Description](https://leetcode.com/problems/add-two-numbers/description/?source=submission-ac)
  
  * FizzBuzz: The second problem we solved was "FizzBuzz," also from LeetCode. This classic programming problem requires generating the FizzBuzz sequence up to a given number. We crafted a Python solution that iterates through the numbers from 1 to the given number, appending "Fizz" for multiples of 3, "Buzz" for multiples of 5, "FizzBuzz" for multiples of both 3 and 5, and the number itself if none of the conditions are met. This exercise reinforces our ability to write concise and efficient code to solve common programming challenges.
  [Problem Description](https://leetcode.com/problems/fizz-buzz/description/)
* Day 34: Quicksort
  * We implemented Quicksort, a divide-and-conquer algorithm used for sorting arrays or lists. Quicksort selects a pivot element, partitions the other elements into two sub-arrays based on whether they are less than or greater than the pivot, and recursively sorts the sub-arrays. Known for its efficiency, Quicksort is often used as a benchmark for comparison with other sorting algorithms, enhancing our understanding of algorithmic efficiency and problem-solving skills. 🔄📊🔍
* Day 35: Live Weather Forecast Flask App
  * In today's project, we'll develop a live weather forecast Flask app. This app will take a city name as input and provide various weather characteristics such as temperature in Celsius and Fahrenheit, humidity, wind speed, and more.
* Day 36: Random Passwords Generator
  * Today, we created a Random Passwords Generator program. This program prompts the user to specify the desired length of the password and generates a strong password consisting of a mix of lowercase and uppercase letters, digits, and special characters. Additionally, we implemented a function to save the generated passwords to a CSV file for later use. This project enhances our understanding of string manipulation, random number generation, and file handling in Python, while also providing practical utility by creating a tool for generating secure passwords. 🔒💡💻
* Day 37: Site Connectivity Checker
  * Today, we developed a Site Connectivity Checker application using Flask. This application allows users to input a URL and checks its connectivity by sending a request to the specified website. We enhanced the functionality by adding URL validation, error handling for various connection issues, and logging of activity to track the status of site connections over time. By building this project, we gained practical experience in web development with Flask, handling HTTP requests, error management, and logging, all of which are essential skills for creating robust web applications. 🌐🔍🚀
* Day 38: Heart Attack Analysis & Prediction Dataset [Kaggle](https://www.kaggle.com/datasets/rashikrahmanpritom/heart-attack-analysis-prediction-dataset/data)
  * We explored the Heart Attack Analysis & Prediction Dataset available on Kaggle. This dataset provides valuable insights into factors contributing to heart attacks and includes various health parameters such as age, sex, cholesterol levels, blood pressure, and more. By analyzing this dataset, we aim to gain a deeper understanding of the relationships between different risk factors and the likelihood of a heart attack occurrence. Leveraging statistical analysis and machine learning techniques, we strive to develop predictive models that can assist in early detection and prevention efforts for cardiovascular diseases. This project underscores the importance of data-driven approaches in healthcare and reinforces our skills in data analysis, predictive modeling, and domain knowledge application. ❤️📊🔬
* Day 39: [TensorFlow](https://www.tensorflow.org/tutorials/keras/classification) Guide Basic text Classification (Beginner ~ ML Basics with Keras)
  * Continuing from Day 30, delve deeper into machine learning with TensorFlow and Keras by exploring basic text classification. In this guide, you'll learn how to apply machine learning concepts to classify text data using TensorFlow and Keras. By following step-by-step tutorials and practical examples, you'll understand the fundamentals of text classification, including preprocessing text data, building neural network models, and evaluating model performance. Whether you're new to machine learning or looking to expand your knowledge, this guide provides valuable insights and hands-on experience to enhance your skills in natural language processing and text classification tasks. 🤖📚🔍
* Day 40: Technical Test "Minimum Height Trees" and "Zigzag Conversion" [LeetCode](https://leetcode.com/problems/)
  * Minimum Height Trees: Today, we encountered the "Minimum Height Trees" problem on LeetCode. This problem revolves around identifying the roots of minimum height trees in an undirected graph, given the number of nodes and an array of edges representing connections between nodes. We crafted a Python solution employing graph traversal and manipulation techniques to determine the roots with minimum height efficiently. This challenge enhances our ability to work with graphs, analyze graph structures, and devise optimal algorithms for graph-related problems. [Problem Description](https://leetcode.com/problems/minimum-height-trees/description/)
  * Zigzag Conversion: In addition, we tackled the "Zigzag Conversion" problem on LeetCode. This problem involves converting a given string into a zigzag pattern with a specified number of rows and then reading the string line by line. We devised a Python solution that constructs the zigzag pattern by iteratively placing characters in the appropriate rows, simulating the pattern formation and reading process. Solving this problem reinforces our understanding of string manipulation techniques and enhances our problem-solving skills in handling complex pattern-based challenges. [Problem Description](https://leetcode.com/problems/zigzag-conversion/description/)
* Day 41: Tkinter - Map View
  * Explore Tkinter's capabilities in displaying interactive maps with the Tkinter MapView project. This Tkinter-based application allows users to visualize maps, search for addresses, and adjust zoom levels seamlessly within a GUI interface. By integrating functionalities such as address lookup, zoom control, and map display, this project showcases the potential of Tkinter for creating dynamic and user-friendly applications. Dive into the world of Tkinter and enhance your skills in GUI development with the MapView project. 🗺️🖥️🔍
* Day 42: Tkinter - Digital Clock
  * Explore the world of GUI development with Tkinter by creating a digital clock application. In this project, I utilized Tkinter's functionalities to design an attractive and functional digital clock interface. By leveraging Python's time module and Tkinter's Label widget, I implemented a dynamic clock display that updates in real-time. Join me as I continue to delve into Tkinter and expand my skills in creating intuitive and visually appealing graphical user interfaces. ⏰🖥️🔧
* Day 43: PySpark (Quickstart: DataFrame)[https://spark.apache.org/docs/3.3.1/api/python/getting_started/quickstart_df.html]
  * Dive into the world of big data processing with PySpark as we explore the Quickstart guide for DataFrames. PySpark is a powerful tool for processing large-scale datasets using the Apache Spark framework. In this project, we'll delve into the basics of working with DataFrames, a distributed collection of data organized into named columns. By following the Quickstart guide, we'll learn how to create, manipulate, and analyze DataFrames efficiently. Join me on this journey as we harness the power of PySpark to tackle big data challenges with ease and scalability. 🚀💻🔍
* Day 44: Daily Routine with Desktop Notifications
  * In this project, I crafted a personalized daily routine assistant utilizing desktop notifications. Leveraging Python libraries such as `win10toast` and `schedule`, I created a system that sends timely notifications for various activities throughout the day. Whether it's studying English, working on Python projects, taking short breaks, or even enjoying a joke break, this routine keeps me organized and on track. By scheduling notifications at specific times using the schedule module, I ensure I stay productive and maintain a healthy balance between work and relaxation. Join me as I automate my daily routine and optimize my productivity with desktop notifications! 📅⏰🖥️
* Day 45: Language Detection
  * Enhancing my text processing capabilities, I delved into language detection. Leveraging the langdetect and langcodes libraries in Python, I developed a program capable of identifying the language of input text. By utilizing the powerful language detection algorithms provided by these libraries, I crafted a user-friendly interface using Tkinter. This project allows users to input text and receive instant feedback on the detected language, aiding in various applications such as multilingual text analysis, translation services, and content filtering. Join me as I explore the fascinating world of language detection and broaden the scope of text processing possibilities! 🌐🔍📝
* Day 46: Technical Test "MedianSortedArrays" and "lengthOfLongestSubstring" [LeetCode](https://leetcode.com/problems/)
  * MedianSortedArrays: Today, we encountered the "Median of Two Sorted Arrays" problem on LeetCode. This problem involves finding the median of two sorted arrays, which are of different sizes, m and n. The challenge is to achieve a time complexity of O(log(m+n)). We tackled this problem by employing the binary search approach. By partitioning the arrays and comparing elements at partition points, we efficiently determine the median. Solving this problem enhances our understanding of algorithmic complexity and binary search techniques, crucial for tackling similar problems efficiently. [Problem Description](https://leetcode.com/problems/median-of-two-sorted-arrays/)

  * lengthOfLongestSubstring: In addition, we tackled the "Longest Substring Without Repeating Characters" problem on LeetCode. This problem requires finding the length of the longest substring within a given string that does not contain any repeating characters. We approached this problem using a sliding window technique, which allows us to efficiently traverse the string while keeping track of the characters encountered. By updating the window's boundaries based on repeating characters, we determine the longest substring without repetition. Solving this problem enhances our understanding of string manipulation and sliding window algorithms, essential for solving various string-related challenges. [Problem Description](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)
* Day 47: Currency Converter
  * Today, I embarked on a journey to create a currency converter application using Python. Leveraging the tkinter library for graphical user interface (GUI) development and the forex_python library for currency conversion functionality, I crafted a simple yet effective tool for converting between different currencies. This project involved setting up dropdown menus for selecting the source and target currencies, implementing an entry widget for inputting the amount to convert, and integrating a button to trigger the conversion process. By handling exceptions and displaying conversion results dynamically, I ensured a smooth user experience. Join me as I explore the world of currency conversion and develop a handy tool for everyday use! 💱💼🔀
* Day 48: Perceptron
  * In today's project, I delved into the world of artificial neural networks by implementing a perceptron from scratch. The perceptron, a fundamental building block of neural networks, is a simple algorithm capable of learning binary classifiers. Leveraging the NumPy library for numerical operations, I crafted a perceptron class capable of training on labeled datasets and making predictions. By defining the perceptron's architecture, including input features, weights, and activation functions, I gained insight into the inner workings of neural networks. Through iterative training and weight updates based on prediction errors, the perceptron learns to separate linearly separable classes in feature space. This project serves as a foundational step towards understanding more complex neural network architectures and their applications in machine learning and artificial intelligence. Join me as I explore the basic principles of neural networks and implement a perceptron algorithm from scratch! 🧠💻🤖
* Day 49: Technical Test "Reverse Integer" and "Longest Palindromic Substring" [LeetCode](https://leetcode.com/problems/)
  * Today's technical challenge involves the "Reverse Integer" problem on LeetCode. This problem requires reversing the digits of a signed 32-bit integer. If the reversed integer overflows, the function should return 0. We'll tackle this problem by implementing a solution that handles both positive and negative integers, considering overflow conditions carefully. Solving this problem enhances our skills in handling numerical operations and edge cases effectively. [Problem Description](https://leetcode.com/problems/reverse-integer/description/)
  * "Longest Palindromic Substring": Additionally, we'll tackle the "Longest Palindromic Substring" problem on LeetCode. This problem involves finding the longest palindromic substring within a given string. We'll devise an algorithm to efficiently determine the longest palindrome, leveraging techniques such as dynamic programming or expanding around centers. By addressing this challenge, we deepen our understanding of string manipulation and algorithmic problem-solving strategies. [Problem Description](https://leetcode.com/problems/longest-palindromic-substring/description/)
* Day 50: Students Performance in Exams [Kaggle](https://www.kaggle.com/datasets/whenamancodes/students-performance-in-exams/data)
  * Today, we delve into the realm of educational data analysis by exploring a student performance dataset from Kaggle. This dataset offers valuable insights into factors that may influence student achievement in exams. By delving into this data, we can uncover patterns, trends, and relationships that can inform educational practices and improve student learning outcomes.
* Day 51: Interactive Menu for YouTube and Web Searches
  * Today's focus is on creating a music player application. Building a music player involves integrating functionalities to play, pause, skip, and control the playback of audio files. Additionally, we'll explore features such as creating playlists, displaying metadata, and providing a user-friendly interface for an immersive music listening experience. By developing a music player, we deepen our understanding of GUI frameworks, multimedia handling, and software design principles.
* Day 52: Task Manager Performance
  * Today's task revolves around analyzing the performance of a task manager application. Task managers play a crucial role in monitoring system resources, managing processes, and optimizing performance. Through this analysis, we aim to evaluate the efficiency, responsiveness, and resource utilization of the task manager under various conditions. By examining performance metrics such as CPU usage, memory consumption, and task responsiveness, we can identify areas for improvement and enhance the overall functionality of the task manager application.
* Day 53: Technical Test "Integer to Roman" and "Container With Most Water" [LeetCode](https://leetcode.com/problems/)
  * Integer to Roman:
    Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M. Implement a function to convert an integer into its corresponding Roman numeral representation.
    Given an integer, convert it to a Roman numeral. [Problem Description](https://leetcode.com/problems/integer-to-roman/)
  * Container With Most Water: You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store. [Problem Description](https://leetcode.com/problems/container-with-most-water/description/)
* Day 54: Background Remove Flask
  * Today's focus is on implementing a background removal functionality within a Flask web application. Background removal is a crucial task in image processing and computer vision, allowing users to isolate subjects from their backgrounds. By integrating this functionality into a web application using Flask, we aim to provide users with a convenient and accessible tool for background removal tasks. Throughout this process, we'll explore techniques for image manipulation, integration of third-party libraries, and web development with Flask. By building a background removal tool, we enhance our understanding of image processing algorithms, web application development, and practical applications of computer vision technology.
* Day 55: Multiple Files Renamer
  * Today's focus is on developing a multiple files renamer application. Renaming multiple files in bulk is a common task, especially when organizing files or preparing them for specific purposes. This application will provide users with the ability to select a folder containing files, specify renaming criteria, and execute the renaming process efficiently. By creating this utility, we aim to streamline file management tasks and enhance productivity for users dealing with large numbers of files. Throughout the development process, we'll explore file handling techniques, user interface design, and implementation of renaming algorithms to ensure a robust and user-friendly application.
* Day 56: Technical Test "threeSum" and "threeSumClosest" [LeetCode](https://leetcode.com/problems/)
  Today's focus is on solving technical problems related to array manipulation and algorithmic thinking. We'll tackle two problems from LeetCode:
  * threeSum: Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j, i != k`, and `j != k, and nums[i] + nums[j] + nums[k] == 0`. The solution set must not contain duplicate triplets. [Problem Description](https://leetcode.com/problems/3sum/description/)
  * threeSumClosest: Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. [Problem Description](https://leetcode.com/problems/3sum-closest/description/)
* Day 57: KeyLogger 
  * Today's focus is on developing a KeyLogger application. A KeyLogger is a program that records the keystrokes made by a user on their computer. It's commonly used for various purposes such as monitoring employee activity, parental control, or debugging software. Our KeyLogger application will capture keystrokes and store them in a log file, providing users with the ability to monitor keyboard activity. Through this project, we'll delve into event handling, file I/O operations, and potentially explore additional features such as email notifications for logged keystrokes, enhancing the utility and versatility of the KeyLogger.
* Day 58: Matrix Effect
  * Today's focus is on creating a Matrix Effect, inspired by the iconic "Matrix" movie. This project involves generating a cascading effect of characters resembling the falling code seen in the film. Through this project, we'll explore concepts such as terminal manipulation, randomization, and animation. By implementing this Matrix Effect, we aim to recreate the visually stunning display seen in the movie, offering a fun and engaging coding exercise.
* Day 59: Dice-Rolling [realpython.com](https://realpython.com/python-dice-roll/#step-1-code-the-tui-of-your-python-dice-rolling-app)
  * Today's focus is on implementing a Dice-Rolling application. This project involves creating a Python program to simulate rolling dice. We'll explore concepts such as random number generation, user input validation, and ASCII art for visual representation of dice faces. Additionally, we'll delve into creating a text-based user interface (TUI) for the application. By developing this Dice-Rolling application, we aim to provide users with a fun and interactive way to simulate rolling dice, suitable for various gaming and recreational purposes.
* Day 60: Technical Test "letterCombinations" and "4Sum" [LeetCode](https://leetcode.com/problems/)
  * **Letter Combinations of a Phone Number**: Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. [Problem Description](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)
  * **4Sum**: Given an array `nums` of n integers, return an array of all the unique quadruplets `[nums[a], nums[b], nums[c], nums[d]]` such that:
     - `0 <= a, b, c, d < n`
     - `a, b, c, and d` are distinct.
     - `nums[a] + nums[b] + nums[c] + nums[d] == target`
  You may return the answer in any order. [Problem Description](https://leetcode.com/problems/4sum/)
* Day 61: Anemia Types Classification [Kaggle](https://www.kaggle.com/datasets/ehababoelnaga/anemia-types-classification/data)
  * Today, we focus on anemia types classification using a dataset from Kaggle. This dataset contains CBC (Complete Blood Count) data labeled with the diagnosis of anemia type, collected from several CBCs and diagnosed manually. By analyzing this dataset, we aim to understand the relationships between CBC parameters and different types of anemia. This analysis can provide valuable insights for medical diagnosis and treatment strategies.
* Day 62: Cinema Management System using OOP
  * Today, we delve into a cinema project focusing on Object-Oriented Programming (OOP). The project involves designing classes to simulate various aspects of a cinema system, including movies, rooms, reservations, and the cinema itself. Through this project, we aim to implement key OOP principles such as encapsulation, inheritance, and polymorphism. By structuring the code in an object-oriented manner, we can create a modular and scalable system that effectively models the functionalities of a real-world cinema. This project provides an excellent opportunity to practice OOP concepts while developing a practical application.
* Day 63: Technical Test "removeNthFromEnd" and "isMatch" [LeetCode](https://leetcode.com/problems/).
  * Today's technical test on LeetCode involves two problems:
  * removeNthFromEnd: Given the head of a linked list, remove the nth node from the end of the list and return its head. This problem challenges your ability to manipulate linked lists efficiently. [Problem Description](https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/)
  * isMatch: Implement regular expression matching with support for '.' and '*', where '.' matches any single character and '*' matches zero or more of the preceding element. The matching should cover the entire input string (not partial). [Problem Description](https://leetcode.com/problems/regular-expression-matching/description/).
  
  These problems test your proficiency in data structures and algorithms, particularly in linked list manipulation and dynamic programming. Working on them will enhance your problem-solving skills and algorithmic thinking.
* Day 64: Contour Plots in Matplotlib - Visualize 3D Functions in 2D [NeuralNine](https://www.youtube.com/watch?v=DYn9HdTmt0E)
  * In today's session, we explore how to create contour plots in Matplotlib, a powerful visualization tool in Python. Contour plots allow us to represent 3D functions in 2D, providing a clear view of the function's behavior over a plane. We will generate 2D grids using `numpy.meshgrid` and define various 3D functions to visualize. The session includes creating both surface plots and filled contour plots using Matplotlib's `plot_surface` and `contourf` functions, respectively. This exercise will help you understand how to effectively visualize complex functions, enhancing your data presentation skills and making your plots more informative and visually appealing.
* Day 65: Technical Test "isValidParentheses" and "MergeTwoSortedLists" [LeetCode](https://leetcode.com/problems/).
  * isValidParentheses: Given a string `s` containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if:
      * Open brackets must be closed by the same type of brackets.
      * Open brackets must be closed in the correct order.
      * Every close bracket has a corresponding open bracket of the same type. 
      [Problem Description](https://leetcode.com/problems/valid-parentheses/description/)
  * MergeTwoSortedLists: Given the heads of two sorted linked lists `list1` and `list2`, merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. [Problem Description](https://leetcode.com/problems/merge-two-sorted-lists/description/)
* Day 66: Web Scraping Job Listings with Python
  * In today's session, we delve into the world of web scraping using Python. Our goal is to extract job listings from the Python.org jobs page and save the data into a CSV file. We will use the `requests` library to fetch the HTML content of the webpage and `BeautifulSoup` for parsing the HTML and extracting the job details. The details we will extract include the job title, company name, location, posting date, and job type. After extracting the data, we will write it into a CSV file using Python's `csv` module. This exercise will enhance your skills in web scraping, data extraction, and handling CSV files, providing a practical approach to gather and organize data from web sources.
* Day 67: [TensorFlow](https://www.tensorflow.org/tutorials/keras/regression) Regression (Beginner ~ ML Basics with Keras)
  * Today, we embark on a journey into the basics of regression analysis using TensorFlow and Keras. This tutorial covers the essential steps to build, train, and evaluate regression models. We will start by loading and cleaning the Auto MPG dataset, which includes features like 'Horsepower', 'Weight', and 'Acceleration'. After preprocessing the data, we'll split it into training and testing sets, and normalize it to improve model performance. You'll learn how to construct simple linear regression models, first with a single input and then with multiple inputs. Furthermore, we'll explore more complex models using deep neural networks (DNNs). This hands-on guide will help you understand the fundamentals of regression analysis, model training, evaluation, and making predictions, providing a strong foundation in machine learning with TensorFlow and Keras. 🚗📈🤖
* Day 68: Recursion "SierpinskiTriangle" and "FractalTree".
  * On day 68, we explore the concept of recursion through the creation of two classic fractals: the Sierpinski Triangle and the Fractal Tree. Both examples utilize Python's turtle graphics library to visualize the recursive processes.
    * Sierpinski Triangle: This fractal is formed by recursively subdividing an equilateral triangle into smaller triangles. Each subdivision step reduces the size of the triangles and changes their color based on the recursion depth. This exercise helps in understanding how recursion can break down complex problems into simpler, repeatable tasks.
    * Fractal Tree: This fractal simulates the natural growth patterns of a tree. Starting with a trunk, the tree branches into smaller sub-branches, each at a specific angle and length decrement. By adjusting the recursion depth, angle, and length decrement, different tree shapes and complexities can be generated. This project emphasizes the power of recursion in modeling natural phenomena and visualizing algorithmic patterns.
* Day 69: Ticket management GUI
  * On day 69, we delve into building a web-based Ticket Management System using Flask. This project includes two primary interfaces: one for clients to generate tickets for order claims, and another for providers to manage and track the tickets. The client-side allows users to enter their name, generate a ticket with a unique number, and record the time of generation. The provider-side interface displays the next ticket in the queue along with the current ticket being attended to and which counter is handling it. This system demonstrates the basics of web development with Flask, including form handling, data storage, and dynamic content rendering. By completing this project, you will gain practical experience in creating web applications, managing state, and ensuring smooth interactions between different user roles. 🧾🖥️✨
* Day 70: Scientific GUI Calculator
  * On day 70, we constructed a Graphical User Interface (GUI) for a scientific calculator using the tkinter library in Python. This calculator provides a wide range of mathematical functions, including basic arithmetic operations, trigonometric functions, logarithmic functions, and more. Users can input numerical values, perform calculations, and view results conveniently through the intuitive interface. The calculator's design incorporates various buttons for different mathematical operations, making it easy to use and navigate. By creating this project, you will enhance your skills in GUI development, event handling, and integrating complex mathematical operations into user-friendly applications. 🧮💻🔍
* Day 71: Technical Test "generateParenthesis" and "mergeKLists" [LeetCode](https://leetcode.com/problems/).
  * generateParenthesis: Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
  [Problem Description](https://leetcode.com/problems/generate-parentheses/description/)
  * mergeKLists: You are given an array of `k` linked-lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.[Problem Description](https://leetcode.com/problems/merge-k-sorted-lists/description/)
* Day 72: Knight's Tour Problem Solver
  * On day 72, we explore the classic Knight's Tour problem using Python. This project involves developing an algorithm to find a sequence of moves that allows a knight to visit every square on an N x N chessboard exactly once. The solution employs backtracking to systematically search for a valid tour, ensuring that all board positions are covered without repetition. The implementation includes functions to validate moves, print the board, and recursively attempt to solve the tour from a given starting position. By tackling this problem, you will gain a deeper understanding of recursion, backtracking, and algorithmic problem-solving. This project is an excellent exercise in enhancing your skills in algorithm development and Python programming. ♞📐💡
* Day 73: Tic-Tac-Toe Multiplayer [NeuralNine](https://youtu.be/s6HOPw_5XuY?si=ZlnrpRTxmJiYtGv8)
  * On day 73, we developed a multiplayer Tic-Tac-Toe game using Python. This project allows two players to connect over a network and play Tic-Tac-Toe in real-time. One player hosts the game, while the other player connects to it. The implementation includes setting up a server-client architecture using the socket library and managing game state and turns through a combination of functions for move validation, board updates, and win condition checks. The game uses threading to handle simultaneous communication between players. By completing this project, you will enhance your understanding of network programming, client-server communication, and basic game development in Python. 🎮🕹️💻
* Day 74: Technical Test "twoSum" and "myAtoi" [LeetCode](https://leetcode.com/problems/).
  * twoSum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.
  [Problem Description](https://leetcode.com/problems/two-sum/description/)
  * myAtoi: Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer. The function follows a specific algorithm to ignore leading whitespace, determine the sign, read digits, and handle integer overflow by clamping the result within the 32-bit signed integer range.
  [Problem Description](https://leetcode.com/problems/string-to-integer-atoi/description/)
* Day 75: Spotify Songs Album [Kaggle](https://www.kaggle.com/datasets/zeesolver/spotfy/data)
  * Today, we embark on a journey into the realm of music data analysis with a dataset sourced from Kaggle, focusing on Spotify songs albums. This dataset provides a comprehensive collection of information about various songs, including attributes such as danceability, energy, and acousticness. By delving into this dataset, we aim to uncover intriguing insights into the characteristics of popular songs, trends in music streaming, and the impact of different attributes on song popularity. Through exploratory data analysis and visualization techniques, we will unravel patterns, correlations, and unique features within the dataset, shedding light on the dynamic landscape of the music industry. Join us as we dissect this rich dataset to discover the rhythms and melodies that shape our musical experiences.
* Day 76: Bank Queue Management System
  * Today, we delve into the development of a robust bank queue management system designed for "Su ahorrito". This system aims to streamline the process of managing customer service operations, focusing on assigning and managing customer turns efficiently. Our system encompasses several key functionalities:
    - User Management: Create and manage user profiles, including user ID, name, and client type (General, Preferential1, Preferential2).
    - Turn Assignment: Automatically assign turns to users, categorizing each turn with a specific transaction type (Deposit, Withdrawal, Bill Payment).
    - Customer Service: Facilitate the process of attending to customers, ensuring that completed transactions are recorded and stored systematically.
    - Transaction Analysis: Calculate and display the percentage distribution of different transaction types, providing insights into customer needs and service trends.
    - Turn Management: Enable the removal of specific turns and display the number of turns assigned to each user.
    - Transaction History: Maintain and showcase a history of all completed transactions, ensuring transparency and record-keeping.
Through this project, we aim to enhance the efficiency of customer service in a banking environment by leveraging Python to build an intuitive and effective queue management system. Join us as we implement and explore this essential application, ensuring a smoother experience for both bank staff and customers.
* Day 77: Inventory Management GUI
Today, we embarked on the development of a Graphical User Interface (GUI) for an Inventory Management System. Leveraging the Flask web framework in Python, we crafted an intuitive interface that enables users to efficiently manage their inventory of products. The system offers a range of features to enhance inventory control and streamline operations, including:
  - **Product Management:** Users can easily add, edit, and delete products from the inventory, facilitating seamless product catalog management.
  - **Real-time Inventory Monitoring:** The application provides a comprehensive view of the current inventory status, allowing users to track product quantities and make informed decisions.
  - **Report Generation:** With built-in reporting capabilities, users can generate detailed reports on inventory status, product performance, and more, empowering data-driven decision-making.
  - **Low Stock Alerts:** The system automatically alerts users to products with low stock levels, helping prevent stockouts and optimize inventory replenishment.
  - **Data Export:** Users can export inventory data to CSV or Excel formats for further analysis or integration with external systems.

  By developing this Inventory Management GUI, we aimed to provide businesses with a powerful tool to effectively manage their inventory, improve efficiency, and optimize resource utilization. Join us as we continue to explore the intersection of technology and business operations, empowering organizations to thrive in today's dynamic marketplace. 📦💻📊
* Day 78: Technical Test "swapPairs" and "reverseKGroup" [LeetCode](https://leetcode.com/problems/).
  * swapPairs: Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed) [Problem Description](https://leetcode.com/problems/swap-nodes-in-pairs/description/)
  * reverseKGroup: Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k, then the left-out nodes at the end should remain as they are. You may not alter the values in the list's nodes, only nodes themselves may be changed. [Problem Description](https://leetcode.com/problems/reverse-nodes-in-k-group/description/)
* Day 79: Minesweeper GUI Pygame
  * Today, we're diving into the development of a Minesweeper game with a Graphical User Interface (GUI) using Pygame. This classic game challenges players to uncover hidden mines on a grid-based board without detonating any of them. Our implementation leverages Pygame's intuitive interface to provide an engaging and immersive gaming experience. Players can reveal tiles, flag potential mines, and navigate through various difficulty levels or customize their game settings. Join us as we explore the world of game development with Python and Pygame, bringing the timeless excitement of Minesweeper to life in a modern and visually appealing format. 🕹️💣🎮
* Day 80: Student Practice Management System
  * Today, we developed a Python-based system to manage student internships. This system features:
    - **Practice Registration**: Capture student details, company name, and practice duration.
    - **Internship Tracking**: Monitor ongoing practices with detailed views.
    - **Average Duration Calculation**: Display the average length of internships.
    - **Company-Specific Intern Count**: Determine the number of interns per company.
    - **Company Update for Practices**: Modify the company associated with a student's practice.
    - **User-Friendly Menu Interface**: Easily navigate and interact with the system.

  This system aims to streamline the management of student internships, benefiting both students and administrators. 🎓🏢📊
* Day 81: Random Roulette
  * Today, we're building a Random Roulette web application using Flask. This app allows users to add and modify options for the roulette, and then spin to select a random option. With Flask's lightweight and flexible framework, we'll create an interactive and dynamic web interface where users can easily manage their options. The application features a simple design with an intuitive navigation system, ensuring a seamless user experience. Join us as we delve into web development with Flask, creating a fun and functional tool for making random selections. 🎡🔄✨
* Day 82: Test Projects "celsius_to_fahrenheit"
  * Today, we're focusing on writing unit tests for a simple function that converts temperatures from Celsius to Fahrenheit. Testing is a crucial part of software development, ensuring that our code works as expected and helps prevent bugs from creeping into our projects. We'll use Python's unittest module to create and run our tests. This exercise will help you understand the basics of writing tests and how to use them to verify the correctness of your code.
* Day 83: Technical Test "removeDuplicates" and "removeElement" [LeetCode](https://leetcode.com/problems/).
  * removeDuplicates: Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums. [Problem Description](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)
  * removeElement: Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val. [Problem Description](https://leetcode.com/problems/remove-element/description/)
* Day 84: Complaint Management System
  * Today, we developed a Python-based system to manage complaints for the General Prosecutor's Office. This system features:
    - **Complaint Creation**: Record details such as complainant, accused, date, type, and unique code.
    - **Complaint Deletion**: Remove complaints using a unique code.
    - **Sublist Creation**: Generate a sublist of complaints involving a specific person.
    - **Type-Based Percentage Calculation**: Calculate the percentage of each type of complaint.
    - **Complaint Display**: Show all registered complaints.
    - **Date Modification**: Update the date of a specific complaint.
    - **User-Friendly Menu Interface**: Easily navigate and interact with the system.

  This system is designed to streamline the management of complaints, making it easier for the General Prosecutor's Office to handle and organize them effectively. 📅📝🔍
* Day 85: Convert Word Files To PDF [NeuralNine](https://www.youtube.com/watch?v=i57uYpW5Ng8)
  * Today, we worked on a project to convert Word files (.docx) to PDF format. This project was inspired by a video tutorial from NeuralNine. While the tutorial provided the basic functionality for converting a single DOCX file to PDF, we expanded the project by adding several new features:
    - **Graphical User Interface (GUI)**: Using `tkinter`, we created an intuitive interface that allows users to easily select files and specify output options.
    - **Single File Conversion**: Users can convert a single DOCX file to PDF by selecting the file and choosing a destination.
    - **Multiple File Conversion**: Users can select multiple DOCX files and convert them all to PDF at once, saving the converted files in a specified directory.
    - **Error Handling**: The application includes robust error handling to inform users of any issues during the conversion process.
    - **User Notifications**: After a successful conversion, the application provides a notification to the user.
    
  These enhancements make the tool more user-friendly and versatile, offering a complete solution for converting Word documents to PDF efficiently.

* Day 86: Goldner-Harary Graph in 3D
  * Today, we explored the fascinating world of graph theory by creating and visualizing the Goldner-Harary graph in 3D. This project helped us understand the properties of planar graphs and verify Euler's formula. Here are the key features and steps we implemented:
    - **Graph Construction**: We created the Goldner-Harary graph, which consists of 11 vertices and 27 edges.
    - **3D Visualization**: Using `matplotlib` and `networkx`, we plotted the graph in a 3D space, providing a comprehensive visual representation of its structure.
    - **Planarity Check**: We verified the graph's planarity, confirming that it can be drawn on a plane without any edges crossing.
    - **Euler's Formula Verification**: We checked Euler's formula (v - e + f = 2) for the graph, ensuring it holds true for planar graphs.
    - **Graph Information**: We displayed essential information about the graph, including the number of vertices, edges, and faces.
    
  This project not only enhanced our understanding of graph theory but also provided practical experience with 3D data visualization techniques. The Goldner-Harary graph, with its complex structure, served as an excellent example for studying planar graphs and their properties. 🌐📊🔍
* Day 87: Building Management System
  * Today, we developed a Python-based Building Management System. This system offers functionalities such as generating invoices, making payments, and tracking property ownership. Key features include:
    - **Invoice Generation**: Automatically generate monthly invoices for property owners.
    - **Payment Processing**: Record and manage payments made by proprietors.
    - **Account Statements**: Generate account statements for proprietors, detailing payments and dues.
    - **Delinquency Monitoring**: Identify delinquent apartments based on overdue balances.
    
  This system streamlines property management tasks, enhancing efficiency and organization. 🏢💼💰
* Day 88: Technical Test "strStr" and "divide" [LeetCode](https://leetcode.com/problems/).
  * strStr: Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. This classic problem tests your ability to efficiently search substrings within a larger string. [Problem Description](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)
  * divide: Given two integers, dividend and divisor, divide them without using multiplication, division, and mod operator. Ensure the result is truncated toward zero. This problem challenges you to implement efficient division using basic arithmetic operations. [Problem Description](https://leetcode.com/problems/divide-two-integers/description/)
* Day 89: Dragon Ball Radar Animation with DBSCAN Clustering
  * Today, we crafted an animated Dragon Ball radar using Python, leveraging DBSCAN clustering to detect clusters of Dragon Balls. Here's a breakdown of what we accomplished:
    - **Radar Animation**: We animated a radar line sweeping through 360 degrees, simulating the iconic Dragon Ball radar from the anime series.
    - **DBSCAN Clustering**: Utilizing the DBSCAN algorithm, we clustered randomly generated Dragon Ball positions, mimicking their distribution across the radar's range.
    - **Cluster Visualization**: Each cluster of Dragon Balls was represented by a yellow point on the radar, with the number of Dragon Balls in each cluster displayed alongside.
    - **Interactive Animation**: The animation included blinking points and text to add dynamism and visual appeal to the radar display.

  This project blends entertainment with data science, offering a playful yet educational exploration of clustering algorithms and animated visualizations. 🐉🔍✨
* Day 90: Pong Game Development in Python
  * Today, we developed a classic Pong game using Python and the Pygame library. Here's a summary of our progress:
    - **Game Mechanics**: We implemented the basic mechanics of Pong, including ball movement, paddle control, and collision detection.
    - **Scoring System**: A scoring system was added, with the game ending when a player reaches 5 points. The score is displayed on the screen, and a winning message is shown at the end.
    - **Paddle Customization**: The paddles were given distinct colors (red for the left paddle and blue for the right paddle) to enhance the visual appeal.
    - **Smooth Animation**: The game runs smoothly at 60 frames per second, providing a responsive and enjoyable gaming experience.

  This project demonstrates the fundamentals of game development in Python, showcasing the power and flexibility of Pygame for creating interactive applications. 🎮🚀✨
* Day 91: Flask-based Online Survey Application
  Today, we created a Flask-based Online Survey Application. This project allows users to create surveys and participate in them. Key functionalities include:

    - **Survey Creation**: Users can create new surveys with customizable options.
    - **Survey Participation**: Other users can vote in existing surveys.
    - **Results Display**: The application displays results for each survey, showing the distribution of votes.
    
  This project aims to provide a straightforward platform for conducting surveys online, enhancing user engagement and feedback collection. 📊🖥️✅
* Day 92: Tower of Hanoi and N Queens Problem Solutions
  * Today, we implemented solutions to the classic Tower of Hanoi and N Queens problems in Python. Here's a summary of our progress:
    - **Tower of Hanoi**: We developed a recursive function to solve the Tower of Hanoi problem, which involves moving disks from one peg to another according to specific rules. The function efficiently moves disks from the source peg to the target peg using an auxiliary peg.
    - **N Queens Problem**: We implemented a backtracking algorithm to solve the N Queens problem, which involves placing N queens on an NxN chessboard such that no queen attacks another. The algorithm ensures that each queen is placed safely by checking for conflicts with other queens in the same row, column, or diagonal.

  These projects demonstrate the power of Python for solving complex problems and the importance of recursion and backtracking in solving these types of problems. 🎯👑

* Day 93: Word Search Puzzle GUI
  * Today, we created a graphical user interface (GUI) for a word search puzzle using Python's Tkinter library. Here's an overview of what we accomplished:
    - **Word Entry**: We added an input field for users to enter words (comma-separated) which will be hidden in the word search grid.
    - **Grid Generation**: We implemented a function to generate a grid filled with random letters, ensuring that the words are placed in random directions (horizontal, vertical, diagonal).
    - **Word Selection**: We enabled cell selection in the grid. Selected cells highlight in yellow until a word is completely formed. If the word is valid, the cells change to green, indicating that the word has been found. If not, the cells revert to their original state.
    - **Word List Display**: The words are displayed on the right side of the interface. Found words are struck through.
    - **Timer**: We added a configurable timer (5 to 10 minutes) that counts down. If the user doesn't find all the words within the time limit, a message prompts them to try again.
    - **Solve Button**: A centrally placed "Solve" button highlights all the words in the grid, assisting the user in finding the words.
    - **Completion and Reset**: Upon finding all the words or the timer running out, the user is prompted to play again, allowing the game to reset.

  This project demonstrates the integration of Python with Tkinter to create interactive applications, enhancing user experience and interface design. 🧩🕹️

* Day 94: Technical Test "findSubstring" and "nextPermutation" [LeetCode](https://leetcode.com/problems/).
  * findSubstring: Given a string `s` and an array of strings `words`, find all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once and without any intervening characters. [Problem Description](https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/)
  * nextPermutation: Implement the next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order). The replacement must be in place and use only constant extra memory. [Problem Description](https://leetcode.com/problems/next-permutation/description/)
* Day 95: PhishGuard - Anti-Phishing Email and Website Filter
  * Today, we developed a phishing protection filter called **PhishGuard** using Python. Here's an overview of what we accomplished:
    - **Keyword Detection**: Implemented a function to identify phishing keywords in email content.
    - **URL Analysis**: Extracted and analyzed URLs from emails, checking them against a list of known phishing domains.
    - **Email Filtering**: Created a filter to process a list of emails, blocking those identified as phishing attempts.
    - **Hotmail Example**: Tested the filter with example Hotmail emails to demonstrate its effectiveness.
      
  This project highlights how Python can be used to enhance email security by detecting and blocking potential phishing attacks. 🛡️📧
* Day 96: World Clock GUI
  * Today, we developed a **World Clock GUI** using Python and Tkinter. Here's an overview of what we accomplished:
    - **Time Zone Updates**: Implemented a function to update and display the current time for multiple time zones including Colombia, New York, China, Germany, and Norway.
    - **GUI Design**: Created a user-friendly graphical interface with labeled clocks for each time zone, enhancing the visual appeal and usability.
    - **Icon and Flags**: Added an application icon and country flags to represent each time zone, providing a clear and engaging visual representation.
    - **Dynamic Updates**: Ensured the clock times are updated dynamically every second, keeping the displayed times accurate.

  This project showcases how Python can be used to create a functional and visually appealing world clock application. 🕒🌍
* Day 97: Pipelines for inference [🤗 Transformers](https://huggingface.co/docs/transformers/pipeline_tutorial)
  * Today, I explored the powerful pipeline feature from the Hugging Face Transformers library to perform automatic speech recognition (ASR) and text generation tasks. Here's a summary of what I accomplished:
    - **Automatic Speech Recognition**: Utilized the `pipeline()` function for ASR to transcribe audio files into text. Implemented and tested the OpenAI Whisper model for improved accuracy.
    - **Batch Processing**: Leveraged batch processing to handle multiple audio files efficiently, enhancing the pipeline's performance on a GPU.
    - **Task-Specific Parameters**: Experimented with parameters such as `return_timestamps` for subtitling and `chunk_length_s` for processing long audio files, demonstrating the flexibility of the pipeline.
    - **Device Management**: Configured the pipeline to run on the appropriate device (CPU or GPU) based on availability, optimizing computational resources.
    - **Dataset Integration**: Integrated the pipeline with datasets to perform inference on large datasets, showing the capability of the pipeline to handle extensive data inputs seamlessly.

  This project highlights the versatility and ease of using Hugging Face's pipeline feature for various NLP and ASR tasks, showcasing the practical applications of machine learning models in real-world scenarios.
* Day 98: Vehicle Management System
  * Today, I developed a Vehicle Management System to help the Universidad de Envigado manage the vehicles that enter and exit the campus. The system identifies each vehicle by its license plate and entry date. Here's a summary of what I accomplished:
    - **Vehicle Entry**: Implemented functionality to add a vehicle to the active vehicles list and log its entry time.
    - **Vehicle Exit**: Created a method to remove a vehicle from the active list and log its exit in the history.
    - **Date-Specific Entry Count**: Added a feature to determine the number of vehicles that entered the campus on a specific date.
    - **Entry Count by Vehicle**: Developed a function to list the number of times a specific vehicle has entered the campus.
    - **User-Friendly Menu**: Designed an interactive menu for users to manage vehicle entries and exits, check vehicle counts, and handle inputs gracefully, including validation for empty inputs.

  This project showcases the application of object-oriented programming principles to solve real-world problems, providing an efficient solution for managing campus vehicle traffic. The user-friendly interface ensures ease of use, while robust input validation enhances reliability.
* Day 99: 🌬️ Asthma Disease Dataset 🌬️ [Kaggle](https://www.kaggle.com/datasets/rabieelkharoua/asthma-disease-dataset/data)
  * Today, I worked with the Asthma Disease Dataset from Kaggle, aiming to analyze and model the factors contributing to asthma diagnosis. Here's a summary of what I accomplished:
    - **Data Exploration and Cleaning**: Conducted an initial exploration of the dataset to understand its structure and identify missing values. Cleaned the data by handling missing values and irrelevant columns.
    - **Feature Analysis**: Performed an exploratory data analysis (EDA) to visualize distributions of numerical features, correlations, and demographic insights. Created plots to understand the relationships between various factors and asthma diagnosis.
    - **Descriptive Statistics**: Calculated and interpreted key statistics for age distribution, gender, ethnicity, and education level among diagnosed and non-diagnosed patients.
    - **Pie Charts and Histograms**: Generated pie charts for categorical variables like ethnicity, gender, and education level. Plotted histograms for age distribution of diagnosed patients to identify trends.
    - **Correlation Heatmap**: Created a heatmap to visualize correlations between numerical features, helping to identify significant relationships.
    - **Model Training and Evaluation**: Developed and evaluated several machine learning models, including Logistic Regression, Random Forest, Gradient Boosting, Support Vector Machine, XGBoost, and K-Nearest Neighbors. Assessed model performance using accuracy and ROC AUC scores.
    - **Scaling and Splitting Data**: Preprocessed the data by scaling features and splitting it into training and testing sets to ensure robust model evaluation.

  This project highlights the importance of data preprocessing, exploratory analysis, and model evaluation in the context of medical data. The insights and models developed can help in understanding the factors influencing asthma diagnosis and potentially aid in early detection and prevention strategies.
* Day 100: 🎮 2048 Game with Flask 🎮

  * Today, I created a web-based 2048 game using Flask. The project involved building the game logic, setting up a server, and creating a responsive user interface. Here's a summary of what I accomplished:
    - **Flask Application Setup**: Initialized a Flask application to handle game logic and API endpoints. Defined routes for starting a new game, making moves, and autoplay functionality.
    - **Game Logic Implementation**: Developed functions to initialize the game board, add new tiles, and perform moves in all directions (left, right, up, down). Ensured that the game logic correctly merges tiles and adds new ones after each move.
    - **Autoplay Feature**: Implemented an autoplay feature that simulates moves automatically until the game ends. This feature helps demonstrate the game mechanics and provides a way to observe strategies for achieving higher scores.
    - **Game Over Check**: Added functionality to detect when the game is over, offering the option to restart the game and encouraging continuous play.
    - **User Interface Design**: Created a responsive UI using HTML and CSS, ensuring the game board is centered and visually appealing. Applied a dark background for better visibility and user experience.
    - **Styling with CSS**: Separated CSS into an external file, focusing on clean design and readability. Styled the board and cells to clearly display game states and centered numbers within their cells.
    - **JavaScript Integration**: Moved JavaScript code to an external file for better organization. Handled user input for moves, board rendering, and autoplay functionality.
    - **Restart Option**: Added a restart button to allow users to start a new game when the current game ends.
    - **Enhanced User Experience**: Improved the overall user experience by ensuring smooth interactions, clear game states, and responsive design elements.

  This project demonstrates the integration of front-end and back-end technologies to create an interactive web application. It highlights the importance of clean code organization, user-centric design, and robust game logic implementation. The 2048 game serves as a fun and engaging way to explore web development with Flask.

* Day 101: Technical Test "longestValidParentheses" and "search" [LeetCode](https://leetcode.com/problems/).
  * longestValidParentheses: Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. [Problem Description](https://leetcode.com/problems/longest-valid-parentheses/description/)
  * search: Given an array of integers `nums` sorted in ascending order, which is possibly rotated at an unknown pivot, and an integer `target`, find the index of `target` in `nums` or return -1 if it is not in `nums`. The algorithm must run in O(log n) time complexity. [Problem Description](https://leetcode.com/problems/search-in-rotated-sorted-array/description/)

* Day 102: 🍦 Object-Oriented Programming in Python with Ice Cream Example 🍦

  * Today, I explored the fundamentals of Object-Oriented Programming (OOP) in Python using a fun and relatable example: an ice cream shop. This project highlights the six basic principles of OOP—inheritance, cohesion, abstraction, polymorphism, coupling, and encapsulation. Here's a summary of what I accomplished:

    - **Abstraction and Encapsulation**: Created an abstract base class `IceCream` to represent the common attributes and behaviors of all ice creams. Encapsulated the flavor and price attributes to protect them from direct modification.
    - **Inheritance**: Developed two subclasses, `ScoopIceCream` and `Sundae`, inheriting from the `IceCream` class. These subclasses extend the base class by adding specific attributes like the number of scoops and toppings.
    - **Polymorphism**: Implemented a function `print_ice_cream_details` that takes any `IceCream` object and prints its details. This demonstrates how different ice cream objects can be handled through a single interface.
    - **Cohesion**: Ensured each class has a single, well-defined responsibility. For example, `ScoopIceCream` handles the specifics of scoop-based ice cream, while `Sundae` manages sundae-specific attributes.
    - **Coupling**: Maintained loose coupling between classes to ensure that changes in one class minimally affect others. This was achieved through well-defined interfaces and clear separation of responsibilities.
    - **Encapsulation**: Used private attributes to encapsulate the internal state of the objects, providing getter methods to access the values.
* Day 103: [TensorFlow](https://www.tensorflow.org/tutorials/keras/text_classification_with_hub) Text classification with TF Hub

  * Today, I explored text classification using TensorFlow Hub and TensorFlow Datasets. This project focused on building a neural network model to classify movie reviews as positive or negative. Here's a summary of what I accomplished:

    - **Data Loading and Preparation**: Utilized TensorFlow Datasets to download and prepare the IMDB dataset, splitting it into training, validation, and test sets.
    - **Exploration**: Examined the dataset to understand its structure and content. Each example in the dataset consists of a movie review (text) and a corresponding label (0 for negative, 1 for positive).
    - **Text Embedding**: Leveraged a pre-trained text embedding from TensorFlow Hub to convert sentences into embedding vectors. This approach simplifies text preprocessing, benefits from transfer learning, and provides a fixed-size output.
    - **Model Building**: Constructed a neural network model using Keras Sequential API. The model includes:
      - A TensorFlow Hub layer for text embedding.
      - A Dense layer with 16 hidden units and ReLU activation.
      - A Dense output layer with a single unit for binary classification.
    - **Loss Function and Optimizer**: Configured the model with the `binary_crossentropy` loss function and the Adam optimizer. This setup is suitable for binary classification tasks.
    - **Model Training**: Trained the model for 10 epochs using mini-batches of 512 samples, monitoring the loss and accuracy on the validation set.
    - **Model Evaluation**: Evaluated the model on the test set to measure its performance, reporting both loss and accuracy.

  This project demonstrates the application of TensorFlow and TensorFlow Hub for natural language processing tasks. It highlights the importance of using pre-trained models for efficient text embedding and the benefits of a well-structured neural network for text classification.
* Day 104: Battleship Game with Flask
  * Today, I developed a Battleship game using Flask, a micro web framework for Python. This project involved creating a web-based version of the classic Battleship game, where users can guess the locations of ships on a grid. Here's a summary of what I accomplished:

    - **Setting Up Flask Application**: Initialized a Flask project, set up routes, and managed sessions to maintain game state between requests.
    - **Game Logic Implementation**: Implemented the core game logic in Python, including functions for creating ships, processing user guesses, and checking for game over conditions.
    - **Session Management**: Utilized Flask sessions to store the hidden and guess boards, ensuring the game state is preserved between user interactions.
    - **User Interface**: Developed HTML templates using Jinja2 to render the game board and provide a user-friendly interface. Included labels for rows and columns to guide the user.
    - **Game Mechanics**: Added functionality to handle user guesses, update the game board, and provide feedback on hits and misses. Also implemented logic to reveal ship locations if the user runs out of turns.

  This project showcases how to build a simple yet interactive web application with Flask. It emphasizes the importance of session management in web applications and demonstrates how to create a dynamic user interface with Jinja2 templates. Additionally, it illustrates the implementation of classic game mechanics in a web-based environment.

* Day 105: Technical Test "searchRange" and "searchInsert" [LeetCode](https://leetcode.com/problems/).

  - **searchRange**: Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given target value. If the target is not found in the array, return [-1, -1]. The algorithm must run in O(log n) time complexity.
  [Problem Description](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/)
    
  - **searchInsert**: Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. The algorithm must run in O(log n) time complexity. [Problem Description](https://leetcode.com/problems/search-insert-position/description/)
* Day 106: Create a Multipage App with Streamlit [Streamlit Tutorial](https://docs.streamlit.io/get-started/tutorials/create-a-multipage-app)
  * Today, I focused on building a multipage web application using Streamlit, a popular open-source app framework for Machine Learning and Data Science projects. This project involved creating a web application that can navigate between different pages, each displaying unique content or functionality. Here's a summary of what I accomplished:

    - **Setting Up Streamlit Environment**: Installed Streamlit and set up the development environment.
    - **Creating Pages**: Developed multiple pages for the application, each serving a distinct purpose. For example, a home page, a data visualization page, and a user input page.
    - **Navigation Implementation**: Implemented a navigation system to switch between different pages. Used Streamlit’s built-in components to create a user-friendly interface for navigation.
    - **Dynamic Content**: Ensured each page displays dynamic content based on user interactions. For instance, visualizations that update based on user input or data selections.
    - **User Interface Design**: Designed the layout and style of the application to make it intuitive and visually appealing. Leveraged Streamlit’s layout options and widgets to enhance the user experience.

  This project showcases the versatility of Streamlit in creating interactive and multipage web applications. It emphasizes the ease of setting up a multi-page structure and the ability to integrate dynamic content seamlessly. This was an excellent exercise in web development and user interface design, demonstrating how to build comprehensive applications using Streamlit.
* Day 107: Twenty One Card Game GUI
  * Today, I developed a Twenty-One card game (similar to Blackjack) in Python. This project involved creating the core game logic, displaying cards, handling user interactions, and implementing the rules of the game. Here's a summary of what I accomplished:

    - **Card Display Function**: Created a function to display cards in a visually appealing format using ASCII art. This function helps players see their cards and the dealer's cards clearly.
    - **Random Card Generation**: Implemented a function to generate random cards, ensuring a mix of suits and values for each game.
    - **Card Value Calculation**: Developed a function to calculate the value of each card, considering the special case for Aces, which can be worth either 1 or 11 points.
    - **Game Logic**: Implemented the main game loop, handling the player's turn and the dealer's turn, including decision-making processes and win/lose conditions.
    - **User Interaction**: Added functionality for user input to decide whether to continue playing or stop, and to determine if the player wants to try again after a game ends.

  This project demonstrates the implementation of a classic card game using Python, focusing on interactive gameplay and dynamic card management. It emphasizes the importance of user-friendly design and accurate game mechanics.
* Day 108: Character-Level Language Model with RNN
  * Today, I developed a simple character-level language model using Recurrent Neural Networks (RNN) with TensorFlow and Keras. This project involved creating a model to predict the next character in a sequence of text. Here's a summary of what I accomplished:

    - **Text Preparation**: Prepared the input text by creating mappings from characters to indices and vice versa. Split the text into sequences for training.
    - **Dataset Creation**: Generated training data by creating overlapping sequences of characters and the corresponding next character to predict.
    - **Model Building**: Constructed an RNN model using Keras. The model includes:
      - An Embedding layer to learn character embeddings.
      - A SimpleRNN layer to capture sequential dependencies.
      - A Dense output layer with softmax activation to predict the next character.
    - **Model Compilation**: Compiled the model using categorical cross-entropy loss and the Adam optimizer.
    - **Model Training**: Trained the model on the prepared dataset, using a batch size of 2 and running for 100 epochs.
    - **Prediction Function**: Implemented a function to predict the next character given a sequence of characters. This function uses the trained model to generate predictions.

  This project showcases the process of building a character-level language model using RNNs. It emphasizes the importance of text preprocessing, sequence generation, and model training for sequential data tasks. The model is capable of predicting the next character in a sequence, demonstrating the potential of RNNs in natural language processing.
* Day 109: PolarsVSPandas (Polars Is The Faster Pandas) [NeuralNine](https://www.youtube.com/watch?v=zthI91ASV58)
  * Today, I explored the performance differences between Pandas and Polars for data manipulation tasks. This project was inspired by NeuralNine's video on Polars being faster than Pandas. Here's a summary of what I accomplished:

    - **Data Preparation**: Created a dataset with 120,000 rows of random data using NumPy.
    - **DataFrame Creation**: Generated DataFrames using both Pandas and Polars to compare their performance.
    - **Reading Data**: Measured the time taken to read the data into Pandas and Polars DataFrames.
    - **Aggregation**: Performed aggregation operations to calculate the mean of column 'B' and the sum of column 'C' grouped by column 'A'.
    - **Filtering**: Filtered the data to include only rows where column 'A' is greater than 50.
    - **Joining**: Conducted join operations to merge two DataFrames on column 'A'.
    - **Conditional Column Addition**: Added a new column to a DataFrame based on a condition using both Pandas and Polars.

  This project demonstrates the significant performance improvements that Polars offers over Pandas for certain data manipulation tasks. It highlights the importance of choosing the right tools for data processing to achieve efficient and scalable solutions. Special thanks to NeuralNine for the step-by-step guide provided in his video.

* Day 110: Technical Test "isValidSudoku" and "solveSudoku" [LeetCode](https://leetcode.com/problems/).

  - **isValidSudoku**: Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
    - Each row must contain the digits 1-9 without repetition.
    - Each column must contain the digits 1-9 without repetition.
    - Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
    Note:
    - A Sudoku board (partially filled) could be valid but is not necessarily solvable.
    - Only the filled cells need to be validated according to the mentioned rules.
    [Problem Description](https://leetcode.com/problems/valid-sudoku/description/)
    
  - **solveSudoku**: Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules:
    - Each of the digits 1-9 must occur exactly once in each row.
    - Each of the digits 1-9 must occur exactly once in each column.
    - Each of the digits 1-9 must occur exactly once in each of the nine 3x3 sub-boxes of the grid.
    The '.' character indicates empty cells.
    [Problem Description](https://leetcode.com/problems/sudoku-solver/description/)
* Day 111: Library Management System

  - Today, I developed a Flask-based system for managing books, members, loans, and returns in a library setting. Data storage is handled using JSON files.
    - **Features**:
      - **Books Management**: Add, view, and list books.
      - **Members Management**: Add and list members.
      - **Loans Management**: Loan and return books with member associations.
    - **Technologies**: Flask, JSON, HTML/CSS.
    - **Project Structure**:
      - **app.py**: Flask application handling routes and data operations.
      - **templates/**: HTML templates for rendering pages.
      - **static/**: CSS styles for frontend.
    - **Future Enhancements**: Implement editing and deletion functionalities for books and members, search functionality, and user authentication.
* Day 112: Maze Generator and Solver
  - **Maze Generator**: Implemented a recursive maze generator using the turtle graphics library in Python. The maze is generated by moving the turtle to adjacent cells based on the least visited neighbors.
  - **Maze Solver**: Developed a recursive solver to find the path from the start to the end of the maze. The path is drawn using a different color to indicate the solution.

  This project showcases the use of recursive algorithms for generating and solving mazes, highlighting the power of Python's turtle graphics library for visualizing the process.
* Day 113: Basketball Scoreboard in Flask

  - **Basketball Scoreboard**: Created a web application using Flask to simulate a basketball scoreboard. The scoreboard allows users to input the names of the home and away teams, track scores (1-point, 2-point, and 3-point baskets), fouls, and display the current quarter or overtime. The game progresses through regular quarters, halftime, and overtime periods as needed, with a final winner determined based on scores.

  This project demonstrates the use of Flask for web development and real-time updating of game states, showcasing interactive elements like score tracking, foul recording, and game progression logic.
* Day 114: Internet Speed Test Application

  - **Internet Speed Test Application**: Developed a desktop application using Tkinter to measure internet speed. The application tests the download and upload speed as well as the ping of the user's internet connection. Results are displayed in the application window in real-time.

    - **Speed Test**: Utilized the Speedtest library to measure download and upload speeds in Mbps, and ping in milliseconds. The results are displayed in a user-friendly format.
    - **User Interface**: Designed a simple and intuitive GUI using Tkinter, with buttons to start the speed test, display information about the application, and exit the program.
    - **Information Dialog**: Added an information dialog box to provide users with details about the application's functionality.

  This project demonstrates the use of Tkinter for building desktop applications and integrating third-party libraries to perform real-time internet speed tests.
* Day 115: Steganography Application using Flask

  - **Steganography Application**: Developed a web application using Flask to hide and reveal secret messages within images using the Stegano library. This project involved creating a user-friendly interface for uploading images and entering messages to hide or reveal.

    - **Hide Message**: Implemented functionality to allow users to upload an image and input a message, which is then hidden within the image using the LSB (Least Significant Bit) method provided by the Stegano library. The resulting image is saved and displayed to the user.
    - **Reveal Message**: Added functionality to upload an image and extract any hidden message from it. The extracted message, if any, is displayed to the user along with the image.
    - **User Interface**: Designed a clean and intuitive web interface with routes for hiding and revealing messages, ensuring ease of use and smooth user experience.

    This project demonstrates the use of Flask for building web applications, integrating third-party libraries for steganography, and handling file uploads and processing.
* Day 116: Technical Test "countAndSay" and "combinationSum" [LeetCode](https://leetcode.com/problems/).

  - **countAndSay**: Generate the nth term in the count-and-say sequence. The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
    - countAndSay(1) = "1"
    - countAndSay(n) is the run-length encoding of countAndSay(n - 1).
    
    For example, to compress the string "3322251" using run-length encoding, replace "33" with "23", replace "222" with "32", replace "5" with "15" and replace "1" with "11". Thus the compressed string becomes "23321511".
    [Problem Description](https://leetcode.com/problems/count-and-say/description/)

  - **combinationSum**: Return a list of all unique combinations of candidates where the chosen numbers sum to a given target. Each number in candidates may be used an unlimited number of times in the combination. Two combinations are unique if the frequency of at least one of the chosen numbers is different.

    Given an array of distinct integers `candidates` and a target integer `target`, this problem finds all unique combinations of candidates that sum to the target. The test cases are generated such that the number of unique combinations that sum up to the target is less than 150 combinations for the given input.
    [Problem Description](https://leetcode.com/problems/combination-sum/description/)
* Day 117: Recursion "BinaryTreeExpressionEvaluator"
  * This project defines a binary tree where each node can be a numeric value or an operator. It evaluates the expression represented by the binary tree using recursion. The supported operations are addition, subtraction, multiplication, division, and exponentiation.
  
  - **TreeNode Class**: A class that represents a node in the binary tree.
    - `value`: The value of the node, which can be an integer (leaf node) or an operator (internal node).
    - `left`: The left child node.
    - `right`: The right child node.
  
  - **evaluate_tree Function**: A function that evaluates the binary tree to compute the result of the expression it represents.
    - It takes the root node of the binary tree as an argument.
    - It returns the result of the expression as an integer or float.
    - It raises a `ValueError` if there is an attempt to divide by zero.
  
  - **Example Usage**: The project includes an example usage of creating a binary tree for the expression `((3 + 2) * (4 - 1)) ^ 2` and evaluating it to get the result.

  This project showcases the power of recursion in evaluating complex expressions represented by binary trees, highlighting the versatility of binary trees in computational problems.
* Day 118: Shirt Store
  * Implemented a Python application for managing a shirt store using object-oriented programming concepts. The application allows users to add shirts to the store's inventory, manage customer interactions including adding to cart and purchasing, and view store and customer details.
* Day 119: Household Basket
  - **Household Basket Application**: Developed a desktop application using Tkinter to manage household items in a basket, including fruits, vegetables, meat, dairy, and other categories. The application connects to an SQLite database to store and manage the items.

    - **Add Item**: Implemented functionality to add items to the household basket. Users can select a category, enter the name and quantity of the item, and add it to the database. Validation ensures proper input for name and quantity fields.
    - **View Items**: Added a treeview to display all items in the household basket. Users can see the item ID, category, name, and quantity.
    - **Delete Item**: Included functionality to delete selected items from the basket. Users can select an item from the treeview and remove it from the database with a single click.
    - **Database Management**: Utilized SQLite to create a persistent storage solution for the household basket items. Functions were developed to create the table, insert items, retrieve items, and delete items from the database.
    - **User Interface**: Designed a user-friendly and responsive interface with Tkinter, ensuring a smooth user experience. The interface includes input fields, buttons, and a treeview to manage and display items effectively.
* Day 120: Copa America 2024 Groups [Dataset](https://en.wikipedia.org/wiki/2024_Copa_Am%C3%A9rica)
  - **Copa America 2024 Groups**: Developed a Python script to scrape and process data from the Wikipedia page for the 2024 Copa América, extracting the group stage tables and organizing them into a dictionary for easy access and manipulation.
    - **Data Scraping**: Used the `pandas` library to read all tables from the Wikipedia page, focusing on the relevant indices to extract the tables for Groups A to D.
    - **Data Processing**: Renamed the second column of each table to "Team" and removed the "Qualification" column for cleaner data representation.
    - **Data Organization**: Stored the processed tables in a dictionary, with group letters as keys for easy retrieval and display.
    - **Data Persistence**: Saved the dictionary to a file using the `pickle` library for persistent storage and later use.
* Day 121: Technical Test "combinationSum2" and "firstMissingPositive" [LeetCode](https://leetcode.com/problems/).
  - **combinationSum2**: Find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination, and the solution set must not contain duplicate combinations. This problem involves using a backtracking approach to explore all possible combinations, ensuring that no duplicates are included in the result set. [Problem Description](https://leetcode.com/problems/combination-sum-ii/description/)

  - **firstMissingPositive**: Return the smallest positive integer that is not present in an unsorted integer array `nums`. The algorithm must run in O(n) time and use O(1) auxiliary space. The solution involves rearranging the array so that each positive integer `n` is placed at index `n-1`. Then, the first index that does not contain the correct integer indicates the missing positive integer. [Problem Description](https://leetcode.com/problems/first-missing-positive/description/)
* Day 122: Recursion "Knapsack"

  * This project tackles the Knapsack problem using both recursive and dynamic programming approaches. The Knapsack problem is a classic algorithmic problem that involves selecting items with given weights and values to maximize the total value without exceeding the weight capacity.

  - **knapsack_recursive Function**: A recursive function to solve the Knapsack problem.
    - `weights`: A list of weights of the items.
    - `values`: A list of values of the items.
    - `W`: The maximum weight capacity of the knapsack.
    - `n`: The number of items.
    - This function returns the maximum value that can be obtained by including or excluding the nth item.
    - Base cases include no items left or a knapsack capacity of 0. The function chooses the maximum value between including and not including the nth item.

  - **knapsack_dynamic Function**: A dynamic programming function to solve the Knapsack problem.
    - `weights`: A list of weights of the items.
    - `values`: A list of values of the items.
    - `W`: The maximum weight capacity of the knapsack.
    - This function returns the maximum value that can be obtained using a bottom-up approach to build a table `dp` where `dp[i][w]` represents the maximum value that can be obtained with the first `i` items and a knapsack capacity of `w`.
    - The function iterates over the items and capacities, filling the table based on whether the item is included or not.

  - **Example Usage**: The project includes an example with weights `[1, 2, 3, 4]`, values `[10, 20, 30, 40]`, and a knapsack capacity `W = 5`. It demonstrates the maximum value calculation using both recursive and dynamic programming approaches.
* Day 123: [TLC Trip Record Data](https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page)
  - **NYC Taxi Data Analysis**: Developed a data analysis project using PySpark and Pandas to process and visualize the NYC Yellow Taxi Trip data. This project involved extensive data cleaning, transformation, and visualization to uncover patterns and insights from the dataset.

    - **Data Cleaning and Transformation**: Utilized PySpark for efficient handling of large datasets. Performed data cleaning steps such as filtering out invalid data, handling missing values, and creating new columns for analysis.
      - **Trip Duration Calculation**: Calculated trip duration from pickup and dropoff timestamps and added it as a new column.
      - **Sampling**: Extracted a sample of the data to facilitate visualization and analysis in Pandas.

    - **Data Visualization**: Converted the cleaned data to a Pandas DataFrame for visualization using Seaborn and Matplotlib.
      - **Distribution of Trip Durations**: Plotted a histogram to show the distribution of trip durations.
      - **Trips per Hour**: Visualized the number of trips per hour to identify peak times for taxi rides.
      - **Trip Distance vs Fare Amount**: Created scatter plots to explore the relationship between trip distance and fare amount.
      - **Heatmaps of Pickup and Dropoff Locations**: Generated heatmaps to show the frequency of pickups and dropoffs by location ID.
      - **Passenger Count Distribution**: Displayed the distribution of the number of passengers per trip.
      - **Payment Type Distribution**: Visualized the distribution of different payment types used in the trips.
      - **Total Amount vs Tip Amount**: Plotted the relationship between the total fare amount and the tip amount.

  This project demonstrates the use of PySpark for big data processing and Pandas/Seaborn for detailed data visualization, providing insights into the NYC taxi operations and passenger behaviors.
* Day 124: 🏫 Object-Oriented Programming in Python with University Enrollment System 🏫

  * Today, I worked on a university enrollment system project to reinforce the principles of Object-Oriented Programming (OOP) in Python. This project incorporates key OOP concepts such as inheritance, encapsulation, and abstraction. Here's a summary of what I accomplished:

    - **Abstraction and Encapsulation**: Created an abstract base class `Person` to represent common attributes and behaviors for both students and teachers. Encapsulated the name and ID number attributes to protect them from direct modification. Implemented abstract methods to enforce a consistent interface for subclasses.
    - **Inheritance**: Developed two subclasses, `Student` and `Teacher`, inheriting from the `Person` class. These subclasses extend the base class by adding specific attributes and methods like enrolling in courses and assigning courses.
    - **Course Management**: Created a `Course` class to represent a university course, including attributes for course name, credits, teacher, and maximum number of students. Added methods to handle student enrollment, calculate total students, and determine the cost per student.
    - **User Interaction**: Implemented a menu-driven interface to allow users to enroll students in courses, display student details, and show course information. This interactive component showcases how OOP can be used to structure complex, real-world applications.
    - **Data Storage**: Used dictionaries to manage and store student instances, demonstrating the practical use of data structures in conjunction with OOP to handle multiple objects efficiently.

  This project provided a comprehensive exercise in applying OOP principles to a realistic scenario, reinforcing the importance of well-structured, maintainable, and scalable code.
* Day 125: Technical Test "trap" and "multiply" [LeetCode](https://leetcode.com/problems/).
  - **trap**: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. This problem involves using a two-pointer approach to traverse the elevation map and calculate the trapped water by comparing the heights of bars. It requires understanding how to efficiently track the maximum heights from both ends of the array to determine the water level at each position. [Problem Description](https://leetcode.com/problems/trapping-rain-water/description/)

  - **multiply**: Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string. The solution must not use any built-in BigInteger library or convert the inputs to integers directly. This problem requires implementing a manual multiplication algorithm similar to the one learned in school, handling digit-by-digit multiplication, and managing carry-over between digits. [Problem Description](https://leetcode.com/problems/multiply-strings/description/)
* Day 126: Basketball Ground Using Turtle
  * Created a visual representation of a basketball court using the Turtle graphics library in Python. This project involves drawing a complete basketball court with various elements like the court boundaries, center circle, and basket areas.

  - **Drawing the Court**: Utilized Turtle graphics to draw the court boundaries, including the outer lines and the rectangular playing area.
  - **Center Circle and Baskets**: Implemented functions to draw the center circle and the areas around the baskets, including the semi-circles and rectangles that represent the key areas on the court.
  - **Colors and Aesthetics**: Used different colors and fill patterns to differentiate various parts of the court, enhancing the visual appeal and clarity of the representation.

  This project showcases the capabilities of the Turtle graphics library for creating detailed and visually appealing graphics. It also emphasizes the importance of geometric calculations and the use of loops and functions to create complex shapes and patterns.

  The code for this project was adapted from an example on GeekforGeeks: [Create a Basketball Ground Using Turtle Library in Python](https://www.geeksforgeeks.org/create-a-basketball-ground-using-turtle-library-in-python/).
* Day 127: Employee Hours
  - **Employee Hours Management System**: Developed a web application using Flask and SQLite to manage and track employee working hours. This project includes functionalities for user authentication, logging working hours, editing logged hours, and visualizing the weekly work schedule.

    - **User Authentication**: Implemented login and registration features to ensure secure access to the application.
      - **Login**: Users can log in with their username and password. If credentials are invalid, an error message is displayed.
      - **Registration**: New users can register by providing a username and password. The registration page is linked from the login page.

    - **Logging Working Hours**: Provided functionality to log working hours with task details.
      - **Form Validation**: Ensured that logged hours are within weekdays (Monday to Friday) and between 06:00 and 23:00. If the user tries to log hours outside these constraints, an error message is displayed.

    - **Editing Logged Hours**: Allowed users to edit previously logged hours.
      - **Task and Start Time Modification**: Users can update the task description and the start time of logged hours, with the same validation constraints as logging new hours.

    - **Data Visualization**: Displayed the logged hours in a tabular format showing the weekly schedule.
      - **Weekly Schedule Table**: Organized logged hours by day and time, highlighting the tasks performed.
      - **Total Hours Calculation**: Summed up the total hours worked in a week and displayed it. If total hours exceed 42, the overtime hours are also shown.

    - **Database Management**: Used SQLite to store user credentials and logged hours.
      - **Database Initialization**: Created tables for users and logged hours if they do not exist.

    - **Additional Features**:
      - **Clear Hours**: Added a button to clear all logged hours for the next week, ensuring a fresh start.
      - **Responsive Design**: Implemented a professional CSS for a better user experience and user interface.

    This project demonstrates the use of Flask for web development, SQLite for database management, and JavaScript for client-side validation. It provides a comprehensive solution for managing and tracking employee working hours, ensuring data integrity and user-friendliness.
* Day 128: Recursion "Letter Combinations"

  * This project focuses on solving the "Letter Combinations of a Phone Number" problem using recursion. Given a string containing digits from 2-9 inclusive, the goal is to return all possible letter combinations that the number could represent. The mapping of digits to letters is based on the traditional telephone keypad.

  - **letter_combinations Function**: A recursive function to find all possible letter combinations for a given phone number.
    - `digits`: A string containing the digits from 2-9.
    - This function returns a list of all possible letter combinations.
    - The function uses a helper function `backtrack` to perform backtracking and explore all possible combinations.
    - The `phone_map` dictionary maps each digit to its corresponding letters.
    - The `backtrack` function iterates over all letters that map to the next available digit, appending the current letter to the combination and proceeding with the next digit until all digits are processed.
* Day 129: Pneumonia Detection Using Deep Learning

  - **Pneumonia Detection System**: Developed a deep learning model to detect pneumonia from chest X-ray images. This project includes data wrangling, model training, and evaluation using TensorFlow.

    - **Data Collection and Preparation**: 
      - **Dataset**: Utilized a dataset from Kaggle containing chest X-ray images categorized as "NORMAL" or "PNEUMONIA".
      - **Pathlib for File Handling**: Separated the dataset into training, validation, and test sets using Pathlib.
      - **Data Wrangling**: Generated labels for the images based on their directory names.

    - **Model Development**: 
      - **Data Preprocessing**: Implemented functions to load, transform, and create TensorFlow datasets from the image paths and labels.
      - **Model Architecture**: Used ResNet50V2 as the backbone for the CNN model, followed by GlobalAveragePooling2D and Dense layers with a sigmoid activation function.
      - **Regularization Techniques**: Added dropout and L2 regularization to improve model generalization and prevent overfitting.

    - **Model Training**: 
      - **Compilation**: Compiled the model with the Adam optimizer and binary cross-entropy loss, tracking accuracy, precision, and recall metrics.
      - **Callbacks**: Implemented ModelCheckpoint and EarlyStopping to save the best model and stop training early if no improvement was observed.
      - **Training Process**: Trained the model on the training dataset, validating it with the validation dataset over multiple epochs.

    - **Evaluation and Interpretation**: 
      - **Model Evaluation**: Evaluated the model on the test dataset to calculate accuracy, precision, and recall.
      - **Visualizations**: Plotted the training and validation metrics over epochs to interpret the model's performance.

    - **Complete Model and Deployment**: 
      - **Saving the Model**: Saved the best model weights and the complete trained model for future use.
      - **Loading and Testing**: Loaded the saved model and tested it on new images to ensure it works as expected.

    This project demonstrates the use of deep learning for medical image classification, involving data preprocessing, model building, training, and evaluation with TensorFlow. It provides a comprehensive solution for detecting pneumonia from chest X-rays, showcasing the potential of AI in healthcare.
* Day 130: Technical Test "WildcardisMatch" and "jump" [LeetCode](https://leetcode.com/problems/)
  - **WildcardisMatch**: Given an input string `s` and a pattern `p`, implement wildcard pattern matching with support for `?` and `*`. The `?` matches any single character, while the `*` matches any sequence of characters (including the empty sequence). The solution should cover the entire input string, not just a partial match. This problem involves using dynamic programming to efficiently manage the different matching scenarios and ensure the pattern matches the entire string. [Problem Description](https://leetcode.com/problems/wildcard-matching/description/)
  - **jump**: Given a 0-indexed array of integers `nums` of length `n`, where each element `nums[i]` represents the maximum length of a forward jump from index `i`, return the minimum number of jumps to reach `nums[n - 1]`. The solution should use a greedy algorithm to track the farthest point that can be reached and count the jumps needed to reach the last index. The test cases guarantee that you can reach the last index. [Problem Description](https://leetcode.com/problems/jump-game-ii/description/)
* Day 131: 🐕 Dogs vs Cats 🐈 [Kaggle](https://www.kaggle.com/datasets/salader/dogs-vs-cats)

  * Today, I worked with the Dogs vs Cats dataset from Kaggle, focusing on developing a Convolutional Neural Network (CNN) to classify images of dogs and cats. Here's a summary of what I accomplished:
    - **Data Preparation**: Downloaded and extracted the dataset, and created training and validation datasets using TensorFlow’s `image_dataset_from_directory` function. The images were normalized for better model performance.
    - **Model Architecture**: Built a CNN using Keras, consisting of multiple Conv2D layers with Batch Normalization and MaxPooling. The model included three Conv2D layers with increasing filter sizes (32, 64, 128) to extract features from the images.
    - **Fully Connected Layers**: Added fully connected Dense layers to the model, with Dropout for regularization, to perform the final classification.
    - **Model Compilation**: Compiled the model with Adam optimizer and binary cross-entropy loss function, suitable for binary classification tasks.
    - **Training**: Trained the model on the prepared dataset for 9 epochs, validating its performance on the validation dataset. Visualized the training and validation accuracy and loss over epochs using Matplotlib.
    - **Testing**: Tested the model with sample images of dogs and cats to verify its predictions.

  This project highlights the importance of proper data preprocessing, designing a robust neural network architecture, and evaluating the model's performance to achieve accurate image classification. The insights and models developed can be further refined and used for various image classification tasks.
* Day 132: 🎬 Object-Oriented Programming in Python with Movie Subscription System 🎬

  * Today, I worked on a movie subscription system project to reinforce the principles of Object-Oriented Programming (OOP) in Python. This project incorporates key OOP concepts such as inheritance, encapsulation, and abstraction. Here's a summary of what I accomplished:

    - **Abstraction and Encapsulation**: Created an abstract base class `Person` to represent common attributes and behaviors for both viewers and directors. Encapsulated the name and ID number attributes to protect them from direct modification. Implemented abstract methods to enforce a consistent interface for subclasses.
    - **Inheritance**: Developed two subclasses, `Viewer` and `Director`, inheriting from the `Person` class. These subclasses extend the base class by adding specific attributes and methods like subscribing to genres and adding movies to the director's filmography.
    - **Movie Management**: Created a `Movie` class to represent a movie, including attributes for the movie title, genre, director, rating, and duration. Added methods to handle movie details and categorize movies by genre.
    - **User Interaction**: Implemented a menu-driven interface to allow users to subscribe viewers to genres, display viewer details, and show movie information. This interactive component showcases how OOP can be used to structure complex, real-world applications.
    - **Data Storage**: Used dictionaries to manage and store viewer instances, demonstrating the practical use of data structures in conjunction with OOP to handle multiple objects efficiently.

  This project provided a comprehensive exercise in applying OOP principles to a realistic scenario, reinforcing the importance of well-structured, maintainable, and scalable code.
* Day 133: 🤖 Implementing a Simple Neural Network in Python with Backpropagation 🤖

  * Today, I worked on a project to build a simple neural network from scratch in Python, focusing on the fundamental concepts of neural networks and backpropagation. Here's a summary of what I accomplished:

    - **Activation Function**: Implemented the sigmoid function and its derivative, which are essential for the forward and backward passes in the neural network.
    - **Loss Function**: Used the mean squared error (MSE) as the loss function to measure the performance of the neural network.
    - **Network Initialization**: Created a `NeuralNetwork` class with two hidden layers. Randomly initialized the weights for connections between the input layer, hidden layers, and output layer.
    - **Forward Propagation**: Developed a method to pass input data through the network, compute the activations of the hidden layers and the final output.
    - **Backward Propagation**: Implemented the backpropagation algorithm to update the weights based on the error between predicted and actual outputs. This involved calculating deltas for each layer and adjusting the weights using the learning rate.
    - **Training the Network**: Trained the neural network using a small dataset, splitting it into training and validation sets. Monitored the training and validation loss to ensure the network was learning correctly.
    - **Prediction**: Added a function to test the trained network with new input data, demonstrating its ability to make predictions.

  This project provided a hands-on exercise in understanding and implementing the core components of a neural network, from initialization to training and prediction. It reinforced key concepts in machine learning, such as forward and backward propagation, weight updates, and performance evaluation.
* Day 134: ♟️ Building a Chess Game in Python with Object-Oriented Programming ♟️

  * Today, I worked on a project to create a chess game in Python, focusing on the principles of Object-Oriented Programming (OOP). This project involved designing classes for different chess pieces and implementing their movements on the board. Here's a summary of what I accomplished:

    - **ChessPiece Base Class**: Developed an abstract `ChessPiece` class to represent a generic chess piece. This class includes a `color` attribute and an abstract method `get_legal_moves` which must be implemented by subclasses.
    
    - **King Class**: Created a `King` class that inherits from `ChessPiece` and implements the `get_legal_moves` method to return all possible legal moves for the king, considering its unique movement rules.

    - **Queen Class**: Developed a `Queen` class that combines straight and diagonal moves, mimicking the behavior of both a rook and a bishop. This class uses helper methods `get_straight_moves` and `get_diagonal_moves` to calculate all legal moves.

    - **Rook Class**: Created a `Rook` class that inherits from `ChessPiece` and reuses the `get_straight_moves` method from the `Queen` class to determine its legal moves.

    - **Bishop Class**: Implemented a `Bishop` class that inherits from `ChessPiece` and reuses the `get_diagonal_moves` method from the `Queen` class to calculate its legal moves.

    - **Knight Class**: Designed a `Knight` class with a unique movement pattern, implementing its own `get_legal_moves` method to return all possible L-shaped moves.

    - **Pawn Class**: Developed a `Pawn` class that includes specific movement rules such as moving forward one or two squares from the starting position and capturing diagonally.

    - **ChessBoard Class**: Created a `ChessBoard` class to initialize the board with all pieces in their starting positions. This class includes methods to display the board, move pieces, check for valid moves, and evaluate the position.

    - **Move Validation**: Implemented logic in the `move_piece` method to ensure moves are legal according to each piece's movement rules. This method also switches the current turn between white and black players.

    - **Evaluation and Legal Moves Generation**: Added methods to evaluate the board's position and generate all legal moves for a given color, providing a foundation for future enhancements like check and checkmate detection.

  This project provided a comprehensive exercise in applying OOP principles to a classic game, reinforcing the importance of creating maintainable and scalable code. It also offered a practical way to implement and test various chess piece movements and game mechanics.
* Day 135: ☕ Analyzing Worldwide Coffee Consumption Trends with Python ☕

  Today, I focused on a data analysis project that examines coffee consumption patterns across various countries using a dataset that spans from 2000 to 2023. This project provided valuable insights into how coffee is enjoyed around the world. Here's a summary of what I accomplished:

  - **Loading the Data**: Imported the dataset containing information on coffee consumption, prices, types of coffee consumed, and population for different countries.

  - **Data Exploration**: Explored the dataset to understand its structure, including the number of records, data types, and basic statistics.
    - **Fields and Data Types**:
      - `Country`: The name of the country where the data was collected.
      - `Year`: The year of the record, spanning from 2000 to 2023.
      - `Coffee Consumption (kg per capita per year)`: The amount of coffee consumed per person annually.
      - `Average Coffee Price (USD per kg)`: The average price of coffee per kilogram in US dollars.
      - `Type of Coffee Consumed`: The most popular types of coffee enjoyed in each country.
      - `Population (millions)`: The estimated population of each country.

  - **Data Cleaning**: Renamed columns to remove spaces and make them more code-friendly.

  - **Handling Missing Data**: Checked for and handled any missing data to ensure the dataset was complete and accurate for analysis.

  - **Exploratory Data Analysis (EDA)**: Conducted various analyses to gain insights into the data:
    - **Distributions**: Plotted histograms for numerical features to understand their distributions.
    - **Trends Over Time**: Analyzed the number of records per year for different types of coffee.
    - **Correlation Analysis**: Created a heatmap to visualize the correlations between numerical features.
    - **Pie Charts**: Visualized the distribution of different types of coffee consumed.
    - **Stacked Bar Chart**: Showed the trends of coffee types consumed over the years.
    - **Box Plot**: Compared coffee prices across different countries.
    - **Top Countries Analysis**: Identified and analyzed the top 10 countries by average coffee consumption.
    - **Heatmap**: Displayed the distribution of different types of coffee consumed across countries.

  This project provided a comprehensive exercise in data analysis, helping to reinforce key concepts in data cleaning, exploration, visualization, and interpretation.
* Day 136: Technical Test "permute" and "permuteUnique" [LeetCode](https://leetcode.com/problems/)
  - **permute**: Given an array `nums` of distinct integers, return all possible permutations. The solution involves using backtracking to generate permutations by swapping elements and recursively building each permutation until the entire array is permuted. [Problem Description: Permutations](https://leetcode.com/problems/permutations/description/)
  - **permuteUnique**: Given a collection of numbers that might contain duplicates, return all possible unique permutations. The solution sorts the input array and uses backtracking with a set to skip over duplicate elements during the permutation process. [Problem Description: Permutations II](https://leetcode.com/problems/permutations-ii/description/)
* Day 137: Test Projects "NotesManager"
  * Today, we're focusing on writing unit tests for a simple Note Manager application. Testing is a crucial part of software development, ensuring that our code works as expected and helps prevent bugs from creeping into our projects. We'll use Python's unittest module to create and run our tests. This exercise will help you understand the basics of writing tests and how to use them to verify the correctness of your code.
* Day 138: 🐾 Developing a Pet Store Management System in Python with Unit Testing 🐾

  * Today, I worked on a project to create a Pet Store Management System in Python, emphasizing the principles of Object-Oriented Programming (OOP) and unit testing. This project involved designing classes for customers, staff, and pets, and implementing a menu-driven interface for interactions. Here's a summary of what I accomplished:

    - **Person Base Class**: Developed an abstract `Person` class to represent a generic person in the system, including attributes for name and ID number. This class also includes an abstract method `get_description` which must be implemented by subclasses.

    - **Customer Class**: Created a `Customer` class that inherits from `Person` and includes methods to adopt pets and retrieve a list of adopted pets. The class also implements the `get_description` method to return customer details.

    - **Staff Class**: Developed a `Staff` class that inherits from `Person` and includes methods to assign pets to staff and retrieve a list of assigned pets. This class also implements the `get_description` method to return staff details.

    - **Pet Class**: Designed a `Pet` class with attributes for name, breed, age, and price. This class includes a method `get_description` to return pet details.

    - **Menu Interface**: Implemented a menu-driven interface that allows users to adopt a pet, display customer details, and display pet details. The interface interacts with the `Customer`, `Staff`, and `Pet` classes to manage the store's operations.

    - **Unit Testing**: Wrote comprehensive unit tests using Python's `unittest` module to verify the functionality of the application. The tests cover:
      - Adding pets to customers and ensuring they are correctly added to the list.
      - Assigning pets to staff and verifying the assignment.
      - Retrieving and verifying descriptions of customers, staff, and pets.

  This project provided an in-depth exercise in applying OOP principles and writing effective unit tests to maintain code quality. It reinforced the importance of encapsulation, inheritance, and abstraction in creating maintainable and scalable code.
* Day 139: Top 20 Play Store App Reviews [Kaggle](https://www.kaggle.com/datasets/odins0n/top-20-play-store-app-reviews-daily-update/data)

  * Today, I worked with the Top 20 Play Store App Reviews dataset from Kaggle, focusing on analyzing review sentiments using the DistilBERT model. Here's a summary of what I accomplished:
    - **Data Loading**: Loaded the dataset using Pandas to get a comprehensive view of the reviews and their scores.
    - **Review Analysis**: 
      - Visualized the distribution of review scores to understand the general sentiment of the reviews.
      - Sampled 200 reviews from the dataset for detailed analysis.
    - **Sentiment Analysis with DistilBERT**:
      - Utilized the DistilBERT model for sentiment analysis. The model was fine-tuned on the SST-2 dataset for sentiment classification.
      - Created a sentiment analysis pipeline using the model and tokenizer.
      - Performed sentiment analysis on the reviews and added the results to the dataset.
    - **Visualization**:
      - Plotted the distribution of sentiments (Positive vs. Negative) to get an overview of the sentiment spread.
    - **Model Evaluation**:
      - Evaluated the model's performance using a confusion matrix and classification report.
      - Compared the sentiment analysis results with the actual review scores to assess the model's accuracy.
    - **Key Insights**:
      - The model achieved an overall accuracy of 85% in predicting sentiments.
      - Highlighted the balance between precision and recall, showing effective performance in classifying both positive and negative reviews.

  This project demonstrates the practical application of pre-trained transformer models in sentiment analysis, emphasizing the importance of data preprocessing, model evaluation, and visualization in deriving meaningful insights from textual data.
* Day 140: 🎮 Memory Game 🎮
  * Today, I created a memory game using Pygame, focusing on building a fun and interactive application that challenges players to find matching pairs of colored cards. Here's a summary of what I accomplished:
    - **Game Setup**: Initialized Pygame and set up the display with a grid of cards.
    - **Card Generation**: 
      - Defined a set of colors and created pairs for the memory game.
      - Shuffled the colors and assigned them to the cards in a grid layout.
    - **Game Logic**: 
      - Implemented the logic for flipping cards and checking for matches.
      - Handled user input to select and flip cards, and checked for matched pairs.
      - Included a mechanism to hide unmatched cards after a short delay.
    - **Graphics and Display**:
      - Drew the cards on the screen, showing either the card back or the front color based on their state.
      - Added text to display a winning message when all pairs are found.
    - **Game Loop**: 
      - Managed the main game loop to handle events, update the game state, and redraw the screen.
      - Ensured the game runs smoothly and responds to user actions.

  This project highlights the use of Pygame for game development, emphasizing the importance of game logic, user interaction, and visual display to create an engaging user experience. The memory game is a great way to practice Pygame and develop skills in interactive application design.
* Day 141: 🧮 EMI Calculator with Tkinter and Matplotlib 📊
  * Today, I developed an EMI (Equated Monthly Installment) Calculator using Tkinter for the GUI and Matplotlib for visualizing the EMI breakdown. This project involved creating a user-friendly interface and implementing the logic for EMI calculation and graphical representation. Here's a summary of what I accomplished:

    - **GUI Setup**:
      - Created the main window using Tkinter and set the title and background color.
      - Registered validation commands to ensure the user inputs are valid.

    - **Input Fields**:
      - Added input fields for total loan amount, loan period (years and months), and interest rate.
      - Used Tkinter's Entry widget for text inputs and Spinbox for selecting years and months.

    - **Calculation Logic**:
      - Implemented the EMI calculation formula to compute the monthly payment.
      - Calculated the total payment, interest amount, and the breakdown of payments over time.

    - **Result Display**:
      - Formatted and displayed the calculation results in a message box.
      - Showed the monthly payment, total EMI period, total amount, interest amount, and total payment.

    - **Graphical Visualization**:
      - Utilized Matplotlib to plot the EMI breakdown over time.
      - Displayed the balance, interest, and principal components month-wise in a line graph.
      - Added titles, labels, legends, and grid to the plot for better readability.

    - **Clear Functionality**:
      - Implemented a clear function to reset all input fields and prepare the form for new input.

    This project demonstrates the integration of Tkinter for building interactive GUI applications and Matplotlib for data visualization. The EMI Calculator is a practical tool for understanding loan repayment schedules and visualizing the impact of different loan parameters.
* Day 142: Technical Test "rotate" and "groupAnagrams" [LeetCode](https://leetcode.com/problems/)
  - **rotate**: This function rotates an `n x n` 2D matrix by 90 degrees clockwise. The solution involves first transposing the matrix (swapping rows and columns) and then reversing each row. [Problem Description: Rotate Image](https://leetcode.com/problems/rotate-image/description/)
  - **groupAnagrams**: This function groups anagrams together from a list of strings. The solution uses a dictionary where the key is the sorted version of the word and the value is the list of words that, when sorted, match the key. [Problem Description: Group Anagrams](https://leetcode.com/problems/group-anagrams/description/)
* Day 143: 🎵 Object-Oriented Programming in Python with Music Subscription System 🎵
  * Today, I worked on a music subscription system project to reinforce the principles of Object-Oriented Programming (OOP) in Python. This project incorporates key OOP concepts such as inheritance, encapsulation, and abstraction. Here's a summary of what I accomplished:
    - **Abstraction and Encapsulation**: Created an abstract base class `Person` to represent common attributes and behaviors for both listeners and artists. Encapsulated the name and ID number attributes to protect them from direct modification. Implemented abstract methods to enforce a consistent interface for subclasses.
    - **Inheritance**: Developed two subclasses, `Listener` and `Artist`, inheriting from the `Person` class. These subclasses extend the base class by adding specific attributes and methods like subscribing to genres and adding songs to the artist's discography.
    - **Song Management**: Created a `Song` class to represent a song, including attributes for the song title, genre, artist, rating, and duration. Added methods to handle song details and categorize songs by genre.
    - **User Interaction**: Implemented a menu-driven interface to allow users to register listeners and artists, subscribe listeners to genres, register songs, display listener details, display song information, and show artist details. This interactive component showcases how OOP can be used to structure complex, real-world applications.
    - **Data Storage**: Used dictionaries to manage and store listener, artist, and song instances, demonstrating the practical use of data structures in conjunction with OOP to handle multiple objects efficiently.

  This project provided a comprehensive exercise in applying OOP principles to a realistic scenario, reinforcing the importance of well-structured, maintainable, and scalable code.
* Day 144: 🌀 Mandelbrot Set Visualization 🌀
  * Today, I delved into the fascinating world of fractals by visualizing the Mandelbrot set using Python. This project involved implementing the mathematical principles behind the Mandelbrot set and generating a beautiful visual representation. Here's a summary of what I accomplished:

    - **Mathematical Foundations**: Implemented the Mandelbrot sequence using a function that iterates a complex number to determine if it belongs to the Mandelbrot set. The function returns the iteration count, which is used to determine the color of each point in the visualization.
    - **Grid Creation**: Generated a grid of complex numbers representing the real and imaginary parts of the Mandelbrot set. Used `numpy` to create linear spaces for the real and imaginary components, and iterated over this grid to compute the Mandelbrot values.
    - **Visualization**: Utilized `matplotlib` to plot the computed Mandelbrot set. Applied a color map to visually represent the iteration count, creating a vivid and intricate fractal image. Added labels and a color bar for better readability.
    - **Code Organization**: Structured the code into functions to improve readability and maintainability. This modular approach ensures that each part of the computation and visualization process is clearly defined and easy to understand.
    - **Inspiration**: Based this project on a tutorial by NeuralNine. You can watch the video here: [NeuralNine YouTube Tutorial](https://www.youtube.com/watch?v=xjjmkg9J7Gg).

  This project provided a deep dive into both mathematical computation and data visualization, reinforcing the importance of combining theoretical concepts with practical implementation.
* Day 145: 🌳 Recursive Tree Animation 🌳
  * Today, I explored the world of recursive graphics by creating an animated visualization of a fractal tree using Python. This project combined recursion with animation to produce a dynamic and captivating visual representation. Here's a summary of what I accomplished:

    - **Recursive Tree Drawing**: Implemented a recursive function to draw a tree. The function calculates the end points of each branch using trigonometric functions and recursively draws smaller branches at specified angles. This method creates the characteristic fractal structure of a tree.
    - **Animation Setup**: Used `matplotlib` and `numpy` to set up the initial figure and axis for the animation. Defined the limits and aspect ratio to ensure the tree is displayed correctly.
    - **Frame Updates**: Created an animation function that updates the tree's depth with each frame, gradually increasing the depth of recursion to animate the growth of the tree. This function clears the previous frame, sets the axis limits, and draws the tree with the current depth.
    - **Creating the Animation**: Utilized `matplotlib.animation.FuncAnimation` to create the animation. Defined the initial and maximum depth, and set the interval between frames to control the animation speed.
    - **Displaying the Animation**: Configured `matplotlib` to display the animation, showcasing the growth of the fractal tree in real-time.

  This project provided an exciting opportunity to delve into recursive algorithms and animation techniques, demonstrating the power of combining mathematical concepts with visual art.
* Day 146: 🏦 ATM Machine Simulation 🏦
  * Today, I ventured into the realm of GUI programming by creating an ATM machine simulation using Python and Tkinter. This project involved developing a user-friendly interface that mimics the functionalities of a real ATM, providing an interactive experience for users. Here's a summary of what I accomplished:

    - **GUI Design**: Designed the main application window with Tkinter, setting up the initial balance and PIN. Configured the window to be non-resizable and applied a consistent color scheme for a professional look.
    - **PIN Validation**: Implemented a PIN entry system to authenticate users. The application verifies the entered PIN and provides appropriate feedback using message boxes.
    - **ATM Menu**: Created a menu with options to check balance, deposit money, withdraw money, and exit. Each menu option is linked to its corresponding function, ensuring smooth navigation.
    - **Balance Check**: Developed a function to display the current balance in a message box.
    - **Deposit Money**: Added functionality to allow users to deposit money into their account. Implemented input validation to ensure the deposited amount is a positive number.
    - **Withdraw Money**: Enabled users to withdraw money, with validation to check for sufficient balance and ensure the withdrawn amount is positive.
    - **Code Organization**: Structured the code into functions and classes to enhance readability and maintainability. This modular approach ensures that each part of the application is clearly defined and easy to understand.

  This project provided valuable insights into GUI development and user interaction, demonstrating the importance of creating intuitive and functional interfaces.
* Day 147: Technical Test "myPow" and "NQueens" [LeetCode](https://leetcode.com/problems/)
  - **myPow**: Implemented a function that calculates \( x^n \) (x raised to the power n) efficiently. This problem involves optimizing the power calculation by leveraging recursion and handling edge cases such as negative powers. [Problem Description: myPow](https://leetcode.com/problems/powx-n/description/)
  - **NQueens**: Solved the N-Queens problem, which involves placing n queens on an n x n chessboard so that no two queens attack each other. The solution uses backtracking to explore all possible placements and returns all distinct configurations. [Problem Description: NQueens](https://leetcode.com/problems/n-queens/description/)
* Day 148: 🎮 Video Game Subscription System in Python 🎮

  * Today, I expanded my understanding of Object-Oriented Programming (OOP) by developing a Video Game Subscription System using Python. This project leverages fundamental OOP principles such as inheritance, encapsulation, and abstraction. Here’s a summary of the key elements:

    - **Abstraction and Encapsulation**: Defined an abstract base class `Person` representing common features for both `Player` and `Developer`. Encapsulated attributes like name and ID number to ensure data integrity. The abstract method `get_description` enforces a consistent interface for subclasses.
    - **Inheritance**: Created two subclasses, `Player` and `Developer`, that inherit from `Person`. These subclasses add specific attributes and methods, such as subscribing to game genres for `Player` and adding games to a portfolio for `Developer`.
    - **Game Management**: Introduced a `Game` class to represent individual games, including details such as title, genre, developer, rating, and release year. Methods within this class manage game-related information and allow interaction with player and developer objects.
    - **User Interaction**: Built a menu-driven interface allowing users to register players and developers, add new games, subscribe players to game genres, and display details for players, games, and developers. This interactive component illustrates the practical application of OOP in creating user-friendly software systems.
    - **Data Organization**: Employed dictionaries to efficiently manage and store instances of players, developers, and games. This approach highlights the integration of OOP and data structures to handle complex, real-world data scenarios.

  This project provided an engaging and insightful exercise in implementing OOP principles to simulate a real-world application, reinforcing the importance of design patterns and code maintainability.
* Day 149: 🧩 Wordle Game with Flask and CSS 🖥️

  * Today, I worked on developing a Wordle-inspired game using Flask for the backend and custom CSS for styling. This project integrates web development skills with game logic to create an interactive user experience. Here’s a summary of the key components:

    - **Flask Application**: Implemented a Flask application to handle game logic, including word selection, guess validation, and feedback management. Used session variables to track game state, including the target word, attempts, and game status.
    - **Word Management**: Loaded a list of possible words from a text file and used it to randomly select a word for each game session. Validated player guesses against this word and provided feedback on correctness, presence, or absence of letters.
    - **User Interface**: Designed a user-friendly interface using HTML and CSS, featuring forms for guess input, feedback display, and game status updates. The interface also includes a responsive design to ensure compatibility across different devices.
    - **Feedback System**: Incorporated a feedback mechanism to visually represent the correctness of each guessed letter, including color-coded indicators for correct, present, and absent letters.
    - **Game Flow Control**: Managed game flow with options to restart the game or handle game-over scenarios, providing an engaging experience with clear instructions and error handling.

  This project allowed me to apply web development and design skills in a practical context, creating an enjoyable and visually appealing game experience.

* Day 150: 🧠 Brain Tumor Dataset 🧠 Analysis [Kaggle](https://www.kaggle.com/datasets/odins0n/brain-tumor-dataset)

  * Today, I worked with the Brain Tumor dataset from Kaggle, focusing on exploring various aspects of the data and performing detailed analyses. Here's a summary of what I accomplished:
    - **Data Loading**: Loaded the dataset using Pandas, and explored the initial structure of the data.
    - **Data Cleaning**:
      - Renamed columns for consistency and easier access.
      - Checked for and handled missing data, ensuring the dataset was ready for analysis.
    - **Exploratory Data Analysis (EDA)**:
      - **Categorical Features**: 
        - Created count plots for features like Tumor Type, Location, and Gender to visualize their distributions.
        - Analyzed the correlation between Tumor Location and Grade using a heatmap.
      - **Numerical Features**:
        - Generated correlation heatmaps to understand relationships between numeric features like Age and Tumor Size.
        - Visualized the distribution of Tumor Grade by Age and Gender, and Tumor Size by Type and Grade.
      - **Outlier Detection**:
        - Used boxplots to detect outliers in Age and Tumor Size, identifying specific data points for further investigation.
    - **Principal Component Analysis (PCA)**:
      - Applied PCA to reduce dimensionality, focusing on numeric features like Age and Size.
      - Visualized the resulting principal components to explore potential clustering by Tumor Type.
    - **Feature Engineering**:
      - Grouped Age into categories to simplify analysis.
      - Created a binary feature indicating whether a tumor was in a critical location.
    - **Automated Report**:
      - Developed functions to generate a statistical summary, distribution graphs, and correlation analysis for both numerical and categorical variables.
      - Automated the generation of visual and textual insights from the dataset.

  * This work provided valuable insights into the distribution and relationships within the dataset, which could be crucial for understanding and predicting outcomes related to brain tumors. The automated report functions developed can also be reused for similar datasets in future projects.
* Day 151: 🏗️ Tower of Babel - Recursive Algorithm 🏗️

  * Today, I implemented and explored the Tower of Babel problem, a variation of the classic Tower of Hanoi, using a recursive algorithm. This project focused on moving blocks from one position to another following specific rules. Here's a summary of what I accomplished:
    - **Recursive Function Design**:
      - Developed a recursive function `build_tower` that moves blocks between positions to simulate the construction of a tower.
      - The base case handles the movement of a single block, while the recursive case manages the movement of multiple blocks.
    - **Block Movement Logic**:
      - Implemented the `move_block` function to transfer blocks between positions, ensuring that each move is printed to the console for clarity.
    - **Initial and Final Tower States**:
      - Initialized the tower with a specific number of blocks in one position.
      - The recursive process successfully moved all blocks to the target position, maintaining the rules of the problem.
    - **Visualization and Debugging**:
      - Provided clear output of the tower's state before and after the recursive process, aiding in debugging and understanding the algorithm's flow.
      - Used print statements to trace each block movement, making it easier to follow the recursive calls.

  * This exercise was a great opportunity to reinforce my understanding of recursion, particularly in solving problems that involve multiple recursive calls and complex state management. The Tower of Babel problem also highlights the importance of clear base cases and recursive steps in algorithm design.
* Day 152: Technical Test "totalNQueens" and "maxSubArray" [LeetCode](https://leetcode.com/problems/)
  - **totalNQueens**: Implemented a solution to the N-Queens II problem, which involves counting the number of distinct solutions for placing n queens on an n x n chessboard so that no two queens attack each other. The solution uses backtracking to explore all valid placements and utilizes arrays to track columns and diagonals that are under attack. The efficient marking and unmarking of attacked positions allow the algorithm to explore all configurations systematically. [Problem Description: totalNQueens](https://leetcode.com/problems/n-queens-ii/description/)

  - **maxSubArray**: Solved the Maximum Subarray problem, where the goal is to find the contiguous subarray within a one-dimensional numeric array that has the largest sum. The solution employs a dynamic programming approach, where the maximum sum is updated as the algorithm iterates through the array, considering each element either as a standalone subarray or as an extension of the previous subarray. This approach ensures an optimal solution with a time complexity of O(n). [Problem Description: maxSubArray](https://leetcode.com/problems/maximum-subarray/description/)
* Day 153: 🎮 Rock Paper Scissor Game with Tkinter 🎮

  * Today, I developed a Rock Paper Scissor game using Python's Tkinter library. The game allows the player to select between Rock, Paper, or Scissors, while the computer randomly selects its move. Here’s a summary of the key components of this project:
    - **Graphical User Interface (GUI) Design**:
      - Created an intuitive and user-friendly interface with buttons for the player's choices, as well as labels for displaying the results.
      - Utilized Tkinter widgets such as `Label`, `Button`, and `Frame` to organize the layout and display game elements.
    - **Game Logic Implementation**:
      - Implemented the game logic for Rock, Paper, Scissors, where the player’s choice is compared with the computer’s random selection.
      - Handled different outcomes such as "Player Wins", "Computer Wins", or "Match Draw" based on the rules of the game.
    - **Reset and State Management**:
      - Added a reset button to allow players to restart the game without closing the application.
      - Disabled buttons after each round to prevent multiple choices in a single game, ensuring a fair gameplay experience.
    - **Random Computer Selection**:
      - Used Python's `random` library to simulate the computer's choice, making the game unpredictable and engaging.

  * This project was a great way to practice my skills in building GUI applications with Tkinter, as well as implementing simple game mechanics in Python. It reinforced concepts such as event handling, state management, and the importance of a well-structured user interface.
* Day 154: 🏥 Medical Appointment System in Python 🩺

  * Today, I developed a Medical Appointment System using Python, implementing Object-Oriented Programming (OOP) principles such as inheritance, encapsulation, and abstraction. This project focuses on managing patients, doctors, and appointments in an organized and scalable manner. Here's a summary of the key features:

    - **Abstraction and Encapsulation**: Defined an abstract base class `Person` to represent common attributes for both `Patient` and `Doctor`, ensuring a consistent interface through the abstract method `get_description`. Encapsulated sensitive data like name and ID number to protect the integrity of the information.
    - **Inheritance**: Created two subclasses, `Patient` and `Doctor`, that extend the functionality of the `Person` class. The `Patient` class manages patient-specific data like age and appointments, while the `Doctor` class tracks the doctor's specialty and assigned patients.
    - **Appointment Scheduling**: Introduced an `Appointment` class to manage the scheduling of appointments between patients and doctors, storing details like date, time, and reason for the visit. This class ties together both patient and doctor information, ensuring smooth coordination.
    - **Menu-Driven Interaction**: Built a user-friendly interface that allows the registration of new patients and doctors, scheduling of appointments, and viewing detailed information about patients and doctors. This menu system showcases the integration of OOP with real-world applications.
    - **Data Management**: Used dictionaries to organize and store instances of patients and doctors efficiently. This approach facilitates quick access and updates to patient and doctor records, demonstrating the importance of effective data structures in software systems.

  This project was a great opportunity to practice implementing OOP concepts in a practical scenario, creating a robust system for managing medical appointments. It deepened my understanding of how OOP principles can streamline the organization of complex data and processes.
* Day 155: 🎬 Movie Ratings Analysis with PySpark and Seaborn 🎥 [Dataset](https://grouplens.org/datasets/rating-disposition-2023/)

  * Today, I worked on a data analysis project focused on movie ratings using PySpark for distributed data processing and Seaborn for visualizations. The project involved cleaning, processing, and analyzing a dataset of movie ratings to uncover trends and insights. Here's a breakdown of the key features:

    - **Data Processing with PySpark**: Utilized PySpark to handle a large dataset of movie ratings, allowing efficient computation on big data. I loaded the data into a DataFrame, filtered, and aggregated it using PySpark’s powerful functions like `groupBy`, `agg`, and `filter` to analyze ratings per movie and user.
    - **Average Rating Calculation**: Calculated the average rating for each movie and determined the number of ratings each movie received. This information was crucial for identifying popular movies and trends in user preferences.
    - **User Activity Analysis**: Analyzed user behavior by calculating the average rating given by each user and identifying the most active users, showcasing how PySpark can be used to extract valuable insights from large datasets.
    - **Visualization with Seaborn**: Converted the PySpark DataFrame to a pandas DataFrame and used Seaborn to create a bar chart representing the distribution of ratings across movies. This visual representation helped highlight the most common rating values and their occurrences.
    - **Interactive Data Exploration**: Implemented a menu-driven interface allowing exploration of the data, including displaying top-rated movies, most active users, and the distribution of ratings. This approach ties together both data processing and visualization in a cohesive project.

  This project was a great opportunity to dive deeper into big data processing with PySpark, as well as exploring data visualization techniques with Seaborn. It enhanced my ability to work with large datasets and transform them into meaningful insights, while reinforcing the importance of visualizations in data analysis.
* Day 156: 🗒️ To-Do List Application with Flet 📝

  * Today, I created a To-Do List application using Flet, a modern framework for building interactive web applications in Python. This project was a fantastic exercise in using Flet to manage user input, display dynamic content, and handle interactive events. Here's a summary of the key features:

    - **User Interface Design**: Designed a clean and user-friendly interface with a centered layout. The application features a title, input field, and button for adding tasks, along with a dynamically updated list of tasks.
    - **Task Management**: Implemented functionality to add new tasks to the list and display them with checkboxes. Tasks are displayed in a list view, allowing users to see and manage their to-dos easily.
    - **Interactive Elements**: Incorporated interactive elements such as a `TextField` for task input and a `FilledButton` to add tasks. Added checkboxes next to each task to allow users to mark tasks as completed.
    - **Dynamic Updates**: Created functions to update the task list and display selected tasks based on user interactions. The list updates in real-time to reflect new tasks and changes in task selection.
    - **Data Handling**: Used a list to manage and store tasks, and updated the displayed list dynamically. The application tracks which tasks are selected and updates the display accordingly.

  This project was an excellent opportunity to explore Flet's capabilities in building interactive web applications and to apply concepts of UI design and event handling in a practical context.
* Day 157: Technical Test "spiralOrder" and "canJump" [LeetCode](https://leetcode.com/problems/)

  - **spiralOrder**: Solved the Spiral Matrix problem, where the task is to traverse a 2D matrix in spiral order and return the elements in the order they are visited. The algorithm follows a structured approach by traversing the matrix in four directions (right, down, left, up) while adjusting the boundaries (top, bottom, left, right) as the spiral tightens. This method ensures that each element is visited exactly once. The solution has a time complexity of O(m * n), where m and n are the dimensions of the matrix. [Problem Description: Spiral Order](https://leetcode.com/problems/spiral-matrix/description/)

  - **canJump**: Implemented a solution for the Jump Game problem, which asks whether it is possible to reach the last index of an array given that each element represents the maximum jump length from that position. The algorithm utilizes a greedy approach to track the farthest reachable index as it iterates through the array. If at any point the current index is beyond the farthest reachable index, the function returns `False`. Otherwise, it returns `True` if the last index is reachable. This solution operates in linear time with a time complexity of O(n). [Problem Description: Can Jump](https://leetcode.com/problems/jump-game/description/)
* Day 158: 🖌️ Floodfill Image Color Changer with Tkinter 🖌️

  * Today, I created a graphical application in Python using Tkinter that allows users to apply a floodfill operation to an image. The application provides a simple interface for loading an image, selecting a color, and applying the floodfill to change the color of a specific region. Here’s a summary of the key components of this project:
    - **Image Loading and Display**:
      - Implemented a file dialog to allow users to select an image from their system. The selected image is then displayed on a Tkinter canvas.
      - Utilized the PIL (Python Imaging Library) to handle image loading and conversion to the RGB format, ensuring compatibility with various image types.
    - **Floodfill Operation**:
      - Added a floodfill feature where the user can choose a color using a color chooser dialog, and apply it to a specific pixel on the image.
      - The floodfill algorithm fills all connected pixels with the chosen color, making it easy to change the appearance of large areas within the image.
    - **Saving the Modified Image**:
      - Integrated a save dialog that allows users to save the modified image in their desired format (PNG, JPEG, etc.).
      - Ensured that the application handles any errors during the save process, providing user feedback through message boxes.
    - **User Interface**:
      - Designed a clean and intuitive user interface with buttons for loading, applying floodfill, and saving the image. The interface is styled with colors and fonts to enhance the user experience.
    - **Error Handling**:
      - Included comprehensive error handling to manage issues like unsupported image formats, out-of-bound pixel selections, and file save errors, ensuring a robust application.

  * This project was an excellent exercise in working with images and enhancing my skills in Tkinter and PIL. It allowed me to delve deeper into image processing techniques and GUI development in Python.
* Day 159: 🏠 Real Estate Data Visualization with Folium 🗺️

  * Today, I worked on a project that visualizes real estate data using Folium, a powerful Python library for creating interactive maps. The project was inspired by a [NeuralNine](https://www.youtube.com/watch?v=5UQyxgiQAzk) video, which provided a great foundation for this type of data visualization. Here’s a summary of the key components of this project:
  
    - **Data Handling**:
      - Utilized the California Housing dataset provided by Scikit-Learn to analyze various features such as median house value, average number of rooms, and population.
      - Converted the dataset into a Pandas DataFrame for easy manipulation and analysis.

    - **Map Initialization**:
      - Created an interactive map centered on the average latitude and longitude of the data points.
      - Used Folium to set up the base map with a zoom level appropriate for visualizing the entire California region.

    - **Marker Creation**:
      - Iterated through each row of the dataset to add circle markers on the map, with each marker representing a location in the dataset.
      - Adjusted the size of the markers based on the normalized average number of rooms, providing a visual indication of housing density.
      - Applied a color gradient to the markers based on the median house value, allowing for quick visual identification of high-value areas.

    - **Popup Information**:
      - Added detailed popups to each marker, displaying information such as median house value, average rooms, population, and median income.
      - Ensured the popups are clear and informative, making the map not only visually appealing but also data-rich.

    - **Additional Features**:
      - Integrated a minimap plugin for better navigation and spatial context, enhancing the user’s ability to explore different regions.
      - Saved the final interactive map as an HTML file, making it easy to share and view on any web browser.

  * This project was a great exercise in combining data science with geographic visualization. It allowed me to deepen my understanding of how to represent complex datasets in a user-friendly manner using Python and Folium. Special thanks to NeuralNine for the inspiration!
* Day 160: Top 1000 Global Tech Companies Dataset (2024) [Kaggle](https://www.kaggle.com/datasets/muhammadehsan000/top-1000-global-tech-companies-dataset-2024/code)

  * Today, I explored the Top 1000 Global Tech Companies dataset from Kaggle, focusing on data analysis and visualization. Below is a summary of the key activities and findings:
  
    - **Data Loading**: 
      - Loaded the dataset using Pandas and inspected the initial data structure.
  
    - **Data Cleaning**:
      - Renamed the "Market Cap" column to "Market_Cap" for easier access and consistency.
      - Checked for and identified any missing data within the dataset.
  
    - **Exploratory Data Analysis (EDA)**:
      - **Categorical Features**:
        - Created count plots for the "Country," "Sector," and "Industry" features to visualize their distributions.
        - Analyzed the distribution of industries across different countries using a heatmap.
        - Focused on the top 10 industries to further analyze their distribution by country.
      - **Numerical Features**:
        - Visualized the distribution of company rankings within the dataset.
        - Examined the top 10 companies by market capitalization, converting the values to billions for clarity.
      - **Country Distribution**:
        - Analyzed the distribution of companies by country, identifying the top 10 countries by the number of companies.
  
    - **Automated Reporting**:
      - Developed functions to automate the generation of statistical summaries, distribution graphs, and correlation analyses for both numerical and categorical variables.
      - These functions facilitate rapid insights and visualizations for future projects involving similar datasets.

  * This analysis provided a comprehensive understanding of the distribution of tech companies globally, with insights into key industries and market leaders. The automated report generation process developed can be applied to future datasets for efficient and consistent analysis.
* Day 161: 🏨 Hotel Reservation System in Python 🏢

  Today, I developed a Hotel Reservation System using Python, focusing on Object-Oriented Programming (OOP) principles such as inheritance, encapsulation, and abstraction. This project is designed to manage guests, rooms, and reservations in a streamlined and efficient manner. Here's a summary of the key features:

  - **Encapsulation**: The `Person` class encapsulates the attributes `name` and `ID number`, making them private to protect data integrity. Getter methods are provided to access these attributes safely.
    
  - **Inheritance**: The `Guest` class inherits from the abstract base class `Person`, which defines common attributes for all persons in the system. This ensures code reusability and consistency.

  - **Abstraction**: The `Person` class includes an abstract method `get_description`, which is implemented by the `Guest` class to provide a detailed description of the guest. This enforces a consistent interface across different types of persons in the system.

  - **Room Management**: The `Room` class manages the details of each room, such as the number of beds, baths, food service, and entertainment availability. It also tracks the guests assigned to each room.

  - **Reservation System**: The `Reservation` class ties together the guest and room information, storing details such as check-in and check-out dates. Guests can have multiple reservations, and rooms can accommodate multiple guests.

  - **User Interaction**: A menu-driven interface allows users to register new guests and rooms, make reservations, and view detailed information about guests and rooms. This interface demonstrates the practical application of OOP principles in a real-world scenario.

  - **Data Organization**: Dictionaries are used to store and manage instances of guests and rooms, providing efficient access and updates to the data.

  This project was an excellent opportunity to apply OOP concepts in creating a functional and user-friendly hotel reservation system. It reinforced my understanding of how abstraction, inheritance, and encapsulation can be used to build organized and scalable software solutions.
* Day 162: 🌀 Gray Code Generator - Recursive Algorithm 🌀

  * Today, I explored and implemented a Gray Code Generator using a recursive algorithm in Python. Gray codes are binary sequences where two successive values differ in only one bit, making them useful in error correction, digital communications, and other fields. Here's a summary of what I accomplished:
    - **Recursive Generation of Gray Codes**:
      - Developed the function `generateGrayarr(n)` to generate all possible n-bit Gray codes.
      - Utilized recursion to progressively build the Gray code sequences, starting with the base patterns "0" and "1".
    - **Base Case Handling**:
      - Established a base case that handles scenarios where `n` is 0 or negative, ensuring no Gray codes are generated when `n` is invalid.
    - **Efficient Code Generation**:
      - Implemented a loop to iteratively generate 2^n Gray codes by appending previously generated codes in reverse order.
      - Prefixed "0" to the first half and "1" to the second half of the Gray codes during each iteration, effectively doubling the number of codes.
    - **Binary Manipulation**:
      - Utilized bitwise operations (`<<` and `1 << n`) to manage and generate the appropriate number of codes efficiently.
    - **Output Display**:
      - Printed all generated n-bit Gray codes, providing a clear representation of the output for a 5-bit Gray code sequence.

  * This project provided a solid exercise in recursion, bitwise operations, and efficient algorithm design. The Gray Code Generator is a powerful tool in various computational applications, and implementing it was a great way to deepen my understanding of recursive sequences and binary operations.

* Day 163: Technical Test "merge_intervals" and "insert_intervals" [LeetCode](https://leetcode.com/problems/)

  - **merge_intervals**: Developed a solution for the Merge Intervals problem, where the goal is to merge all overlapping intervals in a given list of intervals. The algorithm starts by sorting the intervals based on their starting times. It then iterates through the sorted list, merging intervals that overlap by adjusting the end time of the current interval. If no overlap is found, the current interval is added to the list of merged intervals. This approach ensures that all overlapping intervals are merged efficiently. The solution has a time complexity of O(n log n) due to the initial sorting step, where n is the number of intervals. [Problem Description: Merge Intervals](https://leetcode.com/problems/merge-intervals/description/)

  - **insert_intervals**: Solved the Insert Interval problem, where the task is to insert a new interval into an existing list of non-overlapping intervals and merge if necessary. The solution involves three main steps: adding all intervals that come before the new interval, merging the new interval with any overlapping intervals, and then adding the remaining intervals that come after. This method ensures that the intervals remain sorted and non-overlapping after insertion. The algorithm has a time complexity of O(n), where n is the number of intervals in the list. [Problem Description: Insert Interval](https://leetcode.com/problems/insert-interval/description/)
* Day 164: 🧮 BMI Calculator with Tkinter and Matplotlib 📊

  * Today, I developed a Body Mass Index (BMI) calculator using Python, Tkinter, and Matplotlib. The application not only calculates BMI based on user input but also provides health recommendations and visualizes BMI and weight trends. Here’s a breakdown of the key features of this project:
    - **BMI Calculation**:
      - Implemented a function to calculate BMI from the user's weight and height, converting height from centimeters to meters for accurate results.
      - Displayed the BMI result in the interface along with a personalized health recommendation based on the calculated BMI.
    - **Dynamic Interface**:
      - Enhanced the user experience by changing the background color of the interface based on the BMI category (e.g., underweight, normal weight, overweight, obese).
      - Added the ability to reset input fields and clear the results, making the application user-friendly and intuitive.
    - **Calculation History**:
      - Implemented a history feature that keeps track of the last five BMI calculations, displaying them in a list within the application.
      - Provided options to save and load the calculation history to/from a JSON file, ensuring data persistence and allowing users to track their BMI over time.
    - **Graphical Visualization**:
      - Used Matplotlib to create and display graphs that show the evolution of BMI and weight over time, giving users a clear visual representation of their progress.
      - Incorporated interactive elements in the Tkinter interface to seamlessly integrate the graphs with the rest of the application.
    - **Error Handling**:
      - Included robust error handling to manage invalid inputs, such as non-numeric values, ensuring the application operates smoothly and provides helpful feedback to users.

  * This project was a great way to practice integrating graphical elements with data processing in Python. It allowed me to enhance my skills in both Tkinter and Matplotlib, creating a functional and visually appealing health tool.
* Day 165: 🗂️ File Manager Pro with Python 🖥️

  - Today, I developed a File Manager system in Python that enables users to efficiently manage their files and folders. This application allows for creating, finding, listing, and deleting files or folders while also calculating the total size of all files in a directory. Below are the key features and components of this project:

    - **File and Folder Creation**:
      - Implemented functionality to create new files with specified names, extensions, and sizes. The system also supports the creation of folders within the base directory.
      - Ensured that the necessary directories are created automatically if they don't exist before a file is generated.

    - **Search Functionality**:
      - Developed a search feature to locate the path of a specific file or folder within the base directory. The system recursively searches through all subdirectories to find the desired item.

    - **Listing Contents**:
      - Created a method to list all files and folders within a given directory, providing an easy overview of the contents.

    - **Size Calculation**:
      - Added the ability to calculate the total size of all files within the base directory, summing up the sizes of individual files to give an accurate total.

    - **File Deletion by Extension**:
      - Included a feature to delete all files with a specified extension across the entire directory structure, helping in bulk file management.

    - **Interactive Command-Line Interface**:
      - Built a user-friendly menu that allows users to interact with the system through various options, such as creating files, listing contents, and deleting files.

    This project provided an excellent opportunity to delve into file management operations using Python’s `os` library. It helped me strengthen my understanding of directory traversal, file handling, and creating user-friendly command-line interfaces.
* Day 166: 🥤 Soda Combinations Generator - Recursive Algorithm 🥤

  * Today, I developed a Python program to generate all possible combinations of a list of sodas using recursion. This project focused on understanding and implementing recursive algorithms to explore all subsets of a given set. Here’s what I achieved:
  
    - **Recursive Generation of Combinations**:
      - Created the function `soda_combinations(sodas, current_combo=[], index=0)` to recursively generate and print all possible combinations of sodas.
      - Implemented two recursive cases: one to include the current soda in the combination and another to exclude it, ensuring all subsets are covered.
    
    - **Base Case Handling**:
      - The base case handles scenarios where all sodas have been considered (`index == len(sodas)`). When this condition is met, the current combination is printed, representing one possible subset.
    
    - **Exploring All Possibilities**:
      - The algorithm explores every combination, from no sodas to the full list, by either including or excluding each soda in the list. This approach ensures that all possible combinations are generated and displayed.
    
    - **Output Display**:
      - Each combination is printed as it is generated, providing a clear and immediate representation of all subsets of the soda list.

  * This project was a great exercise in recursive thinking and subset generation. The ability to systematically explore all possible combinations is a fundamental technique in combinatorial problems, and this implementation deepened my understanding of recursive algorithms in Python.
* Day 167: Technical Test "lengthOfLastWord" and "generateMatrix" [LeetCode](https://leetcode.com/problems/)

  - **lengthOfLastWord**: Implemented a solution for the "Length of Last Word" problem, where the goal is to find the length of the last word in a given string. The algorithm trims any trailing spaces from the string and then finds the index of the last space to determine the length of the last word. The solution efficiently handles different cases, including strings with multiple spaces and empty strings. This method has a time complexity of O(n), where n is the length of the string. [Problem Description: length Of Last Word](https://leetcode.com/problems/length-of-last-word/description/)

  - **generateMatrix**: Solved the "Spiral Matrix II" problem, which involves generating an n x n matrix filled with elements from 1 to n² in a spiral order. The solution uses a systematic approach to fill the matrix by defining boundaries (left, right, top, bottom) and progressively moving inward while filling the matrix. This ensures that the matrix is filled correctly in spiral order. The algorithm has a time complexity of O(n²), where n is the dimension of the matrix. [Problem Description: generate Matrix](https://leetcode.com/problems/spiral-matrix-ii/description/)
* Day 168: Compound Interest Calculator in Python by [NeuralNine](https://www.youtube.com/watch?v=OqCqFfLfFsk)

  * Today, I worked on a project that implements a Compound Interest Calculator using Python and Flask, inspired by a [NeuralNine](https://www.youtube.com/watch?v=OqCqFfLfFsk) tutorial. Here's a breakdown of the key components and features of the project:

    - **User Interface**:
      - Built a simple and user-friendly web interface using HTML and Flask, allowing users to input initial deposit, interest rate, contribution amount, compounding type, and time period in years.
      - Integrated form handling in Flask to process the user input and display the calculated results.

    - **Compound Interest Calculation**:
      - Implemented the compound interest formula to calculate the final amount, considering both the initial deposit and regular contributions over time.
      - Allowed users to choose between monthly and annual compounding, affecting the frequency of interest application.

    - **Visualization**:
      - Used Matplotlib to generate a line graph comparing the growth of the investment with and without interest over the specified time period.
      - Embedded the graph directly in the web page, providing a visual representation of the investment’s growth.

    - **Results Display**:
      - Displayed the final amount with interest and the difference compared to the total contributions without interest.
      - Provided a clear comparison of how much the investment grows due to compound interest.

    - **Technical Implementation**:
      - Utilized Python for back-end calculations and Matplotlib for data visualization.
      - Designed the front-end using HTML, with integration into the Flask framework for dynamic content rendering.

  * This project was a fantastic opportunity to apply mathematical concepts to a real-world financial application, and to further my skills in web development using Flask. The ability to visualize the results added an extra layer of insight into the power of compound interest, making the project both educational and practical.
* Day 169: 🌱 Plant Management System for "La Planta Feliz" Nursery 🌿

  Today, I developed a Plant Management System using Python to help "La Planta Feliz" nursery efficiently manage their inventory of plants. This project focused on leveraging Object-Oriented Programming (OOP) principles to create a flexible and user-friendly system. Here’s a breakdown of the key features:

  - **Plant Creation**: The `Plant` class was designed to represent each plant in the nursery, encapsulating details such as the plant’s code, name, size, species, and price. This structured approach makes it easy to manage and manipulate plant data.

  - **Handling Tall Plants**: I implemented a method in the `Nursery` class to generate a sublist of plants taller than 2 meters. This feature allows the nursery to quickly identify and manage plants that may require special care or different pricing due to their size.

  - **Removing Plants by Name**: The system includes functionality to remove all plants with a specified name. This is particularly useful for managing inventory when certain plants are discontinued or need to be cleared from stock.

  - **Species Counting**: Another key feature is the ability to count the number of plants of a specific species. This helps in understanding the diversity of the nursery’s inventory and making informed decisions about species-specific care or sales strategies.

  - **User Interaction**: The system is designed with a simple interface that allows users to add new plants, filter plants by size, remove plants by name, and count plants by species. This demonstrates the practical application of OOP principles in managing real-world data.

  - **Data Management**: All plant data is managed using lists and list comprehensions, ensuring efficient storage and retrieval of information. This approach facilitates scalability as the nursery's inventory grows.

  This project was an insightful experience in applying OOP concepts to create a functional and efficient system for managing plant inventory. It reinforced my understanding of how encapsulation and data handling can be effectively used in software development to meet specific business needs.
* Day 170: 🍕🍽️ Pizza Restaurant Sales [Kaggle](https://www.kaggle.com/datasets/shilongzhuang/pizza-sales/data)

  * Today, I delved into the Pizza Restaurant Sales dataset from Kaggle, focusing on data analysis and visualization. Below is a summary of the key activities and findings:

    - **Data Loading**:
      - Loaded the dataset using Pandas and examined the initial data structure to understand its composition.
  
    - **Data Cleaning**:
      - Checked for missing values and verified the integrity of the data.
      - Converted `order_time` to a string type and extracted hour, minute, and second for further analysis.
  
    - **Exploratory Data Analysis (EDA)**:
      - **Categorical Features**:
        - Created count plots for the `pizza_size`, `pizza_category`, and `pizza_name` features to visualize their distributions.
        - Analyzed the distribution of pizza sizes and categories using pie charts.
        - Examined the frequency of orders by hour and day of the week, along with monthly trends.
      - **Numerical Features**:
        - Analyzed total price distributions by pizza name and size using box plots and sunburst charts.
        - Visualized the median prices by pizza size and category using a treemap.
      - **Time Series Analysis**:
        - Investigated order frequencies across different hours of the day and days of the week.
        - Created visualizations to show how order distributions vary by date and hour.
  
    - **Advanced Visualizations**:
      - Generated interactive plots using Plotly, including bar charts for order distributions and sunburst plots for price distributions.
      - Used seaborn and Matplotlib for detailed count plots and box plots, enhancing visual insights.
  
  * This analysis provided a detailed view of the pizza sales data, including insights into order trends, pizza categories, and pricing. The generated visualizations offer a comprehensive understanding of the sales dynamics, aiding in decision-making and strategy formulation for the restaurant.
* Day 171: 🔍 Partitioning a List into Two Equal Subsets - Recursive Algorithm 🔍

  * Today, I developed a Python program to determine if a given list of integers can be partitioned into two subsets with equal sum using recursion. This project focused on implementing recursive techniques to explore the possibility of such a partition. Below is a summary of the key tasks and insights:

    - **Understanding the Problem**:
      - The goal was to check if a list can be split into two subsets with an equal sum, a common problem in dynamic programming and recursion.

    - **Recursive Approach**:
      - Implemented the `can_partition_recursive(nums, target_sum, index, subset)` function, which uses recursion to explore whether a subset with a target sum can be found within the list.
      - The function considers two main scenarios: excluding the current number from the subset and including it, then recursively checks the remaining elements.

    - **Base Case Handling**:
      - The base cases include situations where the target sum becomes zero (indicating a successful partition) or when all elements are considered, and the target sum remains unmet.

    - **Exploring Subsets**:
      - By exploring all possible combinations of the list’s elements, the algorithm identifies whether a valid subset exists that equals half the total sum, thus confirming if the list can be partitioned into two equal subsets.

    - **Output and Visualization**:
      - If a valid partition is found, the program outputs the subsets, providing a clear visual representation of the solution.

  * This project reinforced key concepts in recursive problem-solving and subset exploration, offering a deeper understanding of how to approach partitioning problems with Python. The recursive approach not only highlights the power of recursion in combinatorial problems but also emphasizes the importance of base case management and backtracking in algorithm design.
* Day 172: 🏀 Basketball Player Statistics Generator with Python 📊

  * Today, I developed a Python program that allows users to input basic basketball statistics for a player (points, rebounds, assists) and calculates key metrics such as averages per game, shooting percentages, and more. This project provided an excellent opportunity to work with object-oriented programming and data visualization. Below is a summary of the key tasks and insights:

    - **Understanding the Problem**:
      - The goal was to create a system where users can input game statistics for basketball players and easily calculate and visualize key metrics, such as points per game, rebounds per game, assists per game, and shooting percentages.

    - **Class-Based Approach**:
      - Implemented the `BasketballPlayer` class, which tracks a player's game statistics, calculates averages, and computes shooting percentages. The class structure allowed for a clean and modular design, making it easy to manage and update player stats.

    - **Data Input and Handling**:
      - The program features a menu-driven interface that allows users to create players, select existing players, and input game statistics. This interactive approach ensures that the program is user-friendly and can handle multiple players seamlessly.

    - **Statistics Calculation**:
      - The `calculate_averages` method computes the player's averages per game for points, rebounds, and assists, while the `calculate_shooting_percentage` method determines the shooting accuracy based on the shots made and attempted. These calculations are crucial for analyzing player performance.

    - **Data Visualization**:
      - The `plot_stats` method uses Matplotlib to generate bar charts that visually represent the player's statistics. This feature enhances the program by providing a graphical interpretation of the data, making it easier to identify trends and performance levels.

  * This project reinforced my understanding of object-oriented programming, particularly in the context of sports statistics. The integration of data visualization added an extra layer of insight, demonstrating the value of combining algorithmic calculations with graphical outputs. I'm excited to explore further enhancements, such as incorporating advanced metrics and player comparisons.
* Day 173: 🎵 Discord Music Bot with Python and discord.py 🎶

  * Today, I developed a Discord music bot using Python, `discord.py`, and `yt-dlp`. This bot allows users to play and manage music in a voice channel, providing functionalities such as queuing songs, playing the next track, and skipping the current song. Here’s a summary of the key tasks and insights:

    - **Understanding the Problem**:
      - The goal was to create a Discord bot that can play audio from YouTube in a voice channel. The bot should handle commands for adding songs to a queue, playing them, and managing playback.

    - **Bot Setup and Intents**:
      - Configured the bot with necessary intents to read message content and handle voice state updates. This setup ensures the bot can interact with users and manage voice connections effectively.

    - **Music Playback**:
      - Implemented the `play` command to search for a song on YouTube, retrieve its URL, and add it to a queue. The bot connects to the user's voice channel if it is not already connected.

    - **Queue Management**:
      - Developed a queue system to manage song playback. The `play_next` method handles playing the next song in the queue and automatically continues playback when a song ends.

    - **Error Handling**:
      - Incorporated error handling to manage issues that may arise during the search and playback process, providing users with clear feedback if something goes wrong.

    - **Skipping Songs**:
      - Added a `skip` command to stop the currently playing song and move to the next one, enhancing the bot's usability.

  * This project provided valuable experience in integrating Discord's API with audio streaming, handling asynchronous tasks, and implementing user commands. The bot's functionality showcases the practical application of Python in creating interactive and useful tools for Discord communities.
* Day 174: Technical Test "getPermutation" and "rotateRight" [LeetCode](https://leetcode.com/problems/)

  - **getPermutation**: Implemented a solution for the "Permutation Sequence" problem, where the task is to return the k-th permutation sequence of numbers from 1 to n. The approach involves calculating the factorial of n to determine the number of permutations for each block of numbers. The solution uses this factorial to pick the correct digit for each position in the permutation and progressively builds the k-th sequence by updating k for the next position. The algorithm efficiently finds the desired permutation by reducing the search space with each step. The time complexity is O(n²) due to the factorial computations and list manipulations.  
    [Problem Description: getPermutation](https://leetcode.com/problems/permutation-sequence/description/)

  - **rotateRight**: Solved the "Rotate List" problem, where the objective is to rotate a linked list to the right by k places. The algorithm first calculates the length of the list and makes it circular by connecting the last node to the head. Afterward, it determines the new tail and head by traversing the list based on the modulo of k with the list length. The final step involves breaking the circular connection to form the rotated list. This method has a time complexity of O(n), where n is the length of the list.  
    [Problem Description: rotateRight](https://leetcode.com/problems/rotate-list/description/)
* Day 175: Build Your Own News Hub in Python - RSS Feed Aggregator by [NeuralNine](https://www.youtube.com/watch?v=5mEmE7pBI1A)

  * Today, I worked on a project to create an RSS Feed Aggregator using Python and Flask, inspired by a [NeuralNine](https://www.youtube.com/watch?v=5mEmE7pBI1A) tutorial. This project fetches and displays news articles from multiple sources in a user-friendly interface. Here's a breakdown of the key components and features:

    - **User Interface**:
      - Developed a simple web interface with HTML templates and Flask, allowing users to browse the latest news articles from different sources.
      - Implemented a search functionality that enables users to look for specific keywords across the fetched news articles.

    - **RSS Feed Parsing**:
      - Used the `feedparser` library to fetch and parse RSS feeds from various news sources such as Yahoo Finance, Hacker News, Wall Street Journal, and CNBC.
      - Dynamically displayed the fetched articles in a paginated format, allowing for better user experience when browsing through large sets of articles.

    - **Search Functionality**:
      - Added a search form to the header of the website, enabling users to input a keyword and retrieve relevant articles containing that term.
      - Filtered the RSS feed entries to match the search query, displaying the results in a dedicated search results page.

    - **Pagination**:
      - Implemented a pagination system that divides articles into pages, showing 10 articles per page. Users can navigate between pages using the “Next” and “Previous” buttons.

    - **Technical Implementation**:
      - The back-end logic was implemented in Python using the Flask framework, while HTML was used for the front-end.
      - The project makes use of RSS feeds and dynamically updates the content based on the fetched data.
      - Designed reusable HTML templates with `base.html` providing a consistent layout, and specific pages like `index.html` and `search_results.html` handling different types of content.

  * This project was an excellent exercise in integrating multiple technologies, including Flask for web development, RSS feeds for content aggregation, and HTML for building dynamic and responsive web pages. It provided a great opportunity to work on creating a functional news hub with real-time data.
* Day 176: 🔺 Maximum Sum Path in a Triangle - Recursive Algorithm 🔺

  * Today, I worked on a Python program that finds the maximum sum path from the top to the bottom of a triangle using recursion. The project focused on applying recursive techniques to explore different paths and choose the one with the maximum sum. Below is an overview of the key components and insights:

    - **Understanding the Problem**:
      - The goal was to navigate a triangle from the top to the bottom, selecting adjacent numbers in each row, and calculating the maximum possible sum along the way.

    - **Recursive Approach**:
      - Implemented the `max_sum_path(triangle, row, col, n)` function to recursively calculate the maximum sum path by exploring two possible moves: directly below or diagonally to the right.
      - At each step, the function returns the maximum sum path by comparing the two possible paths (left and right).

    - **Base Case Handling**:
      - The base case occurs when the recursion reaches the last row of the triangle, where the function simply returns the value of the current element.
      - This ensures the recursion terminates when all rows are processed.

    - **Initiating the Recursion**:
      - The `find_max_sum(triangle)` function initiates the recursive process from the top of the triangle, passing the necessary parameters to the recursive function to explore all paths.

    - **Output and Visualization**:
      - The program prints the maximum sum path from the top to the base of the triangle, providing a clear indication of the optimal path for maximizing the sum.

  * This project was a great way to apply recursive problem-solving to a real-world mathematical challenge. It also reinforced the importance of recursion in exploring all possible combinations and selecting the optimal solution, offering valuable insights into dynamic programming techniques as well.
* Day 177: 📂 File System Management in Python 🖥️

  Today, I worked on a File System Management project using Python, which focused on applying Object-Oriented Programming (OOP) principles like inheritance, encapsulation, and abstraction to manage files and folders. Here are the key highlights of the project:

  - **Encapsulation**: The `FileSystemItem` class encapsulates the attributes `name` and `path`, making them private to ensure data protection. Getter methods provide controlled access to these attributes.

  - **Inheritance**: The `File` and `Folder` classes inherit from the abstract base class `FileSystemItem`. This ensures that both files and folders have common attributes and behaviors, promoting code reusability.

  - **Abstraction**: The `FileSystemItem` class includes an abstract method `get_description`, which is implemented differently by `File` and `Folder` classes to return specific details about each item. This maintains a consistent interface while allowing customized behavior for different types of items.

  - **File and Folder Operations**: Users can register new files and folders, check their details, and perform operations on files (such as reading or writing). A menu-driven interface makes interaction with the system user-friendly and practical.

  - **File System Interaction**: The project interacts with the actual file system, checking if the paths provided for files and folders exist and retrieving file sizes. This adds a layer of real-world utility by directly integrating with the operating system.

  - **File Operations**: The `FileOperation` class logs operations performed on files (such as read, write, or execute), along with the date of the operation, providing a history of interactions with each file.

  This project provided a practical implementation of OOP concepts and demonstrated how they can be used to build scalable and structured systems. It was a great opportunity to reinforce my understanding of how inheritance, encapsulation, and abstraction contribute to clean, maintainable code in real-world applications.

* Day 178: 🛒📊 Customer Purchasing Behaviors [Kaggle](https://www.kaggle.com/datasets/hanaksoy/customer-purchasing-behaviors/data)

  * Today, I worked with the Customer Purchasing Behaviors dataset from Kaggle, focusing on data analysis and visualization. Below is a summary of the key activities and insights obtained:

    - **Data Loading**:
      - Imported the dataset using Pandas and conducted an initial examination to understand the data structure and key features.

    - **Data Cleaning**:
      - Checked for missing values and ensured the data's integrity.
      - Performed data type conversions, particularly for dates and categorical variables, to facilitate analysis.
    
    - **Exploratory Data Analysis (EDA)**:
      - **Categorical Features**:
        - Created count plots for various features like product categories, customer segments, and purchase channels.
        - Analyzed the distribution of customer segments and product categories using pie charts.
        - Investigated the frequency of purchases across different days, months, and customer segments to identify trends.
      - **Numerical Features**:
        - Analyzed the distribution of total spending by customer and product category using box plots and bar charts.
        - Visualized the average and median purchase amounts across different customer segments and product types.
      - **Time Series Analysis**:
        - Explored how purchasing behaviors varied by time of day, day of the week, and month.
        - Created visualizations showing the distribution of purchases over time, including monthly and daily trends.

    - **Advanced Visualizations**:
      - Utilized Plotly to create interactive visualizations such as heatmaps for purchase frequency across different days and customer segments.
      - Generated detailed bar charts and sunburst plots to explore customer purchase patterns by product category and segment.
      - Used seaborn and Matplotlib to produce enhanced count plots, box plots, and time series graphs for deeper insights.

  * This analysis provided valuable insights into customer purchasing behaviors, including trends across product categories, spending patterns, and customer segments. The visualizations helped uncover key patterns that can guide marketing and sales strategies for businesses looking to optimize their offerings based on customer data.
* Day 179: Movie Recommendation App with Streamlit  
  * Today, I focused on building a **Movie Recommendation App** using Streamlit, a powerful open-source framework designed for creating web applications. The app allows users to select a movie genre and receive recommendations based on a dataset of movies. Here's a breakdown of what I accomplished:

    - **Setting Up the Environment**: Installed Streamlit and other necessary libraries like Pandas for data manipulation.
    - **Dataset**: Used a dataset from [Kaggle](https://www.kaggle.com/datasets/akshaypawar7/millions-of-movies) that contains information about millions of movies, including genres, ratings, release dates, and more.
    - **Loading Data Efficiently**: Implemented data caching using `st.cache_data` to improve performance when loading the movie dataset.
    - **User Interface**: Built an intuitive UI where users can:
      - Preview the movie dataset, showing details like title, genres, release date, rating, and vote count.
      - Select a movie genre from a dropdown menu and receive a list of recommended movies from that genre.
    - **Movie Filtering and Display**: Filtered the movies by genre and displayed each recommendation with details such as the title, release year, rating, vote count, and a brief overview. Additionally, the app displays the movie poster fetched from an external source.
    - **Sidebar with Additional Information**: Created a sidebar that provides information about the app and some statistics about the dataset, including the total number of movies and the top 5 highest-rated films.
  
  This project highlights the ease of using Streamlit to build interactive applications with dynamic content based on user input. The recommendation feature provides a practical use case for filtering and displaying data, making it a helpful tool for exploring movie options by genre. 

  This was an excellent exercise in building a recommendation system, working with movie datasets, and creating a user-friendly interface.
* Day 180: Technical Test "uniquePaths" and "uniquePathsWithObstacles" [LeetCode](https://leetcode.com/problems/)
  
  - **uniquePaths**: Implemented a solution for the "Unique Paths" problem, where the task is to determine the number of unique paths a robot can take to reach the bottom-right corner of an m x n grid, starting from the top-left corner. The robot can only move either right or down at any point. The approach uses dynamic programming to compute the number of ways to reach each cell in the grid by adding the number of ways to reach the top and left cells. The solution has a time complexity of O(m * n) as we fill up the grid iteratively.
    [Problem Description: uniquePaths](https://leetcode.com/problems/unique-paths/description/)

  - **uniquePathsWithObstacles**: Solved the "Unique Paths II" problem, which is an extension of the "Unique Paths" problem but introduces obstacles in the grid, marked as 1. The robot must avoid these obstacles when moving to the bottom-right corner. The algorithm uses a modified dynamic programming approach to track valid paths, ensuring that any cell marked with an obstacle is not considered in the path calculation. The time complexity remains O(m * n), as the grid is processed similarly to the first problem but with obstacle checks.
    [Problem Description: uniquePathsWithObstacles](https://leetcode.com/problems/unique-paths-ii/description/)

* Day 181: 🏀 Basketball Team Generator and Visualizer with Python 📊

  * Today, I developed a Python program that generates a team of random basketball players and visualizes their statistics using various charts. This project allowed me to explore data generation, visualization, and file handling in Python. Here’s a summary of the key tasks and insights:

    - **Understanding the Problem**:
      - The objective was to create a system that generates random basketball player statistics and provides visualizations for analysis. The program includes functionalities to generate player data, display it in graphical formats, and optionally save the generated data to a file.

    - **Player Generation**:
      - Implemented the `generate_player` function to create random player profiles, including attributes such as name, height, position, and performance metrics like points per game, rebounds, assists, and field goal percentage. This function uses the `random` library to ensure that each player’s statistics are unique and realistic.

    - **Data Visualization**:
      - The `plot_player_stats` function creates a polar bar chart using Matplotlib to visualize rebounds, assists, and field goal percentage. This chart helps in comparing these metrics in a circular format, making it easier to see the distribution of stats.
      - The `plot_points` function generates a separate bar chart to display the points scored per game by each player. This visualization highlights the player's scoring ability in a straightforward bar format.

    - **Team Creation and Saving**:
      - The `create_team` function generates a list of random players based on user input for the number of players. This feature allows for flexible team sizes.
      - The `save_team` function saves the generated team data to a text file, making it easy to store and review the player information later. The data is written in a human-readable format, providing a comprehensive view of each player’s attributes.

    - **Interactive User Experience**:
      - The main program includes user prompts to determine the number of players to generate and whether to save the team data. This interactive approach ensures that the program can be used effectively based on user preferences.

  * This project provided valuable experience in combining data generation with visualization techniques. By integrating polar and bar charts, the program offers a comprehensive view of player statistics. The file-saving feature also enhances the program’s usability by allowing users to store and manage player data efficiently. Moving forward, I plan to explore additional enhancements, such as advanced statistical analyses and more sophisticated visualizations.
* Day 182: 🍽️ Restaurant Management System in Python 🍴

  Today, I worked on a Restaurant Management System using Python, with a focus on Object-Oriented Programming (OOP) principles such as inheritance, encapsulation, and abstraction. The project allows customers to place orders, manage food and drinks, calculate tips, and keep track of the server responsible for each order. Below are the key highlights:

  - **Encapsulation**: The `Person` class encapsulates attributes like `name` and `id_number`, ensuring that personal information is protected by making them private. Controlled access is provided through getter methods.

  - **Inheritance**: The system uses inheritance for customer and server classes, both derived from the `Person` abstract class. This allows reusability of common attributes (like `name` and `id_number`) while providing specialized functionality for each subclass.

  - **Abstraction**: The `Person` class contains an abstract method `get_description`, which is implemented by both `Customer` and `Server` classes. This ensures that each type of person in the system has a tailored description, maintaining a consistent interface.

  - **Order Management**: Customers can place orders that include food, drinks, and optional tips. The `Order` class captures details like order number, total price, and the server assigned to the order. This makes the system easy to extend with new features in the future.

  - **Billing and Tips**: The system calculates the total bill based on the items ordered, with an option to add a tip. The final payment amount is clearly displayed, offering both customer satisfaction and ease of tracking for the restaurant.

  - **Menu Options**: A menu-driven interface allows for interaction with the system, where users can place orders, check order details, and calculate the final bill. This makes the program user-friendly and practical for a real restaurant scenario.

  This project was an excellent exercise in applying OOP principles to create a well-structured and maintainable system. I had the opportunity to refine my understanding of how abstraction, encapsulation, and inheritance work together to create clean and reusable code, all while building a practical restaurant management tool.


* Day 183: 🌊 Crossing the River Problem - Recursive Solution 🌊

  * Today, I developed a Python program that solves the classic **Crossing the River Problem** using a recursive approach. This problem involves moving a farmer, a wolf, a goat, and a cabbage across a river with specific constraints, ensuring no dangerous combinations are left unsupervised. Here's an overview of the key components and insights from this project:

    - **Understanding the Problem**:
      - The goal is to transport the farmer, the wolf, the goat, and the cabbage from the left bank of the river to the right bank using a boat. However, there are restrictions:
        - The wolf cannot be left alone with the goat.
        - The goat cannot be left alone with the cabbage.
        - Only two items (the farmer and one other) can cross the river at a time.

    - **Recursive Approach**:
      - Implemented the `solve(state, path=[])` function to recursively explore possible moves while ensuring the state remains valid after each crossing.
      - The program explores all possible combinations of moves, considering the constraints and checking if the goal state (all items on the right bank) is achieved.

    - **State Validation**:
      - A helper function `is_valid_state(state)` ensures that no illegal combinations occur on either bank when the farmer is absent. This prevents situations where the goat is eaten by the wolf or the cabbage is eaten by the goat.

    - **Recursive Movement**:
      - The `move_item(state, item)` function moves the farmer and an optional item between the banks. The recursion avoids revisiting the same state to ensure efficiency.

    - **Goal Achievement**:
      - The base case occurs when all objects are successfully transported to the right bank, and the recursion terminates with the correct solution path.

    - **Output and Visualization**:
      - The program prints each step of the solution, showing the left and right bank configurations after each crossing, leading to the final state where all items have crossed safely.
* Day 184: Technical Test "minPathSum" and "isNumber" [LeetCode](https://leetcode.com/problems/) 

  - **minPathSum**: Implemented a solution for the "Minimum Path Sum" problem, where the task is to find the path from the top-left corner to the bottom-right corner of a grid that minimizes the sum of all numbers along the path. The robot can only move either right or down at any point in time. The approach uses dynamic programming to iteratively update the grid by calculating the minimum sum required to reach each cell. The time complexity is O(m * n), where m and n represent the dimensions of the grid.
    [Problem Description: minPathSum](https://leetcode.com/problems/minimum-path-sum/description/)

  - **isNumber**: Solved the "Valid Number" problem, which validates if a given string can be interpreted as a valid number according to specific rules, including handling integers, decimal numbers, and exponents. The solution uses regular expressions to match the structure of valid numbers, ensuring correct handling of edge cases such as signs, decimal points, and scientific notation. The solution processes the string in O(1) time, as regular expressions offer an efficient way to match the pattern.
    [Problem Description: isNumber](https://leetcode.com/problems/valid-number/description/)
* Day 185: Estimating Pi with Monte Carlo Method
  Today, I focused on building a Python program to estimate the value of **Pi** using the **Monte Carlo** method. This method involves generating random points in a unit square and calculating how many fall within a unit circle to estimate the value of Pi. Here's a breakdown of what I accomplished:

  - **Importing Libraries**: Utilized essential Python libraries like `matplotlib` for plotting and `numpy` for generating random points and mathematical calculations.
    
  - **Monte Carlo Method Implementation**:
    - Created a function `pi_montecarlo(n, n_exp)` where:
      - `n` represents the number of random points generated per experiment.
      - `n_exp` represents the number of experiments to perform.
    - For each experiment, the program generates random `(x, y)` points between 0 and 1.
    - It calculates the distance of each point from the origin and checks whether the point lies inside the unit circle.
    - Repeated the experiment `n_exp` times and averaged the results to get a more accurate estimate of Pi.

  - **Visualizing the Results**:
    - Plotted the estimated values of Pi over multiple experiments to observe how the accuracy improves as the number of experiments increases.
    - The final plot includes:
      - Estimated values of Pi for each experiment.
      - Clear labels for the x-axis (Experiment Number) and y-axis (Estimated Pi).
      - A title to make the plot more informative: "Estimated Pi Values over Experiments."
    
  - **Program Execution**:
    - Ran the function with 10,000 points per experiment and 200 experiments.
    - Displayed the average estimated value of Pi and plotted the results for visualization.

  This project provides an excellent example of applying statistical techniques to estimate a mathematical constant. The Monte Carlo method demonstrates how random sampling can be used to approximate complex values with increasing accuracy as more data points are used.
* Day 186: BMI Calculator in Python - Flask Application
  * Today, I worked on building a simple BMI (Body Mass Index) calculator using Python and Flask. This project allows users to input their weight and height, calculate their BMI, and receive a health category based on the result. Below is a breakdown of the key components and features:

    - **User Interface**:
      - Developed a clean and minimalistic web interface using HTML and CSS. The form takes the user’s weight (in kilograms) and height (in meters) as inputs and calculates the BMI upon form submission.
      - Implemented responsive design with a focus on user-friendliness, ensuring the form and results are clearly visible on both desktop and mobile devices.

    - **BMI Calculation**:
      - Used a simple formula to calculate BMI: `BMI = weight / (height^2)` where weight is in kilograms and height is in meters.
      - Displayed the calculated BMI along with a corresponding health category:
        - **Underweight**: BMI less than 18.5
        - **Normal weight**: BMI between 18.5 and 24.9
        - **Overweight**: BMI between 25 and 29.9
        - **Obesity**: BMI of 30 or higher

    - **Result Display**:
      - After submitting the form, the user is shown their calculated BMI and the associated health category (e.g., "Normal weight").
      - Implemented condition-based formatting for better visual feedback. For example, different BMI categories are highlighted with different colors for clarity.

    - **Technical Implementation**:
      - The back-end logic is written in Python using the Flask framework, which processes the input data, calculates the BMI, and renders the result back to the user.
      - A `POST` method was used to handle form submission and calculation. The results are dynamically displayed using Jinja2 templates.
      - The front-end includes a `style.css` file in the `/static/css` directory to ensure the application has a clean, modern look.

    * This project was a great opportunity to further enhance my Flask skills while building a practical health-related application. It provided insights into form handling, dynamic content generation, and simple calculations based on user input.
* Day 187: 🎲 Lottery Simulator in Python 🎯 

  Today, I worked on a Lottery Simulator using Python and Tkinter, creating a graphical interface for users to choose their lottery numbers and check if they match randomly generated lottery results. Below are the key highlights of the project:

  - **User Input**: The program allows users to input six unique numbers between 1 and 49. These numbers are validated to ensure they meet the required conditions, such as being within the range and not repeating.

  - **Random Number Generation**: The program generates six random lottery numbers using Python's `random.sample` function, ensuring that each number is unique. These numbers are then compared with the user's input.

  - **Matching Logic**: The user’s input is compared with the randomly generated lottery numbers, and the number of matches is displayed in a message box. If all six numbers match, a congratulatory message appears, declaring the user as the winner.

  - **Graphical User Interface (GUI)**: The program uses Tkinter to create a simple and clean interface. The layout is organized with entry boxes for user input and a button that triggers the lottery check. The interface includes:
    - **Entry Fields**: Six entry fields for users to input their numbers.
    - **Lottery Check Button**: A button that checks the user's numbers against the generated lottery numbers and displays the result.
    - **Message Box**: A message box to display the outcome, whether it's a win or how many numbers matched.

  - **Error Handling**: The system handles input errors gracefully, ensuring that users input valid numbers and receive informative messages if they don't.
* Day 188: Technical Test "addBinary" and "plusOne" [LeetCode](https://leetcode.com/problems/) 
  - **addBinary**: Implemented a solution for the "Add Binary" problem, which involves adding two binary strings and returning their sum as a binary string. The approach processes the binary strings from right to left, simulating manual addition by summing digits and tracking carry. The solution handles cases where the strings have different lengths and ensures that any remaining carry is accounted for in the final result. The time complexity is O(max(n, m)), where n and m are the lengths of the input strings.
    [Problem Description: addBinary](https://leetcode.com/problems/add-binary/description/)

  - **plusOne**: Solved the "Plus One" problem, where the task is to increment an integer represented by an array of its digits. The algorithm starts from the least significant digit and adds one, adjusting for carries as necessary. If the entire number consists of nines, a new digit is added at the beginning of the array. The time complexity is O(n), where n is the number of digits in the input array.
    [Problem Description: plusOne](https://leetcode.com/problems/plus-one/description/)
* Day 189: 🔍 Longest Common Subsequence (LCS) 

  Today, I worked on the Longest Common Subsequence (LCS) problem using Python, focusing on recursion to solve the problem. This algorithm finds the longest subsequence common between two given strings. Below are the key highlights:

  - **Recursion**: The solution is implemented using a recursive approach. The base case checks if either of the strings is empty, in which case the LCS is zero. Otherwise, the function compares the last characters of both strings.

  - **Character Matching**: If the last characters of the two strings match, the function proceeds by removing the last character from both strings and recursively calling itself. The result is incremented by 1, indicating that the matched character contributes to the LCS.

  - **Character Mismatch**: When the last characters differ, the algorithm explores two options: removing the last character from one of the strings and calling the function recursively on the remaining parts of the strings. The maximum result from these two recursive calls is taken as the LCS length.

  - **Efficiency**: This recursive approach, while intuitive, is not the most efficient for large strings due to its exponential time complexity. However, it serves as a clear demonstration of how recursion can be applied to complex problems like LCS.

  - **Base Cases**: The base cases are crucial to the recursive approach. When either string is reduced to an empty substring, the recursion stops, ensuring that the solution does not continue indefinitely.

  - **Example Case**: For the strings `"AGGTAB"` and `"GXTXAYB"`, the algorithm correctly identifies that the LCS is `"GTAB"` with a length of 4.

  - **Future Enhancements**: This recursive solution can be further optimized using dynamic programming techniques to avoid redundant calculations, making it feasible for larger inputs.

  This project was an excellent opportunity to deepen my understanding of recursion in Python. I explored how breaking down a problem into subproblems can simplify the overall structure, even when the solution is not the most optimal. I look forward to extending this solution with dynamic programming to handle more complex cases efficiently.
* Day 190: 🧠 MNIST Neural Network with Hyperparameter Tuning in Python 🤖
  Today, I worked on building a neural network model using Python and TensorFlow to classify handwritten digits from the MNIST dataset. This project is based on the amazing work and tutorial by **NeuralNine**, which I followed on [YouTube](https://www.youtube.com/watch?v=lKusotIjzwk). I respect and admire the quality of content NeuralNine provides, and this tutorial was a fantastic learning experience. Below are the key highlights:

  - **Model Architecture**: The neural network consists of an input layer, a flattening layer to convert the 2D images into a 1D vector, hidden layers with ReLU activation functions, and a final output layer using softmax activation for multiclass classification. This architecture allows the network to learn complex features of the handwritten digits.

  - **Normalization**: The input data was normalized to ensure that the values fall between 0 and 1, which helps the model converge faster and improves accuracy during training.

  - **Adam Optimizer**: The model is trained using the Adam optimizer, with a learning rate of 0.005. Adam is well-suited for large datasets and adjusts the learning rate dynamically, leading to faster convergence.

  - **GridSearchCV**: I implemented hyperparameter tuning using GridSearchCV from scikit-learn, which allowed me to search for the best combination of hyperparameters such as the number of hidden layers, the number of neurons per layer, and batch normalization/dropout options. This optimization process helps in finding the model with the highest accuracy on the test set.

  - **Dropout and Batch Normalization**: The project includes options to add dropout layers and batch normalization to prevent overfitting and ensure that the model generalizes well to unseen data.

  - **Model Evaluation**: The model was evaluated using the test dataset after training. Accuracy and loss were calculated to assess the model’s performance, ensuring that it classifies the digits with high precision.

  - **Hyperparameter Tuning Results**: After running GridSearchCV, the best model was selected based on the highest accuracy score. The optimal hyperparameters, such as the number of hidden layers and neurons, were determined and applied to improve the model's performance.

  This project was a valuable exercise in neural network construction, model optimization, and hyperparameter tuning using scikit-learn. I learned a lot from NeuralNine's tutorial, and I deeply respect their commitment to delivering high-quality educational content.
* Day 191: 🚗 Vehicle Management System in Python 🚙
  Today, I developed a Vehicle Management System using Python, incorporating Object-Oriented Programming (OOP) principles such as inheritance, encapsulation, and abstraction. The project allows for the registration and management of different types of vehicles, such as Sports Cars, Minivans, and more. Below are the key highlights of the project:

  - **Encapsulation**: The `Vehicle` class encapsulates attributes like `make`, `model`, and `license_plate`, ensuring that sensitive information is protected by making them private. Controlled access is provided through getter methods, allowing secure data handling.

  - **Inheritance**: The system employs inheritance for different vehicle categories, such as `SportsCar` and `Minivan`, both derived from the base `Vehicle` class. This design allows for reusability of common attributes (like `make` and `model`) while providing specialized functionality for each subclass, enhancing flexibility and scalability.

  - **Abstraction**: The `Vehicle` class contains an abstract method `get_description`, which is implemented by each specific vehicle category. This ensures that every type of vehicle in the system has a tailored description, maintaining a consistent interface and making the code easily extensible.

  - **Category Management**: The system allows users to register vehicles in various categories (Sports Car, Minivan, etc.), record details such as mileage, owner information, and maintenance history, and retrieve comprehensive vehicle data. This feature-rich structure provides a realistic scenario for a vehicle management application.

  - **Data Handling**: The system tracks key details such as vehicle types, mileage, and ownership history. It also includes methods to retrieve and display this data in an organized manner, simulating a real-world vehicle management scenario.

  - **Menu Options**: A menu-driven interface facilitates interaction with the system, allowing users to register new vehicles, display vehicle details, and manage various aspects of each vehicle category. This makes the program user-friendly and practical for real-world applications.

  This project was an excellent exercise in applying OOP principles to create a structured and maintainable system. It provided a great opportunity to deepen my understanding of how abstraction, encapsulation, and inheritance can be effectively used to build a versatile and efficient vehicle management tool.


* Day 192: 💤💪 Health and Sleep Statistics [Kaggle](https://www.kaggle.com/datasets/hanaksoy/health-and-sleep-statistics/data) 

  * Today, I worked with the Health and Sleep Statistics dataset from Kaggle, focusing on data analysis and visualization. Below is a summary of the key activities and insights obtained:

    - **Data Loading**:
      - Imported the dataset using Pandas and conducted an initial examination to understand the data structure and key features.

    - **Data Cleaning**:
      - Checked for missing values and ensured the data's integrity.
      - Performed data type conversions, especially for dates and numerical fields, to prepare the data for analysis.

    - **Exploratory Data Analysis (EDA)**:
      - **Sleep and Health Analysis**:
        - Analyzed sleep patterns, including average sleep duration and sleep efficiency.
        - Created visualizations to explore relationships between sleep duration and factors like age, gender, and activity levels.
        - Investigated correlations between health metrics such as BMI, daily steps, and sleep quality.
      - **Physical Activity Insights**:
        - Visualized the distribution of daily steps, calories burned, and active minutes across different age groups and genders.
        - Explored the relationship between physical activity and sleep quality using scatter plots and heatmaps.
      - **General Health Metrics**:
        - Examined the distribution of BMI, resting heart rate, and other health indicators.
        - Generated insights into how these health metrics are influenced by sleep patterns and activity levels.

    - **Advanced Visualizations**:
      - Utilized Plotly to create interactive visualizations, such as:
        - **Heatmaps**: Showing correlations between sleep efficiency, activity levels, and health metrics.
        - **Line Graphs**: Illustrating trends in sleep duration and physical activity over time.
      - Developed sunburst plots and bar charts to provide deeper insights into health statistics across different demographics.

  * This analysis provided valuable insights into how sleep patterns and physical activity are connected to overall health. The visualizations revealed important trends and correlations that can be beneficial for individuals aiming to improve their health and sleep habits.
* Day 193: 🔍 Anagram Finder in Python 🧩 

  Today, I worked on an Anagram Finder project using Python. This program is designed to find all valid anagrams of a given set of letters based on a predefined dictionary, applying concepts of recursion and permutation generation. Below are the key highlights of the project:

  - **Dictionary Loading**: The program uses a text file `dictionary.txt` containing a list of valid words, which is loaded into a set. This enables fast lookup operations and ensures that only valid words are considered as anagrams.

  - **Permutation Generation**: By utilizing Python's `itertools.permutations` module, the program generates all possible permutations of the input letters, efficiently producing every combination without requiring manual iteration. This approach captures all potential anagram candidates in a compact manner.

  - **Anagram Validation**: Each generated permutation is checked against the loaded dictionary to determine if it forms a valid word. This step ensures that only meaningful words are included in the list of anagrams, filtering out nonsensical combinations.

  - **User Input and Output**: The system prompts the user to enter a set of letters and then displays all valid anagrams found in the dictionary. This interactive feature makes the program engaging and easy to use.

  - **Efficiency**: By using sets and efficient permutation generation, the program is optimized to handle larger sets of letters with minimal computational overhead, demonstrating the practical use of data structures and algorithm optimization.
  
  This project was an excellent opportunity to explore permutation generation and apply dictionary lookups efficiently. It provided valuable insights into handling recursive problems, optimizing data handling, and integrating external data into a Python program.
* Day 194: Technical Test "fullJustify" and "mySqrt" [LeetCode](https://leetcode.com/problems/)

  - **fullJustify**: Implemented a solution for the "Text Justification" problem, where the task is to format a list of words such that each line has exactly `maxWidth` characters and is fully justified. The solution packs words into lines using a greedy approach, ensuring that spaces are distributed as evenly as possible between words. For the last line, the text is left-justified, with any remaining spaces added to the end. The implementation efficiently handles the distribution of spaces, achieving the desired justification in O(n) time complexity, where n is the total number of words.
    [Problem Description: fullJustify](https://leetcode.com/problems/text-justification/description/)

  - **mySqrt**: Solved the "Sqrt(x)" problem, which involves finding the square root of a non-negative integer `x` rounded down to the nearest integer. The solution employs a binary search approach to efficiently calculate the integer square root without using built-in exponent functions or operators. The algorithm has a time complexity of O(log x), making it well-suited for handling large values of `x`.
    [Problem Description: mySqrt](https://leetcode.com/problems/sqrtx/description/)
* Day 195: 📊 Final Exam Score Calculator in Python 🎓 

  Today, I worked on a Final Exam Score Calculator using Python and Tkinter, with a strong emphasis on user interactivity, data validation, and GUI design principles. This project helps students calculate the required score for their final exam to pass their course, considering their current grades and weights. Here are the key highlights:

  - **User Interactivity**: The calculator provides an intuitive and dynamic interface for adding multiple scores and percentages. Users can easily input their grades and the corresponding weights, making the experience user-friendly and practical.

  - **Data Validation**: The system includes robust data validation to ensure that scores and percentages are within the allowed ranges (0.0 - 5.0 for scores and 0 - 100 for percentages). This ensures accurate calculations and prevents errors, with clear error messages guiding the user.

  - **Dynamic Entry Management**: The project allows users to add multiple input fields dynamically, making it adaptable for different scenarios. The entries can be reset at any time, allowing for multiple calculations without restarting the application.

  - **Progress Tracking**: A progress bar visually represents the total percentage of completed coursework, providing users with immediate feedback on how much weight they have already accumulated and how much is still required.

  - **Result Display**: The program calculates the score needed on the final exam and provides motivational feedback based on the result. This helps users understand their current standing and what they need to achieve to pass.

  - **Motivational Feedback**: The application offers encouraging messages based on the required final score, helping students stay motivated regardless of their current standing. This feature adds a personalized and supportive touch to the tool.

  This project was a fantastic opportunity to enhance my skills in GUI programming with Tkinter, focusing on data validation, dynamic UI updates, and user experience design. It demonstrates how practical applications can be created using Python to solve everyday problems, such as managing academic goals effectively.
* Day 196: 🧩 Sudoku Solver in Python 🔢 

  Today, I worked on a Sudoku Solver using Python, focusing on recursion and backtracking techniques. This project aimed to solve a 9x9 Sudoku puzzle while respecting the rules of the game. Below are the key highlights:

  - **Recursion**: The solution uses a recursive function to attempt filling the Sudoku grid cell by cell. If a valid number can be placed in a cell, the function proceeds to solve the rest of the grid recursively.

  - **Backtracking**: If a conflict arises or no valid number can be placed in a cell, the algorithm backtracks, resetting the cell and trying the next possible number. This systematic approach ensures that all possibilities are explored until the puzzle is solved.

  - **Sudoku Validation**: The solver includes a validation method that checks if placing a number in a specific row, column, or 3x3 grid adheres to the game's rules. This ensures that no invalid placements are made during the solving process.

  - **Grid Representation**: The Sudoku puzzle is represented as a 9x9 grid, where empty cells are denoted by `0`. The program attempts to fill these cells while respecting the constraints, ultimately arriving at a valid solution.

  - **Efficient Backtracking**: By using efficient backtracking, the solver quickly finds solutions to even the most complex puzzles. This process ensures that the program is both effective and optimized for speed.

  - **User Interface**: The project includes a simple function to display the Sudoku board before and after solving, making it easy to visualize the solution process.

  This project was a great opportunity to practice and apply recursion and backtracking, fundamental techniques for solving constraint satisfaction problems. It demonstrated how powerful these techniques can be when building a solution that explores possibilities efficiently. The project also reinforced the importance of validation checks to maintain the integrity of the solution, making it a valuable learning experience.
* Day 197: 🏀 Three-Point Shot Success Calculator in Flask 🎯 

  Today, I worked on a Three-Point Shot Success Calculator using Flask, focusing on creating a basic web application that calculates the success rate of three-point shots in basketball. This project allowed me to practice essential Flask concepts and build an interactive web-based calculator. Here are the key highlights:

  - **User Input Handling**: The web application allows users to input the number of attempted and successful three-point shots through a simple HTML form. This input is processed securely on the server side, ensuring accurate calculation of the success rate.

  - **Backend Calculation**: The application captures the data and performs a calculation to determine the percentage of successful three-point shots. This demonstrates how Python can be used on the backend to handle logic and return the result to the user.

  - **Session Management**: Implemented session management using `app.secret_key`, which ensures that user data remains secure during interactions with the web application. The secret key was generated using Python's `secrets` library, demonstrating the use of cryptographic methods for secure session handling.

  - **Flask Integration**: The project utilizes Flask's routing capabilities to handle different routes (`/` for the home page and `/calculate` for processing the calculation), showcasing how Flask can manage multiple endpoints in a web application.

  - **Error Handling**: Basic error handling is included to ensure that the program reacts appropriately to invalid or missing inputs, providing a smooth user experience.

  - **Interactive Feedback**: The calculated success rate is displayed back to the user in a user-friendly format, demonstrating how server-side calculations can be rendered on a web page.

  This project was an excellent opportunity to reinforce my understanding of how Flask can be used to build simple yet functional web applications. It helped me practice session management, user input handling, and backend calculations, all while applying them to a fun and practical example in the context of basketball statistics.
* Day 198: 🐾 Cats Dataset [Kaggle](https://www.kaggle.com/datasets/waqi786/cats-dataset/data) 

  Today, I worked on analyzing the Cats Dataset from Kaggle using Python. The focus was on data exploration and visualization using libraries such as Pandas, Seaborn, and Matplotlib. The project includes generating statistical summaries, visualizing distributions of numerical and categorical variables, and analyzing correlations between features. Below are the key highlights:

  - **Statistical Summary**: The project includes a function that generates a statistical summary of numerical variables, providing insights such as mean, median, and standard deviation. This helps in understanding the central tendency and spread of the data.

  - **Categorical Distribution**: I created a function to display the distribution of categorical variables, such as breed, color, and gender of the cats. This gives a clear view of how many instances exist for each category, aiding in categorical analysis.

  - **Numerical Distributions**: The code generates histograms for numerical variables, allowing for visual inspection of their distributions. This helps identify any skewness, outliers, or normality in the data.

  - **Bar Graphs for Categorical Variables**: I implemented bar graphs to visualize the distribution of each categorical variable. This enhances the ability to quickly grasp the frequency of categories visually.

  - **Correlation Analysis**: A correlation matrix is generated to analyze relationships between numerical variables. This provides insights into potential relationships that can be explored further, and is visualized with a heatmap for clarity.

  - **User-Friendly Functions**: The project includes functions for generating the full report, making it easy to run all analyses in one go. This modular approach enhances code readability and maintainability.

  This project was an excellent opportunity to deepen my understanding of data analysis techniques in Python, as well as to explore the Cats Dataset thoroughly. The experience reinforced the importance of visualizing data to extract meaningful insights and understand underlying patterns.


* Day 199: 📚 Book Subscription System in Python 📖

  Today, I developed a Book Subscription System using Python, focusing on the Model-View-Controller (MVC) architectural pattern along with Object-Oriented Programming (OOP) principles. The project allows readers to subscribe to different book genres, view reader details, and check the information of available books. Here are the key highlights of the project:

  - **Encapsulation**: The `Person` class, which serves as a base class for `Reader` and `Author`, encapsulates attributes such as `name` and `id_number`. These attributes are private and accessed via getter methods, ensuring data protection and controlled access.

  - **Inheritance**: The system demonstrates inheritance by having `Reader` and `Author` classes inherit from the `Person` abstract class. This allows for the reuse of common attributes like `name` and `id_number`, while enabling each subclass to extend with unique functionality, such as subscribing to genres or adding books.

  - **Abstraction**: The `Person` class features an abstract method `get_description`, which is implemented by both `Reader` and `Author` classes. This ensures a consistent interface across different types of persons in the system while allowing specific details to be tailored to each subclass.

  - **MVC Pattern**: The system is structured according to the MVC pattern:
    - **Model**: Represents the core data (Person, Reader, Author, and Book) and logic of the application.
    - **View**: Handles the display of information and interaction with the user.
    - **Controller**: Manages the communication between the Model and View, processing user input and updating the Model accordingly.

  - **Book Subscription Management**: Readers can subscribe to genres, and authors can add books to the system. The `Controller` class facilitates the logic to manage these interactions, providing a seamless experience for users to interact with the system.

  - **Book Details and Reader Information**: The project includes functionality to display detailed information about books and readers, helping users keep track of their subscriptions and explore different genres.

  - **User Interaction**: A menu-driven interface allows users to navigate the system, subscribe to genres, view reader details, and access book information, making it user-friendly and practical for real-world use.

  This project was a valuable experience in applying the MVC pattern along with OOP principles to build a well-structured and maintainable application. It provided a great opportunity to strengthen my understanding of encapsulation, inheritance, and abstraction while working with an architectural design that ensures a clean separation of concerns.
* Day 200: Technical Test "climbStairs" and "simplifyPath" [LeetCode](https://leetcode.com/problems/)
  
  - **climbStairs**: Implemented a solution for the "Climbing Stairs" problem, where the task is to determine the number of distinct ways to reach the top of a staircase with `n` steps, given that you can climb either 1 or 2 steps at a time. The solution employs a dynamic programming approach similar to the Fibonacci sequence to calculate the total number of ways to reach the top efficiently. The time complexity is O(n), where `n` represents the number of steps, as it iteratively calculates the possible ways without redundant computations.
    [Problem Description: climbStairs](https://leetcode.com/problems/climbing-stairs/)

  - **simplifyPath**: Solved the "Simplify Path" problem, which requires converting an absolute Unix-style file path into its canonical form. The approach utilizes a stack to process the path components, effectively handling elements like current (`.`), parent (`..`) directories, and redundant slashes (`//`). The final solution reconstructs the canonical path with a time complexity of O(n), where `n` is the length of the path, ensuring efficient processing of all path elements.
    [Problem Description: simplifyPath](https://leetcode.com/problems/simplify-path/description/)
* Day 201: 🌊 Count Islands in a Grid Using Recursion 🏝️ 

  Today, I worked on a project that counts the number of islands in a grid using Python, focusing on recursion and depth-first search (DFS). The main objective was to identify and count all distinct "islands" in a grid represented by `1`s (land) and `0`s (water). Below are the key highlights:

  - **Recursion**: The solution uses a recursive function to traverse the grid, identifying connected land cells (`1`s). For every unvisited land cell, the function explores all 8 possible directions (up, down, left, right, and the four diagonals) to mark the entire island as visited.

  - **Depth-First Search (DFS)**: By using a DFS approach, the algorithm ensures that every part of an island is explored fully before moving to the next. This allows the algorithm to handle islands of any shape or size, ensuring accurate counting.

  - **Grid Representation**: The grid is represented as a 2D list where `1`s denote land and `0`s represent water. The function recursively marks all connected `1`s as visited (changing them to `0`s), ensuring that each island is counted only once.

  - **Efficient Island Counting**: The project efficiently iterates through the grid, invoking the DFS function each time an unvisited `1` is found. This approach minimizes the number of recursive calls and ensures that all islands are correctly identified.

  - **Handling Edge Cases**: The algorithm effectively handles edge cases, such as single-cell islands or grids with no islands at all, making it robust for different input scenarios.

  - **Example Visualization**: The project includes an example grid and prints the total number of islands found, demonstrating the algorithm's effectiveness in various configurations.

  This project provided a valuable opportunity to apply recursion in a real-world scenario, reinforcing the importance of depth-first search for exploring connected components. It also showcased how recursive algorithms can be used to solve problems involving adjacency and connectivity in grids, which is a fundamental concept in graph theory.

* Day 202: 🃏 Flashcard Creator with Tkinter 🎓 

  Today, I worked on a **Flashcard Creator** using **Tkinter**, where users can create, edit, and review study flashcards, including an option for quizzes to track progress in learning different subjects. The project focuses on building an intuitive GUI for managing flashcards, and the code is designed with object-oriented principles in mind. Here are the main features:

  - **Flashcard Creation**: Users can create flashcards by entering a question or term (front) and its corresponding answer or definition (back). These flashcards are stored and can be navigated or edited as needed, offering flexibility for users to adapt to new topics or modify existing cards.

  - **Editing Flashcards**: The program allows users to edit the content of existing flashcards. This feature ensures that any mistakes or updates can be easily managed, without the need to recreate the flashcard.

  - **Flashcard Navigation**: A user-friendly interface provides navigation between flashcards with "Next" and "Previous" buttons, allowing users to browse through their entire set of cards effortlessly.

  - **Quiz Mode**: The application features a quiz mode where users can test their knowledge. The program randomly selects flashcards, prompting the user to provide the correct answer. After each attempt, feedback is provided (correct or incorrect), and a score is tracked throughout the quiz.

  - **Progress Tracking**: Once the quiz ends, users are presented with their final score, giving them an overview of how well they know the content. This is useful for self-assessment and tracking learning progress over time.

  - **Object-Oriented Design**: The project uses **classes** to represent both the individual flashcards and the flashcard manager, which handles operations like adding, editing, and navigating flashcards. This structure makes the code easy to maintain and extend in future iterations.

  - **User-Friendly Interface**: Built with Tkinter, the application features an intuitive and clean interface that is accessible to users with no prior programming experience. The GUI provides immediate feedback for user actions, making the learning process efficient.

  - **Practical Application**: This project is ideal for students, teachers, or anyone looking to reinforce their knowledge through flashcards. The flexibility of creating custom flashcards makes this tool applicable to various fields of study, from vocabulary building to technical subjects.

  This project was a great exercise in applying both GUI development and object-oriented programming in Python. It allowed me to refine my understanding of class-based structures while creating an educational tool that can easily be extended with additional features like progress charts or importing/exporting flashcards in the future.
* Day 203: ♟️ FEN Notation Converter for Chess in Python ♟️ 

  Today, I worked on a **FEN Notation Converter** project using Python, which allows converting between **Forsyth-Edwards Notation (FEN)** and a visual representation of a chessboard. This project was designed to help chess enthusiasts understand and visualize the FEN notation used in chess software to represent board positions. Below are the key highlights:

  - **FEN to Board Conversion**: The converter reads a FEN string (used to represent chess positions) and generates an 8x8 chessboard matrix. Each row and column is accurately translated to the corresponding chess pieces or empty squares.

  - **Board to FEN Conversion**: The program also allows reversing the process, taking a chessboard (represented as an 8x8 array) and converting it back into a valid FEN string. This was implemented by counting empty spaces and placing piece symbols according to FEN formatting rules.

  - **Visualization**: The board is printed in the console for a quick visual representation of the current chess position. This feature is useful for debugging or simply viewing the position described by the FEN string.

  - **Handling Edge Cases**: The project handles edge cases in FEN notation, such as positions with many empty squares or special symbols for castling rights, active color, and other fields.

  - **User-friendly Functions**: 
    - `fen_to_board(fen)`: Converts a FEN string into an 8x8 chessboard array.
    - `board_to_fen(board)`: Converts a chessboard array back into a FEN string.
    - `print_board(board)`: Prints the visual representation of the chessboard in the console.

  Working on this project gave me the opportunity to improve my skills in string manipulation and matrix operations in Python. Additionally, it deepened my understanding of how FEN notation works and how it can be utilized in chess software.
* Day 204: 🚗🔋 Electric Vehicle Charging Patterns Dataset [Kaggle](https://www.kaggle.com/datasets/valakhorasani/electric-vehicle-charging-patterns/data)

  Today, I focused on exploring the Electric Vehicle Charging Patterns Dataset from Kaggle. This dataset offers a comprehensive view of electric vehicle (EV) charging behaviors, capturing key metrics related to energy consumption, user patterns, and vehicle data. The project leverages Python for data analysis and visualization, employing libraries such as Pandas, Seaborn, Matplotlib, and Plotly. Below are the highlights of the day:

  - **Data Exploration**: The dataset contains various features such as user IDs, vehicle models, charging station IDs, and charging behaviors. The initial steps involved inspecting the data types, dimensions, and performing a basic statistical summary of the dataset. The dataset was then cleaned and missing values were addressed, ensuring reliable analysis.

  - **Feature Renaming**: I renamed the dataset's columns to remove spaces and special characters, simplifying further data handling. This step improves code readability and allows for easier manipulation of the dataset.

  - **Exploratory Data Analysis (EDA)**: Key insights were derived through visualizations of both categorical and numerical features:
    - **Count Plots**: Created for categorical features such as vehicle models, user types, charger types, and time of day to observe charging behavior trends.
    - **Distribution Plots**: Visualized numerical features like battery capacity, energy consumption, charging cost, and charging rate to understand their distributions and identify any skewness or outliers.
    - **Boxplots**: Used to detect outliers in numerical features and ensure that the data was well-prepared for further analysis.
    - **Correlation Heatmap**: Generated to analyze relationships between numerical features and identify any strong correlations that could be useful for predictive modeling.

  - **Clustering Analysis**: Applied **K-Means Clustering** to group similar charging patterns based on numeric features such as battery capacity, energy consumption, and charging rate. The results were visualized using **Principal Component Analysis (PCA)** to reduce dimensionality and display the clusters in a 2D space.

  - **Visualization with Annotations**: Created annotated plots, such as for charging cost, with clear labeling of key statistics like median values. These annotations enhanced the interpretability of the visualizations.

  This project was an excellent way to dive into real-world EV data, offering valuable insights into user behavior and charging patterns. The combination of statistical analysis and rich visualizations allowed for a deeper understanding of energy consumption trends and the factors influencing them.
* Day 205: 📚 Lesson Subscription and Management System in Python 🎓 

  Today, I completed a Lesson Subscription and Management System using Python, with a focus on the Model-View-Controller (MVC) architectural pattern and validation techniques. The project allows students to subscribe to lessons, and instructors to manage and teach these lessons, while ensuring proper input validation. Here are the key features and highlights:

  - **Input Validation**: To ensure data integrity, the system validates that names (for both students and instructors) contain only letters and spaces, preventing the entry of numbers or special characters. This enhances the quality of the data being processed.

  - **Model-View-Controller (MVC)**: The system is built around the MVC pattern, providing a clear separation of concerns:
    - **Model**: The `Person`, `Student`, and `Instructor` classes handle data-related logic. These models encapsulate attributes and implement behavior related to the core entities in the system.
    - **View**: The `View` class handles all user interactions, such as displaying menus, getting input, and showing results.
    - **Controller**: The `Controller` class acts as the intermediary, processing the user's input, updating models, and ensuring that the correct data is shown in the view.

  - **Encapsulation**: The `Person` class encapsulates sensitive attributes like `name` and `id_number`, providing controlled access through getter methods. This ensures that data is protected and follows proper OOP practices.

  - **Inheritance and Abstraction**: The `Student` and `Instructor` classes inherit from the `Person` abstract class, ensuring code reusability. The abstract method `get_description` is implemented by both classes to provide specific details for students and instructors.

  - **Lesson Management**: Instructors are responsible for managing lessons, and students can subscribe to those lessons. Each lesson is linked to an instructor, and students can view which lessons they are subscribed to.

  - **Instructor Lookup**: The system allows users to query which instructor is teaching a particular lesson. This feature makes it easier to organize lesson schedules and track instructor responsibilities.

  - **Error Handling**: The system includes robust error handling for invalid inputs (such as names containing numbers), providing meaningful feedback to users and ensuring smooth operation without crashes.

  - **Menu-Driven Interface**: A user-friendly, menu-driven interface allows for seamless interaction with the system. Users can subscribe students to lessons, view lesson details, and check which instructor is teaching a specific lesson.

  This project helped me deepen my understanding of the MVC architecture and how it can be applied to build modular and scalable software solutions. I also improved my input validation skills, ensuring that the system is reliable and handles edge cases effectively.
* Day 206: Technical Test "minDistance" and "setZeroes" [LeetCode](https://leetcode.com/problems/)

  - **minDistance**: Implemented a solution for the "Edit Distance" problem, where the goal is to transform one string into another using the minimum number of operations, such as inserting, deleting, or replacing characters. The solution uses dynamic programming to build a matrix that keeps track of the number of operations needed to transform substrings of `word1` into `word2`. The time complexity is O(m * n), where `m` and `n` are the lengths of the input strings. This approach ensures efficient calculation by avoiding redundant recalculations.
    [Problem Description: minDistance](https://leetcode.com/problems/edit-distance/description/)

  - **setZeroes**: Solved the "Set Matrix Zeroes" problem, which involves modifying a given matrix in-place such that if an element is 0, its entire row and column are set to 0. The solution utilizes the first row and the first column as markers to remember which rows and columns need to be zeroed. This method allows the problem to be solved in O(m * n) time complexity with O(1) additional space complexity, ensuring that the matrix is updated efficiently without using extra memory.
    [Problem Description: setZeroes](https://leetcode.com/problems/set-matrix-zeroes/description/)

* Day 207: 🎨 Painting Problem in Python 🌈

  Today, I worked on solving the "Painting Problem" using Python, focusing on recursion and backtracking techniques. The goal of the project was to color a grid of cells using a set of available colors, ensuring that no two adjacent cells share the same color. Here are the main highlights:

  - **Recursion**: The core of the solution revolves around a recursive function that attempts to color each cell of the grid. If a valid color is found for the current cell, the function recursively proceeds to the next cell. 

  - **Backtracking**: Whenever a conflict occurs, meaning no valid color can be placed in a specific cell without violating the adjacency constraint, the algorithm backtracks. It resets the current cell and tries the next available color, ensuring all possibilities are explored.

  - **Adjacency Validation**: A key part of the solution is the validation method, which ensures that no cell has the same color as its neighboring cells (top, bottom, left, and right). This check guarantees that all cells are colored according to the given rules.

  - **Grid Representation**: The grid is represented as a 2D list, and each cell is either colored with one of the available colors or left as `None` when uncolored. The recursive algorithm efficiently explores all possible configurations to find valid solutions.

  - **Exploring All Possibilities**: By using recursion and backtracking, the program explores every potential coloring configuration, printing each valid solution where no adjacent cells share the same color.

  - **Versatility**: The solution is flexible and works with any grid size and any number of available colors, making it adaptable for different problem instances.

  This project was an excellent way to deepen my understanding of how recursion and backtracking can be used to solve complex constraint satisfaction problems. It demonstrated the importance of validating constraints and systematically exploring all possible solutions while ensuring optimal performance.
* Day 208: ♟️ Chess Move Validator in Python ♟️ 

  Today, I worked on a **Chess Move Validator** program using Python, focusing on validating the legality of chess moves according to the rules of the game. The project supports different types of pieces, including special movements such as castling and en passant. Below are the key highlights:

  - **Chess Board Representation**: The chess board is represented as an 8x8 grid, with pieces initialized in their standard positions. The board uses a list of lists to manage the state of each square effectively.

  - **Move Validation**: The `is_move_legal` method validates moves for each type of piece, checking for:
    - **Pawns**: Standard moves, captures, and en passant.
    - **Rooks**: Straight line movements.
    - **Knights**: Unique L-shaped movements.
    - **Bishops**: Diagonal movements.
    - **Queens**: Combination of rook and bishop movements.
    - **Kings**: Single square movements and castling conditions.

  - **Error Handling**: The program provides feedback for illegal moves, detailing the specific reasons for each invalid action, such as moves that leave the player in check or moves that are not permissible for the specific piece type.

  - **Move Description**: When a legal move is identified, the program generates a descriptive output in chess notation style, detailing the piece's movement from the starting to the ending position.

  - **User Interaction**: The validator allows users to input moves in a tuple format, simulating the move's legality check. Additionally, the current state of the board is printed after each attempt to facilitate understanding of the game state.

  This project was a great exercise in applying programming principles to simulate the logic of chess movements, deepening my understanding of both the game itself and Python's capabilities. It was rewarding to build a tool that enhances engagement with chess by validating moves according to established rules.
* Day 209: 📱 Cellphone Inventory Management System in Python 📊 

  Today, I worked on a **Cellphone Inventory Management System** using Python, structured around the **Model-View-Controller (MVC)** design pattern. This project focused on managing an inventory of cellphone models, updating stock levels, and displaying the entire inventory. Below are the key highlights:

  - **Model**: The `Cellphone` class represents individual cellphone models with attributes like `model_name`, `brand`, and `stock`. The `Inventory` class manages a collection of these cellphones, allowing for searching and stock updates.

  - **View**: The `View` class handles user interactions, including displaying menu options, taking input for new cellphones, updating stock, and showing the current inventory. This separation allows for clear distinction between user interface logic and business logic.

  - **Controller**: The `Controller` class serves as the intermediary between the `Model` and `View`, processing user input from the `View`, manipulating the `Model`, and updating the user interface accordingly. This pattern enforces a clean, organized structure for managing data and logic separately.

  - **Add New Cellphones**: Users can input details like the model name, brand, and initial stock. These cellphones are then added to the inventory and stored for later access or updates.

  - **Update Stock**: The stock of any cellphone can be updated by searching for the model name and inputting the new stock level, ensuring that the inventory remains accurate.

  - **View Inventory**: The system allows users to view all cellphones currently in the inventory, displaying details such as model name, brand, and stock.

  - **User-Friendly Interface**: A menu-driven interface simplifies interactions, offering options to add new cellphones, update stock, view all cellphones, or exit the program. This intuitive design makes it easy to navigate and use.

  This project provided a solid understanding of how to apply the **MVC architecture** in Python, helping me to create a clean, maintainable, and scalable system. I particularly enjoyed the process of separating concerns between the model (data), view (user interface), and controller (logic), as this is a highly effective way to build software systems.
* Day 210: Technical Test "searchMatrix" and "sortColors" [LeetCode](https://leetcode.com/problems/)

  - **searchMatrix**: Implemented a solution for the "Search a 2D Matrix" problem. The matrix has rows sorted in non-decreasing order, and each row starts with a number greater than the last number of the previous row. The goal is to efficiently find if a target integer exists within the matrix. The solution uses binary search to achieve a time complexity of O(log(m * n)), where `m` is the number of rows and `n` is the number of columns, by treating the matrix as a flattened sorted array.
    [Problem Description: searchMatrix](https://leetcode.com/problems/search-a-2d-matrix/description/)

  - **sortColors**: Solved the "Sort Colors" problem using the Dutch National Flag algorithm. This problem asks to sort an array of integers where 0, 1, and 2 represent red, white, and blue colors respectively. The challenge was to sort the array in-place without using any built-in sort function. The approach uses three pointers (`low`, `high`, and `i`) to organize the array in one pass, achieving O(n) time complexity and O(1) space complexity.
    [Problem Description: sortColors](https://leetcode.com/problems/sort-colors/)
* Day 211: 🧩 Tiling Problem Solver in Python 🎲 

  Today, I worked on solving the classic **Tiling Problem** using a recursive approach in Python. The task was to count the total number of ways to tile a 2xN board using 2x1 tiles. This project helped strengthen my understanding of recursion and dynamic problem-solving. Below are the key highlights of the project:

  - **Recursion**: The problem was tackled using a recursive function that breaks the problem down into smaller subproblems. By reducing the size of the board step by step (either by placing a vertical tile or two horizontal tiles), the solution is built by combining these smaller problems. This demonstrates the power of recursion for solving complex tiling problems.

  - **Base Cases**: 
    - If the board has a length of `0`, there is exactly **one way** to tile it—by doing nothing.
    - If the board has a length of `1`, there is only **one possible tiling** (one vertical 2x1 tile).

  - **Recursive Case**: 
    - If you place a single vertical tile, you reduce the board to a size of 2x(N-1).
    - If you place two horizontal tiles, the board is reduced to 2x(N-2).
    - The total number of ways to tile a 2xN board is the sum of these two possibilities.

  - **Input Flexibility**: The user can input any board length (N) and get the total number of ways to tile it.

  - **Mathematical Insight**: This problem closely relates to the Fibonacci sequence. The number of ways to tile a 2xN board follows the same recurrence relation as Fibonacci numbers, with each solution building upon the previous ones.
* Day 212: 🎳 Bowling Scoreboard App in Python 🎯 

  Today, I worked on a **Bowling Scoreboard App** using **Python** and **Tkinter**, focusing on handling dynamic user input and maintaining a live scoreboard for multiple players. The project aimed to create an interactive user interface for entering scores, validating inputs, and automatically calculating bonuses like strikes and spares. Below are the key highlights:

  - **Dynamic Score Calculation**: The app allows multiple players to enter their scores for each frame. The total score is dynamically updated as players input their rolls, accounting for strikes and spares in the calculations. This ensures real-time feedback for users.

  - **Handling Strikes and Spares**: The project implements logic for handling bonuses from strikes (10 points plus the next two rolls) and spares (10 points plus the next roll). It ensures that incomplete frames don’t cause errors, as missing scores are handled gracefully.

  - **Tkinter GUI**: A user-friendly interface is built using Tkinter, where players' names can be added dynamically, and their frame-by-frame scores are input through entry fields. The app automatically moves the cursor to the next input field after each valid entry, improving the user experience.

  - **Validation of Inputs**: The app includes input validation to ensure that users only enter valid scores (0–10), and handles edge cases like strikes (10 pins on the first roll) by auto-filling the second roll with a 0. This keeps the score entry process smooth and error-free.

  - **Scoreboard Display**: Each player has their own row in the scoreboard with frames clearly displayed. The total score per frame is shown, updating immediately as users complete their rolls.

  - **Focus Management**: The app ensures the user interface is responsive by automatically shifting focus to the next input field after a roll, streamlining the data entry process for players.

  - **Real-Time Total Calculation**: For each player, the app calculates and displays the cumulative score after each frame, factoring in the correct bonus points for strikes and spares.

  This project was a great opportunity to apply my knowledge of **Tkinter** for building graphical user interfaces, as well as handling user inputs and calculations dynamically. It was challenging but rewarding to integrate real-time score updates and ensure that the app remained responsive, accurate, and easy to use throughout the game. I gained deeper insights into managing GUI-based applications with Python and learned how to ensure robust input validation and dynamic interaction.
* Day 213: 🛤️ Self-Avoiding Walk in Python 🚶‍♂️

  Today, I worked on a **Self-Avoiding Walk** simulation using Python, exploring the use of recursion and backtracking. The self-avoiding walk is a mathematical model that represents a path on a grid that never crosses itself. Below are the key highlights of the project:

  - **Recursion**: The solution is built using a recursive function that explores the grid step-by-step, attempting to find valid moves without revisiting any previously visited cells. The function continues to explore until either a full path is found or no valid moves remain.

  - **Backtracking**: If a path reaches a dead-end (i.e., no more valid moves), the algorithm backtracks by resetting the last visited cell to try a different direction. This ensures that all possibilities are explored.

  - **Grid Representation**: The grid is represented as an `n x n` matrix where each cell is either `True` (visited) or `False` (unvisited). The walk starts from the center of the grid, and the program attempts to navigate randomly without crossing the same path.

  - **Randomized Movement**: To simulate various outcomes, valid moves are shuffled randomly at each step. This randomness leads to different results on every execution of the walk.

  - **Termination and Success Check**: The walk can end in two ways: either it fills the entire grid successfully without crossing itself, or it fails due to lack of valid moves. A message indicating success or failure is displayed at the end.

  - **Practical Applications**: The self-avoiding walk has applications in areas such as combinatorics, physical simulations (like polymer chain modeling), and probability theory. It is an interesting problem that highlights the importance of recursion and efficient backtracking.

  This project provided valuable insight into recursive exploration and the challenges involved in simulating random processes on a grid.
* Day 214: Technical Test "minWindow" and "combine" [LeetCode](https://leetcode.com/problems/)

  - **minWindow**: Implemented a solution for the "Minimum Window Substring" problem, where the goal is to find the smallest substring in `s` that contains all characters in `t` (including duplicates). The solution uses the sliding window technique to dynamically adjust the window size while ensuring all characters in `t` are included. A dictionary is used to track the frequency of characters in the window, and a second dictionary ensures the frequency matches the required count for each character in `t`. This approach ensures an efficient solution with a time complexity of O(m + n), where `m` and `n` are the lengths of the strings `s` and `t`, respectively.
    [Problem Description: minWindow](https://leetcode.com/problems/minimum-window-substring/description/)

  - **combine**: Solved the "Combinations" problem, where the task is to generate all possible combinations of size `k` from a range of numbers from `1` to `n`. The solution utilizes backtracking to explore different combinations by recursively adding elements to a temporary list and backtracking when the combination size reaches `k`. This method efficiently generates all possible combinations, with a time complexity of O(C(n, k))—the number of ways to choose `k` elements from `n`.
    [Problem Description: combine](https://leetcode.com/problems/combinations/description/)
* Day 215: 🎳 Console-Based Bowling Game in Python 🕹️ 

  Today, I developed an interactive Bowling Game using Python, played entirely in the console. This project focuses on creating a simple yet fun bowling simulation using ASCII art to represent the pins and providing a real-time score after each roll. Below are the key highlights:

  - **ASCII Art**: The bowling pins are represented in the console using ASCII characters (`O` for standing pins and ` ` for knocked-down pins). The `display_pins` function visually organizes the pins in a triangular format, providing a clear representation of the current game state.

  - **Roll Simulation**: The game uses the `roll_ball` function to simulate each roll of the ball. This function randomly determines which pins are knocked down, simulating a real bowling experience where the outcome of each roll is unpredictable.

  - **Real-time Score Calculation**: After each roll, the `calculate_score` function counts the number of knocked-down pins, giving the player instant feedback on their performance. The total score is updated in real-time after each roll.

  - **Game Flow**: The game allows the player to take two rolls per frame. After the second roll, the player is given the option to either restart the game or exit. This makes the game easily replayable and provides a complete user experience.

  - **Reset and Exit Options**: After completing two rolls, players can choose whether to reset the game and try again or exit. This feature gives users flexibility in how long they wish to play.

  This project was a fun way to combine Python logic with interactive gameplay, using simple text-based output. It was also a great exercise in creating a user-friendly interface, even when working in a console environment. The real-time scoring and ability to reset or exit make this project engaging, and I look forward to building more games like this!
* Day 216: 📊 Leetcode Questions Dataset Analysis [Kaggle](https://www.kaggle.com/datasets/mohitkumar282/leetcode-questions-dataset/data)

  Today, I focused on exploring the Leetcode Questions Dataset from Kaggle. This dataset offers insights into various Leetcode questions, including their acceptance rates, difficulty levels, and whether they require a premium subscription. The project employs Python for data analysis and visualization, utilizing libraries such as Pandas, Seaborn, Matplotlib, and WordCloud. Below are the key highlights of today's analysis:

  - **Data Loading and Overview**:
    - Loaded the dataset and explored its structure, including the features: `Question_No`, `Question`, `Acceptance`, `isPremium`, `Difficulty`, `Question_Link`, and `Solution`.
    - Performed a brief inspection of data types and missing values to understand the initial data quality.

  - **Handling Missing Data**:
    - Verified the presence of any missing values across all features to determine if any data imputation was necessary.

  - **Exploratory Data Analysis (EDA)**:
    - Customized the figure settings for improved visualization aesthetics, including background color adjustments and font settings.
    - Created various plots to gain insights into the dataset:
      - **Count Plots**: Visualized distributions for categorical features such as `Difficulty` and `isPremium` to observe the balance of different categories.
      - **Histogram Plot**: Examined the distribution of `Difficulty` by `isPremium` status using a stacked histogram.
      - **Link Validity Check**: Verified the validity of `Question_Link` and `Solution` links, visualizing the proportion of valid and invalid links.
      - **Acceptance Rate Distribution**: Converted the `Acceptance` feature to a numerical format and analyzed its distribution.

  - **Data Cleaning and Feature Engineering**:
    - Removed special characters and converted the `Acceptance` rates from percentages to numerical values for consistency.
    - Ensured that the `Question_No` column had unique values to identify each question uniquely.

  - **Classification Model to Predict Difficulty**:
    - Encoded the `Difficulty` feature as numerical labels for machine learning purposes.
    - Trained a **Random Forest Classifier** using features such as `isPremium` and `Acceptance` to predict the difficulty level.
    - Evaluated the model's performance using **accuracy** and a **classification report**, providing insights into prediction quality.
    - **Feature Importance Analysis**: Visualized feature importances to understand which factors most influenced the difficulty predictions.

  - **Text Analysis and WordCloud**:
    - Generated a **WordCloud** from the question titles to visualize the most frequently used words.
    
  This project provided a practical approach to exploring and modeling data related to Leetcode questions, combining data cleaning, EDA, and machine learning for predictive analysis. The visualization efforts highlighted patterns in question difficulty, while the classification model demonstrated the feasibility of predicting difficulty levels based on specific features.
* Day 217: 🖼️ Art Store Management System in Python 🎨 

  Today, I worked on an Art Store Management System using Python, designed using the MVC (Model-View-Controller) architecture and Object-Oriented Programming (OOP) principles. The project allows users to manage an inventory of art pieces, including adding, viewing, and removing items. Below are the key highlights:

  - **Model-View-Controller (MVC) Architecture**: The system is divided into three main components:
    - **Model**: Responsible for representing the data and business logic, the `ArtPiece` class captures the attributes of each art piece, and the `Inventory` class manages the collection of art pieces.
    - **View**: Handles the user interface and interaction, allowing users to input and retrieve data. The `ArtStoreView` class displays options and receives inputs like new art piece details or the ID of a piece to be removed.
    - **Controller**: Acts as a bridge between the model and the view. The `ArtStoreController` class controls the flow of data between the inventory and the user interface, ensuring that actions like adding or removing art pieces are handled correctly.

  - **Object-Oriented Principles**: The system leverages OOP principles to ensure clarity, reusability, and modularity:
    - **Encapsulation**: Art piece details are stored and managed securely within the `ArtPiece` class, with clearly defined methods to add or remove pieces from the inventory.
    - **Abstraction**: The program abstracts the details of managing the inventory by providing clear interfaces through methods in the controller and model classes, hiding unnecessary complexity from the user.
    - **Modularity**: Each class has a single responsibility, allowing for easy extension of the system with new functionalities.

  - **Inventory Management**: Users can perform several actions related to the art pieces:
    - **View All Art Pieces**: Displays a list of all art pieces currently in the inventory.
    - **Add New Art Piece**: Allows users to input details for a new art piece, including title, artist, price, and stock.
    - **Remove Art Piece**: Provides the option to remove an art piece by its unique ID.

  - **Menu-Driven Interface**: The system offers a user-friendly menu that provides options for managing art pieces. Users can view all items, add new items, remove items, and exit the system, ensuring a smooth interaction experience.

  This project was an excellent exercise in applying the MVC pattern and solidifying my understanding of OOP principles such as encapsulation, abstraction, and modularity. By using this architecture, I was able to separate concerns effectively, creating a more maintainable and scalable system for managing an art store's inventory.
* Day 218: Technical Test "Subsets" and "WordSearch" [LeetCode](https://leetcode.com/problems/)

  - **Subsets**: Implemented a solution for the "Subsets" problem, where the task is to generate all possible subsets (the power set) from a given list of unique elements. The approach uses an iterative method that starts with an empty subset and adds new subsets by iterating through the input list. Each new element is added to all existing subsets to create new ones. The time complexity of the solution is O(2^n), where n is the number of elements in the input list.
    [Problem Description: Subsets](https://leetcode.com/problems/subsets/description/)

  - **WordSearch**: Solved the "Word Search" problem, which involves determining if a given word can be found in a 2D grid of characters. The word must be formed by letters of sequentially adjacent cells (horizontally or vertically), and each cell can only be used once in the path. The approach uses Depth-First Search (DFS) to explore all possible paths from each cell. The algorithm carefully marks cells as visited during the search to prevent reuse and restores them once the search backtracks. The solution runs with a time complexity of O(m * n * 4^L), where m and n are the dimensions of the grid and L is the length of the word.
    [Problem Description: WordSearch](https://leetcode.com/problems/word-search/description/)
* Day 219: 🎨 Tkinter Color Picker 

  Today, I worked on developing a **Color Picker** application using **Tkinter** in Python. This project is designed for designers and programmers, allowing them to select a color and instantly view its corresponding **Hexadecimal** and **RGB** values. Below are the key highlights of the project:

  - **Color Picker Functionality**: The core of the project is a color picker dialog that allows users to choose a color from a palette. The color is then displayed in a preview section, along with its Hex and RGB codes. This is useful for applications where precise color selection is required.

  - **Hexadecimal and RGB Display**: After selecting a color, the application automatically displays both the Hex code (e.g., `#FF5733`) and the RGB values (e.g., `(255, 87, 51)`), making it convenient to copy the values for further use in design or development work.

  - **Interactive User Interface**: The app provides an intuitive and simple UI, with a button to open the color picker and labels that update dynamically based on the selected color.

  - **Dynamic Background Update**: The background of the display section changes according to the selected color, providing a real-time preview of the chosen color.

  - **Code Modularity**: The code is modular and organized into functions, making it easy to understand, extend, and maintain. Each function serves a specific purpose, ensuring a clean and readable codebase.

  This project helped me further develop my skills in **Tkinter**, particularly in handling user inputs and updating the GUI dynamically based on interactions. It also reinforced the importance of designing simple and intuitive interfaces for utility-based applications.
* Day 220: 💰 Tip Calculator with Tkinter

  Today, I worked on developing a **Tip Calculator** using Tkinter in Python. This simple and interactive tool allows users to input their bill total and desired tip percentage, automatically calculating both the tip amount and the total amount to be paid. The project highlights the power of Tkinter for building user-friendly interfaces. Below are the key aspects:

  - **User Input for Bill Amount and Tip Percentage**: The program includes fields where users can enter the total bill amount and tip percentage. This makes it easy for users to quickly calculate tips based on their preferences.
  
  - **Tip Calculation**: A core function calculates the tip amount by multiplying the bill by the percentage input. This ensures an accurate calculation every time.

  - **Total Amount Display**: In addition to showing the tip amount, the program calculates and displays the total amount to be paid, including both the bill and the tip.

  - **Error Handling**: The program includes error handling to manage invalid inputs (e.g., non-numeric entries) using a simple error message dialog. This enhances user experience by preventing crashes.

  - **Clean User Interface**: Built with simplicity in mind, the interface is straightforward and easy to navigate, making it accessible for a wide range of users.

  This project allowed me to further improve my skills in creating real-world applications using **Tkinter** while emphasizing user interaction and error handling. It demonstrates how small, practical tools can enhance everyday tasks and offer convenience in situations like dining out or splitting bills.
* Day 221: 🌍 Choropleth Map Generator with Flask 🗺️ 

  Today, I worked on a project using Flask to create an interactive choropleth map generator where users can input country names and associated values. The application generates a choropleth map to visually represent the input data. Below are the key highlights:

  - **User-Friendly Interface**: The project provides a web interface using Flask, allowing users to easily input country names and corresponding values via a simple HTML form. This makes the process intuitive for any user, without the need for technical knowledge of how the data will be processed.

  - **Form Validation**: The system validates each country name using the `pycountry` library, ensuring that only valid country names are used in the map. If an invalid country is entered, the user is notified, and no map is generated until the input is corrected.

  - **Dynamic Choropleth Map**: The choropleth map is dynamically generated based on the valid country names and values provided by the user. The map uses Plotly for visualization and is displayed directly in the browser, making it easy to interpret and understand the data visually.

  - **Data Customization**: Users can associate specific numeric values with each country, allowing for the visualization of various metrics (e.g., population, economic data) through the choropleth map. The data is customizable and easy to extend for different use cases.

  - **Real-Time Feedback**: Once the form is submitted, the map is displayed directly on the same page using an embedded HTML frame, giving users immediate feedback on their input and the resulting map.

  - **Error Handling**: The project handles user input errors gracefully. If the user inputs an invalid country name or a non-numeric value, an error message is displayed on the page, guiding the user to correct their input.

  - **Tech Stack**: This project utilized Flask as the web framework, Plotly for creating the interactive maps, `pycountry` for validating country names, and Pandas for handling the data. The generated map is rendered using Plotly’s choropleth functionality and saved as an HTML file, which is then embedded into the webpage for visualization.

  This project allowed me to integrate web development with data visualization. It was a great opportunity to create an interactive, user-friendly tool while improving my Flask skills and working with Plotly for dynamic data representation. The combination of data validation and real-time visual feedback made this a practical and enjoyable project to build.
* Day 222: 💼 LevelUp Jobs - MVC Python Application 🖥️ 

  Today, I developed a job management system called **LevelUp Jobs** using Python with the **Model-View-Controller (MVC)** design pattern. The focus of the project was to create a system where users can register for job offers, and employers can post new job openings. Below are the key highlights of this project:

  - **Model-View-Controller (MVC)**: The application is structured using the MVC pattern, dividing the code into three interconnected components: 
    - **Model**: Handles the logic and data of the job offers and users.
    - **View**: Manages the interface and interaction with the user.
    - **Controller**: Bridges the model and view, handling user input and updating both the model and view accordingly.

  - **Job Registration**: Employers can input detailed job information, such as:
    - Job title
    - Company name
    - Salary (validated to ensure only numeric inputs)
    - Required experience (years)
    - Description and benefits
    - Work schedule
    - Job type (remote or on-site)

    Each job is automatically assigned a unique job ID to ensure easy tracking and management.

  - **User Validation**: The system performs validation checks on the user’s inputs:
    - Ensures that names do not contain numbers.
    - Ensures that the salary and phone numbers are valid numeric inputs.
    - Validates that remote options are entered as 'y' or 'n'.

  - **Edit and Remove Job Offers**: Employers can edit existing job offers by searching for a job via its ID. They can also remove job offers if needed. The system ensures that all input fields are validated during the edit process to prevent invalid data entry.

  - **Job Listings**: Users can view all available job offers, which are displayed in a clean and organized manner. The system shows details such as the job title, company, salary, required experience, and whether the job is remote or on-site.

  - **OOP Principles**: 
    - **Encapsulation**: Each model class encapsulates attributes and provides methods to access or modify these properties.
    - **Abstraction**: The job creation and management process is abstracted from the user, allowing for smooth interaction.
    - **Inheritance**: The system can be extended to allow different types of users, such as job seekers and employers.

  - **Menu-Driven Interface**: The application provides a simple menu for users to:
    1. View all job offers
    2. Add new job offers
    3. Edit existing job offers
    4. Remove job offers
    5. Exit the system
    
    This makes it easy to interact with the system and manage job offers efficiently.

  This project was an excellent opportunity to apply the MVC pattern in a practical scenario, allowing me to separate concerns between the model, view, and controller, making the code more modular and maintainable. Through this experience, I enhanced my skills in data validation, Python's OOP principles, and the development of user-friendly applications.
* Day 223: Technical Test "removeDuplicatesII" and "searchII" [LeetCode](https://leetcode.com/problems/)

  - **removeDuplicatesII**: Implemented a solution for the "Remove Duplicates from Sorted Array II" problem, where the task is to modify a sorted array such that each unique element appears at most twice. The solution uses two pointers to track the position of the current element and to overwrite duplicates beyond the second occurrence. The algorithm processes the array in-place with O(1) extra space. The time complexity is O(n), where n is the number of elements in the array.
    [Problem Description: removeDuplicatesII](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/)

  - **searchII**: Solved the "Search in Rotated Sorted Array II" problem, which requires determining whether a target value exists in a rotated sorted array, where the array may contain duplicates. The solution uses a modified binary search to handle the rotation and duplicates efficiently, adjusting the search space based on the sorted half of the array. In the worst case (due to duplicates), the time complexity is O(n), but on average, it runs in O(log n).
    [Problem Description: SearchII](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description/)
* Day 224: 💵 Recursive Investment Growth Calculator in Python 📈

  Today, I developed a Recursive Investment Growth Calculator in Python to project the future value of an investment in USD based on compound interest. The project demonstrates recursion by calculating the year-over-year growth of an investment, with a focus on breaking down the compound interest formula into recursive function calls. Key features and highlights of the project are outlined below:

  - **Recursion for Compound Interest**: The core of the project is a recursive function, `compound_interest_recursive`, that calculates the compounded investment amount by repeatedly applying the interest rate over the specified years. This function takes the principal, annual interest rate, and remaining years as inputs, stopping once all years have been processed.

  - **Investment Report**: Using the `investment_growth_report` function, the program generates a report that displays the balance at the end of each year, allowing the user to observe the compounding effect of the investment over time. This report is easy to read and provides a year-by-year breakdown of the investment's growth.

  - **User-Friendly Output**: Each year’s projected balance is displayed with a simple and clear format, helping users understand the impact of compounding interest and how investments grow over time. 

  - **Practical Financial Application**: This project showcases how recursion can be applied to financial calculations, especially for simulating the growth of investments. It serves as a basic model that can be expanded with additional features, such as varying interest rates or different compounding frequencies (e.g., monthly, quarterly).

  - **Python Basics in Finance**: This project is not only a good example of recursion but also introduces fundamental financial concepts like compound interest, making it accessible for those interested in combining Python programming with finance.

  This Recursive Investment Growth Calculator was a valuable project to deepen my understanding of recursion and how it can simplify complex calculations like compound interest. It also served as a practical demonstration of how Python can be applied to model real-world financial scenarios, making it a useful tool for anyone interested in finance and programming.
* Day 225: 🌳 Company Organizational Structure Tree in Python 📊 

  Today, I developed a Company Organizational Structure Tree in Python to model and explore hierarchical relationships within an organization. This project utilizes a binary tree structure to represent positions, with each node holding a company role, enabling traversal and understanding of the company's structure. The tree allows for traversal using **pre-order**, **in-order**, and **post-order** methods, providing insights into managerial hierarchies, employee details, and team structures. Below are the main highlights of the project:

  - **Binary Tree Structure**: The company’s organizational structure is represented as a binary tree, where each node corresponds to a company role, with left and right children representing subordinate relationships.

  - **Pre-order Traversal (Management Hierarchy)**: The pre-order traversal visits the nodes in top-down management order, which is helpful for understanding the hierarchy from executives to individual team members.

  - **In-order Traversal (Detailed Structure)**: The in-order traversal lists the structure left-to-right, which can help identify team structures in a balanced manner, making it ideal for reviewing employee details by levels.

  - **Post-order Traversal (Team Completion)**: The post-order traversal processes each team before its respective manager, which is useful for ensuring all sub-levels are accounted for before each managerial level.

  - **Encapsulation**: Each node contains `position` and `name` attributes, encapsulated within the `TreeNode` class. This structure ensures a clear distinction between the nodes, making it easier to extend the tree with additional attributes if needed.

  - **Methodical Structure**: The `OrgStructureTree` class includes traversal methods, making it easy to manage and interact with the tree structure. This design promotes modularity and maintainability, allowing for flexible additions to the tree structure or traversal methods in the future.

  This project provided valuable experience in structuring and traversing hierarchical data, showcasing how binary trees can be adapted to real-world scenarios. The traversal methods add flexibility, making it straightforward to analyze the company hierarchy from different perspectives.
* Day 226: 📱 Mobile Device Usage and User Behavior Dataset 📱 [Kaggle](https://www.kaggle.com/datasets/valakhorasani/mobile-device-usage-and-user-behavior-dataset/data)

  Today, I focused on analyzing the Mobile Device Usage and User Behavior Dataset from Kaggle using Python. The project emphasized data exploration and visualization through libraries such as Pandas, Seaborn, and Matplotlib. Below are the key highlights:

  - **Data Overview**: The dataset includes attributes such as User ID, Device Model, Operating System, App Usage Time, Screen On Time, Battery Drain, Number of Apps Installed, Data Usage, Age, Gender, and User Behavior Class. Each attribute plays a crucial role in understanding user behavior.

  - **Handling Missing Data**: A thorough check for missing values was performed to ensure data integrity before proceeding with analysis.

  - **Exploratory Data Analysis (EDA)**: Various visualizations were created to explore relationships among features. This included:
    - **Count Plots**: Displaying the distribution of categorical features like Operating System and Gender.
    - **Distribution Plots**: Analyzing numeric variables such as App Usage Time and Battery Drain to identify patterns.
    - **Correlation Heatmap**: Visualizing correlations among numeric variables to understand relationships.

  - **Modeling for Classification**: I implemented several classification algorithms (Logistic Regression, Random Forest, Gradient Boosting, SVC, XGBoost, K-Nearest Neighbors) to predict user behavior classes based on device usage patterns. Performance metrics such as accuracy and confusion matrices were generated for each model.

  - **Prediction of Battery Drain**: Regression models (Linear Regression, Random Forest Regressor, Gradient Boosting Regressor, XGBoost Regressor) were trained to predict battery drain based on user behavior data. Evaluation metrics like Mean Squared Error and R² Score provided insights into model performance.

  - **Visualization Techniques**: Advanced visualizations such as pair plots and joint plots were utilized to identify potential relationships among variables. These visualizations help in understanding the complex interactions within the dataset.

  This project offered a valuable opportunity to enhance my skills in data analysis and visualization techniques in Python while providing insights into mobile device usage patterns. The experience underscored the significance of exploratory analysis in uncovering meaningful trends and relationships within data.
* Day 227: 🍏 Food Inventory Management System in Python 🥦

  Today, I developed a Food Inventory Management System using Python, focusing on Object-Oriented Programming (OOP) principles. This project allows users to manage food items, track their expiration dates, and maintain an inventory history. Below are the key highlights:

  - **Encapsulation**: The `FoodItem` class encapsulates attributes such as `name`, `category`, `quantity`, `price`, and `expiration_date`. This ensures that the data is protected and can only be manipulated through defined methods.

  - **Inventory Management**: Users can add and remove food items from the inventory. The system keeps track of each action in an inventory history log, allowing users to see what changes have been made over time.

  - **Expiration Tracking**: The system checks for items that are near expiration (within 7 days) and provides a method to view these items. This feature helps users manage their inventory effectively and reduce food waste.

  - **Data Import/Export**: Users can import food item data from a CSV file and export the current inventory to a CSV file. This functionality makes it easy to manage large datasets and integrate with other systems.

  - **Search Functionality**: The system allows users to search for food items by name and category. This makes it easy to find specific items in a potentially large inventory.

  - **User-Friendly Interface**: A menu-driven interface guides users through the various functionalities of the system, making it intuitive and easy to use for anyone managing food inventory.

  This project was an excellent opportunity to apply OOP principles in creating a structured and maintainable system. I enhanced my understanding of how encapsulation, inheritance, and abstraction work together to produce clean, reusable code while building a practical tool for food inventory management.
* Day 228: Technical Test "deleteDuplicates" and "deleteDuplicatesll" [LeetCode](https://leetcode.com/problems/)

  - **deleteDuplicates**: Implemented a solution for the "Remove Duplicates from Sorted Array II" problem, which involves modifying a sorted array in place to remove duplicates such that each element appears at most twice. The approach uses a two-pointer technique to efficiently traverse the array and manage the count of duplicates, ensuring that the final array maintains the required order. The time complexity is O(n), where n is the number of elements in the array.
    [Problem Description: deleteDuplicates](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/)

  - **deleteDuplicatesll**: Developed a solution for the "Remove Duplicates from Sorted List" problem, which requires removing all duplicates from a sorted linked list. The solution involves traversing the linked list while checking for duplicate values and adjusting the pointers accordingly to skip over any duplicate nodes. This ensures that only unique values remain in the list. The time complexity is O(n), where n is the number of nodes in the linked list.
    [Problem Description: deleteDuplicatesll](https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/)
* Day 229: ⏳ Recursive Countdown Timer in Python ⏲️

  Today, I developed a **Recursive Countdown Timer** using Python, which demonstrates the power of recursion in programming. This timer counts down from a specified number of minutes and seconds, providing real-time updates on the remaining time. Below are the key highlights of this project:

  - **Recursion**: The core functionality of the timer is implemented using a recursive function `recursive_timer`. This function calls itself with updated time values until the countdown reaches zero, showcasing how recursion can simplify complex repetitive tasks.

  - **Time Formatting**: The timer displays the remaining time in a user-friendly format (MM:SS), ensuring that users can easily read the countdown. The use of formatted strings enhances clarity and presentation.

  - **Real-Time Simulation**: To simulate real-time countdown, the program uses `time.sleep(1)`, which pauses execution for one second between updates. This feature provides an accurate representation of the passage of time during the countdown.

  - **Base Case Handling**: The implementation includes a well-defined base case that checks if both minutes and seconds have reached zero. When this condition is met, it prints "Time's up!" and terminates the recursion, demonstrating effective control flow.

  - **Example Usage**: The timer can be initiated with any starting time, as shown in the example usage comment. For instance, calling `recursive_timer(0, 10)` starts a countdown from 10 seconds, allowing for easy testing and demonstration of functionality.

  This project was an excellent exercise in understanding recursion and its practical applications in creating a simple yet effective countdown timer. It reinforced my knowledge of Python programming concepts while providing a useful tool for timing applications.
* Day 230: 🎃 Jack-o'-Lantern in Python with Turtle Graphics 🎨

  Today, I created a fun Halloween-themed drawing of a Jack-o'-Lantern using Python's Turtle graphics library. This project allowed me to explore basic graphics programming while enhancing my understanding of functions and object-oriented principles in Python. Below are the key highlights of the project:

  - **Turtle Graphics**: Utilized the Turtle module to create graphical representations, focusing on shapes and colors that reflect a Halloween theme. The drawing includes features like eyes, a nose, a mouth, and a stem, all designed to resemble a classic Jack-o'-Lantern.

  - **Functionality**: The program is structured around several functions:
    - `drawcircle(x, y)`: Draws filled circles representing the eyes of the pumpkin.
    - `triangle(x, y)`: Draws triangles for the pupils and nose.
    - `mouth()`: Creates a spooky mouth with a unique shape.
    - `stem()`: Draws the pumpkin's stem with an organic shape.

  - **Customizable Aesthetics**: The colors used in the drawing are carefully chosen to enhance the Halloween spirit:
    - Orange for the pumpkin body.
    - Red for the pupils.
    - Yellow for the mouth.
    - Dark green for the stem.

  - **Message Display**: Added a function to display a festive message: "Happy Halloween, October 31, 2024," below the drawing. This enhances user engagement and adds to the overall theme of the project.

  - **User Interaction**: The program runs in a window that remains open until closed by the user, allowing them to enjoy the completed artwork.

  This project was an enjoyable way to combine creativity with programming. It provided an opportunity to practice using functions effectively and understand how to manipulate graphical elements in Python. Overall, it was a delightful exercise in creating something visually appealing while celebrating Halloween!
* Day 231: 🔐 Password Manager in Python 🛡️

  Today, I developed a Password Manager application using Python and Tkinter, focusing on secure password storage and management. The project allows users to store, generate, and view passwords for various accounts while ensuring data security through encryption. Below are the key highlights:

  - **User Interface**: The application features a user-friendly interface built with Tkinter, providing input fields for the site name, username, and password. The dark-themed background enhances usability and reduces eye strain.

  - **Password Generation**: Users can generate strong, random passwords with a single click. The generated password is automatically inserted into the password field, ensuring that users can easily copy or modify it before saving.

  - **Data Encryption**: The application employs the `cryptography` library to encrypt passwords before storing them in a text file. This ensures that sensitive information remains secure and protected from unauthorized access.

  - **Saving Entries**: Users can save their passwords along with associated site names and usernames. The application appends new entries to a text file (`passwords.txt`), making it easy to manage multiple accounts.

  - **Viewing Saved Passwords**: A feature allows users to view all saved passwords in a secure manner. When requested, the application reads the stored entries, decrypts the passwords, and displays them in a message box for easy reference.

  - **Error Handling**: Basic error handling is implemented to manage potential issues when reading from or writing to the file. This ensures that users receive informative feedback if something goes wrong.

  - **Future Enhancements**: This project lays the groundwork for future enhancements such as editing or deleting saved entries, implementing user authentication, and transitioning to a more robust database solution for storing credentials.

  This project was an excellent opportunity to apply my knowledge of Python and Tkinter while focusing on security best practices. It reinforced my understanding of encryption techniques and how to create intuitive user interfaces, all while building a practical tool for managing passwords securely.
* Day 232: 🎮 Pong Game in Python with Kivy 🕹️

  Today, I developed a simple Pong game using Python and the Kivy framework. This project focuses on creating an interactive game that allows two players to control paddles and compete against each other. Below are the key highlights:

  - **Game Structure**: The game consists of three main classes: `PongPaddle`, `PongBall`, and `PongGame`. Each class is responsible for specific functionalities, promoting a clear separation of concerns.

  - **Paddle Mechanics**: The `PongPaddle` class handles the player paddles, including scoring and bouncing the ball. The `bounce_ball` method detects collisions with the ball and adjusts its velocity based on where it hits the paddle, adding a dynamic element to gameplay.

  - **Ball Movement**: The `PongBall` class manages the ball's position and velocity. The `move` method updates the ball's position based on its current velocity, allowing it to travel across the screen.

  - **Game Logic**: The `PongGame` class orchestrates the overall game flow. It includes methods for serving the ball, updating positions, handling collisions with paddles and screen boundaries, and scoring points when the ball goes off-screen.

  - **User Interaction**: Player controls are implemented through touch events. The `on_touch_move` method allows players to move their paddles vertically by dragging their fingers across the screen, providing an intuitive control scheme.

  - **Real-time Updates**: The game runs at 60 frames per second using Kivy's clock scheduling. This ensures smooth animations and responsive gameplay, enhancing the user experience.

  - **Scoring System**: Each player has a score tracked by the `score` property in the `PongPaddle` class. When a player fails to intercept the ball, their opponent scores a point, and the game resets with a new serve.

  This project was an enjoyable exercise in game development using Kivy. It provided valuable insights into handling user inputs, managing object interactions, and implementing real-time updates in a graphical environment. I gained practical experience in structuring a game application while enhancing my programming skills in Python.
* Day 233: 🍬 Candy Inventory Management System in Python 🍭

  Today, I developed a Candy Inventory Management System using Python, focusing on Object-Oriented Programming (OOP) principles. This project allows users to manage their candy inventory by adding, removing, and displaying candy types and quantities. Below are the key highlights:

  - **Class Structure**: The `CandyInventory` class serves as the main structure for managing the candy inventory. It utilizes a dictionary to store different types of candies along with their quantities, ensuring efficient data management.

  - **Adding Candies**: The `add_candy` method allows users to add a specified quantity of a given type of candy. It includes validation to ensure that the quantity is greater than zero and updates the inventory accordingly.

  - **Removing Candies**: The `remove_candy` method implements a recursive approach to check if there are enough candies available for removal. If the quantity reaches zero after removal, the candy type is deleted from the inventory, maintaining a clean and accurate record.

  - **Displaying Inventory**: The `display_inventory` method provides a user-friendly way to view all candies currently in stock. If the inventory is empty, it informs the user, enhancing usability.

  - **Error Handling**: The system includes error handling for various scenarios, such as attempting to remove more candies than are available or adding an invalid quantity. This ensures robustness and improves user experience.

  - **User Interaction**: The program can be run as a standalone script, allowing users to interact with the candy inventory through simple method calls. This makes it easy to test and extend with additional features in the future.

  This project was an enjoyable exercise in applying OOP principles to create a functional and maintainable system. It provided me with valuable experience in managing data structures and implementing recursive logic in Python while building a practical tool for candy inventory management.
* Day 234: Technical Test "largestRectangleArea" and "maximalRectangle" [LeetCode](https://leetcode.com/problems/)

  - **largestRectangleArea**: Implemented a solution for the "Largest Rectangle in Histogram" problem, which involves finding the area of the largest rectangle that can be formed within a histogram represented by an array of heights. The solution utilizes a stack-based approach to efficiently compute the maximum rectangular area by iterating through each bar in the histogram and calculating possible rectangle areas based on bar heights. The time complexity is \(O(n)\), where \(n\) is the number of bars in the histogram.
    [Problem Description: largestRectangleArea](https://leetcode.com/problems/largest-rectangle-in-histogram/description/)

  - **maximalRectangle**: Solved the "Maximal Rectangle" problem, which finds the largest rectangle consisting of only `1`s in a binary matrix. By treating each row of the matrix as the base of a histogram, the solution calculates the maximum area of rectangles row by row, using the `largestRectangleArea` function for each updated histogram height array. The approach ensures efficient processing with a time complexity of \(O(rows \times cols)\), where `rows` and `cols` are the dimensions of the matrix.
    [Problem Description: maximalRectangle](https://leetcode.com/problems/maximal-rectangle/description/)
* Day 235: 🏠 Rent Houses Management System in Python 🏡

  Today, I developed a Rent Houses Management System using Python, employing the Model-View-Controller (MVC) architectural pattern. This project allows users to manage rental properties, including adding new houses, viewing available houses, and removing houses from the list. Below are the key highlights:

  - **Model-View-Controller (MVC) Structure**: The application is organized into three distinct components:
    - **Model**: Manages the data and business logic related to houses. The `HouseModel` class handles operations like adding, removing, and retrieving house listings.
    - **View**: Responsible for user interaction. The `HouseView` class provides a menu-driven interface for users to interact with the system and validates user input.
    - **Controller**: Acts as an intermediary between the model and view. The `HouseController` class orchestrates user actions and updates the model accordingly.

  - **Data Management**: The `House` class encapsulates attributes such as ID, address, rent amount, number of bedrooms and bathrooms, and availability status. This structure allows for easy management of rental properties.

  - **User Interaction**: A simple text-based menu allows users to choose from various options, including viewing all houses, adding new houses, or removing existing ones. Input validation ensures that data entered by users is accurate and consistent.

  - **Dynamic ID Assignment**: Each house is assigned a unique ID upon creation, which simplifies the process of managing listings and ensures that each property can be easily referenced.

  - **Error Handling**: The application includes robust error handling to manage invalid inputs gracefully. Users receive clear feedback when they make mistakes, enhancing the overall user experience.

  - **Extensibility**: The modular design of the application makes it easy to extend functionality in the future. Additional features such as searching for houses based on criteria or integrating a database can be implemented without significant restructuring.

  This project was an excellent opportunity to deepen my understanding of MVC architecture in Python while creating a practical tool for managing rental properties. It reinforced my skills in structuring code for maintainability and usability while providing a functional application that could be further developed.
* Day 236: 🥗 Total Daily Energy Expenditure (TDEE) Calculator in Python ⚖️

  Today, I developed a Total Daily Energy Expenditure (TDEE) Calculator using Python, which incorporates fundamental programming concepts such as functions, recursion, and data handling. This project calculates the TDEE based on individual health metrics and activity levels, providing valuable insights into daily caloric needs. Below are the key highlights:

  - **Basal Metabolic Rate (BMR) Calculation**: The project implements the Harris-Benedict equation to calculate BMR based on weight, height, age, and gender. This foundational metric is crucial for understanding an individual's caloric needs at rest.

  - **Activity Level Integration**: The TDEE is calculated by multiplying the BMR by an activity factor that corresponds to different levels of physical activity (sedentary, light, moderate, active, very active). This allows for a more personalized assessment of daily energy expenditure.

  - **Recursive Data Processing**: A recursive function processes a list of individuals' health data to calculate both BMR and TDEE. This approach demonstrates how recursion can simplify repetitive tasks and enhance code readability.

  - **Sample Data Handling**: The program includes sample data representing various individuals with different weights, heights, ages, genders, and activity levels. This showcases the calculator's versatility and ability to handle diverse inputs.

  - **Results Presentation**: The final output clearly displays each individual's weight, height, age, gender, BMR, and TDEE in a user-friendly format. This enhances the usability of the program and makes it easy to interpret results.

  - **Health Insights**: By calculating TDEE, users can gain insights into their caloric needs for weight maintenance or adjustment. This project serves as a practical tool for individuals looking to manage their health and fitness goals effectively.

  This project was an excellent opportunity to apply programming concepts in a meaningful way while contributing to health awareness. It reinforced my understanding of how functions and recursion can be utilized to create efficient and organized code for real-world applications.
* Day 237: 📝 Word Counter Application in Python 🖥️

  Today, I developed a Word Counter application using Python's Tkinter library. The application allows users to input text and provides a count of both words and characters, all within a user-friendly graphical interface. Below are the key features and highlights of the project:

  - **User Interface**: The application features a clean and intuitive GUI, built using Tkinter. Users can easily enter their text in a multi-line text box and see the results displayed in real-time.

  - **Word and Character Count**: The core functionality includes counting the number of words and characters in the input text. Users can click a button to trigger the counting process, which updates the displayed counts dynamically.

  - **Dark Theme**: To enhance user experience, the application is designed with a dark theme. The background color is set to a dark shade, with contrasting text colors for better visibility, making it easier for users to read their input.

  - **Clear Functionality**: A "Clear Text" button allows users to quickly reset the text box and clear the counts, providing a seamless experience for repeated use.

  - **Responsive Design**: The layout is designed to be responsive, ensuring that it looks good on various screen sizes while maintaining usability.

  - **Code Structure**: The code is structured for readability and maintainability. Functions are clearly defined for counting words, clearing text, and updating the user interface, making it easy to extend or modify in the future.

  This project was a great opportunity to practice GUI development in Python and enhance my skills with Tkinter. It reinforced my understanding of event-driven programming and how to create interactive applications that are both functional and visually appealing. I look forward to exploring more complex GUI applications in future projects!
* Day 238: 📚 Data Structure Management System in Python 📊

  Today, I developed a Data Structure Management System in Python, focusing on implementing a stack and a singly linked list. This project allows users to manage player data effectively through a menu-driven interface. Below are the key highlights:

  - **Singly Linked List**: The system utilizes a singly linked list to store player names. Each player is represented as a node, allowing for efficient insertion and traversal. This structure demonstrates how linked lists can dynamically manage collections of data.

  - **Stack Implementation**: A stack (Last In, First Out - LIFO) is implemented to manage player names. Users can push player names onto the stack and pop them off, showcasing basic stack operations such as `push`, `pop`, and `peek`. This illustrates the utility of stacks in managing data in a controlled manner.

  - **Menu-Driven Interface**: The program features a user-friendly menu that allows users to add players to the linked list, display players, and manage them using stack operations. This interactive approach enhances user experience and makes the system intuitive to navigate.

  - **Data Management Operations**: Users can perform various operations:
    - Add new players to the linked list.
    - Display all players currently stored in the list.
    - Push players onto the stack for temporary storage.
    - Pop players from the stack and view the top player without removing it.

  - **Error Handling**: The system includes basic error handling for invalid menu selections and empty stack scenarios, ensuring robustness and reliability during operation.

  - **Code Structure**: The code is organized into classes (`Node`, `SinglyLinkedList`, and `Stack`), promoting modularity and reusability. Each class encapsulates specific functionalities, making it easier to maintain and extend in the future.

  This project was an enriching experience that deepened my understanding of fundamental data structures in Python. It provided practical insights into how stacks and linked lists operate, along with the importance of user interaction through menu systems. Overall, this exercise enhanced my coding skills while building a functional data management tool.
* Day 239: 🏀 Basketball Team Manager in Python 🏆

  Today, I developed a Basketball Team Manager using Python, focusing on Object-Oriented Programming (OOP) principles. This project allows users to manage a basketball team by adding players, tracking their statistics, and calculating the team's average points scored. Below are the key highlights:

  - **Encapsulation**: The `Player` class encapsulates attributes like `name`, `position`, and `points`. This ensures that player statistics are managed internally while providing methods to interact with these attributes, such as scoring points and retrieving stats.

  - **Team Management**: The `Team` class manages a roster of players. It includes methods for adding players, displaying their statistics, and calculating average points scored by the team. This structure allows for easy updates and maintenance of player data.

  - **Scoring System**: Players can score points through the `score_points` method, which updates their total points. This feature simulates real-game scenarios where players contribute to the team's score.

  - **Average Points Calculation**: The program calculates the average points scored by all players in the team, providing insights into team performance. This functionality can be useful for coaches and managers when evaluating player contributions.

  - **User Interaction**: The `main` function serves as the entry point for the program, creating a user-friendly experience by allowing easy additions of players and displaying their statistics in a clear format.

  - **Future Enhancements**: This project lays a solid foundation for future enhancements, such as adding more player statistics (rebounds, assists), implementing game simulations, or incorporating a user interface for better interaction.

  This project was an excellent opportunity to apply OOP principles in a practical context. I refined my understanding of encapsulation and class interactions while building a useful tool for basketball team management. I'm excited about the potential to expand this project further and explore more complex functionalities!
* Day 240: Technical Test "partitionList" and "isScramble" [LeetCode](https://leetcode.com/problems/)

  - **partitionList**: Developed a solution for the "Partition List" problem, where the objective is to reorder a linked list based on a given integer `x`. All nodes with values less than `x` are moved to the left of nodes with values greater than or equal to `x`, while preserving their original relative order. This is achieved by using two dummy nodes to create two partitions ("less than `x`" and "greater than or equal to `x`"), which are later connected. The final solution has a time complexity of O(n), where `n` is the length of the linked list, as it iterates through the list once.
    [Problem Description: partitionList](https://leetcode.com/problems/partition-list/description/)

  - **isScramble**: Implemented the solution for the "Scramble String" problem, which determines if one string is a scrambled version of another. A string is considered scrambled if it can be obtained by recursively swapping its substrings. The solution uses recursion and memoization to efficiently check all possible partitions and swaps, ensuring optimal performance. With memoization, the approach avoids redundant computations, significantly improving runtime for larger strings. This solution has a time complexity of O(n^4) due to recursive checking of substring partitions.
    [Problem Description: isScramble](https://leetcode.com/problems/scramble-string/description/)
* Day 241: 📈 Fibonacci Sequence Calculator in Python 🔢
  Today, I focused on implementing a Fibonacci Sequence Calculator using Python, emphasizing the concept of recursion. The project demonstrates how recursive functions can be utilized to solve problems that can be broken down into smaller, similar subproblems. Here are the key highlights:

  - **Recursion**: The main feature of this project is the recursive function `fibonacci(n)`, which calculates the nth Fibonacci number. The function calls itself with smaller values until it reaches the base case, demonstrating the power and simplicity of recursion.

  - **Base Case**: The function includes a base case that returns `n` when it is 0 or 1. This is crucial for stopping the recursion and preventing infinite loops, ensuring that the function eventually returns a result.

  - **Recursive Case**: For values greater than 1, the function computes the Fibonacci number by summing the results of two recursive calls: `fibonacci(n - 1)` and `fibonacci(n - 2)`. This showcases how complex problems can be solved by combining solutions to simpler problems.

  - **Example Usage**: The code includes an example usage section where users can easily modify the position in the Fibonacci sequence they wish to calculate. This makes it straightforward to test and understand how the function operates.

  - **Performance Consideration**: While this recursive approach is elegant and easy to read, it is important to note that it may not be efficient for larger values of `n` due to exponential time complexity. Future improvements could include memoization or iterative solutions to enhance performance.

  This project was a valuable exercise in understanding recursion and its applications in programming. It reinforced my ability to break down problems into manageable parts and implement solutions in a clear and concise manner. Overall, it was a rewarding experience that deepened my understanding of recursive algorithms in Python.
* Day 242: ♟️ Simple Chess Game in Python ♟️

  Today, I developed a simple console-based chess game using Python. The project focuses on Object-Oriented Programming (OOP) principles and provides a basic structure for two players to play against each other. Below are the key highlights of the project:

  - **Chess Board Representation**: The `ChessBoard` class initializes an 8x8 grid representing the chessboard, setting up all pieces in their starting positions. The board is displayed in a user-friendly format, making it easy to visualize the game state.

  - **Chess Pieces**: The `ChessPiece` class represents individual chess pieces, encapsulating attributes such as color and type. Each piece can be identified by its abbreviated representation (e.g., `wP` for white pawn).

  - **Move Validation**: The game includes a basic move validation method within the `ChessBoard` class. This method checks whether a move is valid based on simple rules, such as ensuring that players cannot capture their own pieces.

  - **User Interaction**: The game runs in a loop that prompts players for their moves. Players enter the starting and ending coordinates of the piece they wish to move, allowing for an interactive gameplay experience.

  - **Turn Management**: The game alternates turns between the two players (White and Black), ensuring that each player has an equal opportunity to make their moves. This adds a strategic element to the gameplay.

  - **Future Enhancements**: While the current implementation covers basic functionalities, there are numerous opportunities for expansion, such as implementing specific movement rules for each piece, handling check/checkmate scenarios, and adding a graphical user interface (GUI) for improved user experience.

  This project was an excellent exercise in applying OOP principles to create a functional and engaging game. It allowed me to deepen my understanding of class design, encapsulation, and user interaction while building a classic game of chess. I look forward to enhancing this project further and exploring more complex chess mechanics!
* Day 243: 🧴 Lotion Management System in Python 🌿

  Today, I developed a Lotion Management System using Python, focusing on Object-Oriented Programming (OOP) principles. This project allows users to manage a collection of lotions, including adding, removing, viewing, and updating stock levels. Below are the key highlights:

  - **Encapsulation**: The `Lotion` class encapsulates attributes such as `lotion_id`, `name`, `brand`, `price`, and `stock`. This ensures that the details of each lotion are kept together and can be managed through methods that control access to these attributes.

  - **Model-View-Controller (MVC) Architecture**: The application is structured using the MVC design pattern, separating the logic into three components:
    - **Model**: The `LotionModel` class manages the data and business logic, including methods for adding, removing, and retrieving lotions.
    - **View**: The `LotionView` class handles user interaction, displaying menus and messages while gathering input from users.
    - **Controller**: The `LotionController` class orchestrates the flow of data between the model and view, responding to user inputs and updating the model accordingly.

  - **User Interaction**: A menu-driven interface allows users to interact with the system easily. Users can choose options to view all lotions, add new lotions, remove existing ones, or update stock levels. This enhances usability and makes the application practical for everyday use.

  - **Data Management**: The system maintains a list of lotions in memory. Users can add new lotions with details such as ID, name, brand, price, and stock quantity. The application checks for valid inputs when removing or updating lotions to ensure data integrity.

  - **Feedback Mechanism**: The application provides feedback for user actions through success and error messages. This helps users understand whether their actions were successful or if they need to correct any mistakes.

  This project was a valuable exercise in applying OOP principles to create a functional and maintainable system. I enhanced my understanding of how encapsulation works in practice while implementing an MVC architecture that promotes separation of concerns. Overall, this lotion management tool serves as a practical application of my programming skills in Python.
* Day 244: Guava Fruit Disease Dataset [Kaggle](https://www.kaggle.com/datasets/asadullahgalib/guava-disease-dataset/data)

  Today, I focused on developing a convolutional neural network (CNN) to classify diseases in guava fruits using the Guava Disease Dataset from Kaggle. The project involved data preprocessing, model training, and evaluation using TensorFlow and Keras. Below are the key highlights:

  - **Data Loading and Preprocessing**: I utilized TensorFlow's `image_dataset_from_directory` function to load the dataset, which automatically infers labels from the directory structure. The images were resized to a uniform size of 180x180 pixels and split into training and validation sets.

  - **Data Visualization**: I created visualizations to display sample images from the dataset along with their corresponding labels. This helped in understanding the types of diseases present in the dataset and ensured that the data was loaded correctly.

  - **Model Architecture**: I implemented several CNN architectures, including:
    - A **basic CNN** model with multiple convolutional and pooling layers.
    - A **CNN with Dropout** layers to mitigate overfitting.
    - A **transfer learning model** using MobileNetV2, which leverages pre-trained weights for better performance.

  - **Model Compilation and Training**: Each model was compiled using the Adam optimizer and trained for a specified number of epochs. The training process included monitoring both training and validation accuracy to assess model performance.

  - **Performance Evaluation**: After training, I evaluated each model on the validation set, reporting metrics such as validation loss and accuracy. This step provided insights into how well each model generalized to unseen data.

  - **Visualization of Results**: I plotted graphs to compare training and validation accuracy and loss for each model type. This visualization aids in understanding the models' learning behavior over epochs.

  - **Model Saving**: The best-performing model based on validation accuracy was saved for future use, ensuring that the results can be reproduced or deployed later.

  This project provided an excellent opportunity to apply deep learning techniques to image classification tasks. It reinforced my understanding of CNNs, data preprocessing, and the importance of model evaluation in machine learning workflows. Additionally, working with real-world datasets like the Guava Disease Dataset highlighted the challenges and considerations involved in agricultural image classification tasks.
* Day 245: Technical Test "merge" and "grayCode" [LeetCode](https://leetcode.com/problems/)

- **merge**: Implemented a solution for the "Merge Sorted Array" problem, where the goal is to merge two sorted arrays into one sorted array. The first array has enough space to hold the elements of both arrays. The approach involves using two pointers to traverse each array from the end towards the beginning, ensuring that elements are merged in-place without requiring additional space. The time complexity of this solution is O(m + n), where m and n are the sizes of the two arrays.
  [Problem Description: merge](https://leetcode.com/problems/merge-sorted-array/description/)

- **grayCode**: Developed a solution for generating an n-bit Gray code sequence. The Gray code is a binary numeral system where two successive values differ in only one bit. The implementation uses a mathematical formula to compute the Gray code directly from its index, allowing efficient generation of the sequence. This method runs in O(2^n) time, as it generates all 2^n Gray codes for n bits.
  [Problem Description: grayCode](https://leetcode.com/problems/gray-code/description/)
* Day 246: 🗂️ Task Prioritization Matrix in Python 📊

  Today, I focused on developing a **Task Prioritization Matrix** application using Python, leveraging the **Tkinter** library for the graphical user interface (GUI). This project is designed to help users categorize and manage tasks based on their urgency and importance. Below are the key highlights:

  - **Object-Oriented Design**: The application utilizes OOP principles to create a clean and maintainable code structure. The `Task` class encapsulates task-related attributes such as `description` and `category`, allowing for easy management of task data.

  - **User Interface**: The GUI consists of four quadrants representing different categories of tasks:
    - **Urgent & Important**
    - **Urgent & Not Important**
    - **Not Urgent & Important**
    - **Not Urgent & Not Important**
    
    Each quadrant features a list box displaying tasks, enabling users to interact with their task lists intuitively.

  - **Task Management Features**:
    - **Add Task**: Users can add new tasks by specifying a description and selecting a category. The application provides prompts for input, ensuring a user-friendly experience.
    - **Edit Task**: Users can select an existing task to edit its description, allowing for updates as priorities change.
    - **Delete Task**: Selected tasks can be removed from the list, helping users keep their task lists relevant.
    
  - **Drag-and-Drop Functionality**: Users can drag tasks between different quadrants, facilitating easy reorganization based on changing priorities.

  - **Weekly Report Generation**: The application includes functionality to generate a weekly report of tasks categorized by urgency and importance. The report is saved in JSON format, making it easy to share or analyze later.

  - **Colorful UI Elements**: Buttons are designed with friendly colors to enhance usability and make the interface visually appealing. For example:
    - Add Task button: Green
    - Edit Task button: Blue
    - Delete Task button: Red
    - Generate Report button: Yellow
* Day 247: 🏥 Medication Reminder System in Flask 💊

  Today, I worked on a **Medication Reminder System** using Flask, which allows nurses to manage medication schedules for patients effectively. The application provides features for adding, editing, and deleting patient records, as well as setting reminders for medication times. Below are the key highlights:

  - **Responsive Design**: The application is fully responsive and centers its content for an optimal user experience across various devices. This ensures that nurses can easily access and manage patient information on tablets or smartphones.

  - **Real-Time Clock**: A large real-time clock is displayed at the top of the interface, allowing nurses to quickly reference the current time and plan medication schedules accordingly.

  - **Patient Management**: Nurses can add patients with detailed information including ID, name, room number, medications (which can be multiple), allergies, and medication times. The application supports multiple medications with different administration times.

  - **Dynamic Fields**: The system allows users to dynamically add multiple medication time fields for each patient. This flexibility is crucial for patients who require multiple doses throughout the day.

  - **Edit and Delete Functionality**: Each patient's information can be edited or deleted as necessary. This feature ensures that the system remains up-to-date with any changes in patient care plans.

  - **Medication Reminders**: The application runs a background thread that checks the current time against each patient's medication schedule, providing reminders when it's time to administer medication. This helps prevent missed doses.

  - **Weekly Report Generation**: A feature to generate a weekly report in JSON format is included, allowing for easy tracking and documentation of patient medication schedules.

  - **User-Friendly Interface**: The interface is designed with a dark theme and colorful buttons for better usability. Each button serves a distinct function, making navigation intuitive for users.

  This project was an excellent opportunity to deepen my understanding of web development with Flask while implementing features that are practical and beneficial in a healthcare setting. I learned how to manage stateful data in a web application and ensure that user interactions are seamless and efficient. Overall, it was a rewarding experience to create a tool that can help improve patient care through better medication management.
* Day 248: ⏱️ Chess Clock Simulation in Python ♟️

  Today, I developed a Chess Clock Simulation using Python, designed for players to engage in quick-paced games, such as blitz chess. The project focuses on creating a user-friendly command-line interface that allows players to manage their time effectively during matches. Here are the key highlights:

  - **Timer Management**: The `ChessClock` class manages the countdown timers for two players. It tracks the remaining time and ensures that the clock runs accurately for the active player.

  - **Multithreading**: The timer runs in a separate thread, allowing the main program to remain responsive. This enables players to switch turns without interrupting the countdown, ensuring smooth gameplay.

  - **Time Modes**: The simulation supports various time controls (e.g., "5+0" and "3+2"), allowing users to select their preferred game format. Each mode initializes the players' times accordingly.

  - **Player Switching**: Players can easily switch turns by pressing a key, which updates the active player and resumes their timer. This feature enhances the interactivity of the simulation.

  - **User Interface**: A simple command-line interface displays the remaining time for both players in a clear format. Players can view their time and choose to switch or quit at any moment during the game.

  - **Final Time Display**: When the game ends, either by running out of time or user intervention, the remaining times for both players are displayed in an easy-to-read format, providing a clear conclusion to the match.

  This project was an engaging exercise in applying programming concepts such as multithreading and user input handling. It allowed me to explore how to create an interactive tool that enhances the chess-playing experience. I also gained valuable insights into managing state and ensuring thread safety in a real-time application.
* Day 249: 🏀 Basketball Tournament Management System in Python 🏆

  Today, I developed a Basketball Tournament Management System using Python, focusing on Object-Oriented Programming (OOP) principles. The system allows users to register teams and players, create match schedules, record results, and display standings. Below are the key highlights:

  - **Encapsulation**: The `Player` and `Team` classes encapsulate attributes such as `name`, `position`, and match records (wins and losses). This ensures that the internal state of these objects is protected and can only be modified through defined methods.

  - **Class Relationships**: The system features a clear relationship between classes:
    - The `Tournament` class manages multiple `Team` instances and their associated `Match` instances.
    - The `Match` class handles the details of individual matches between two teams, including scheduling and result recording.

  - **Match Scheduling**: The system creates a randomized match schedule for registered teams. This feature ensures that teams are paired fairly and allows for easy extension to include more complex scheduling algorithms in the future.

  - **Statistics Tracking**: After matches are played, results can be recorded, and the system automatically updates each team's win-loss record. This functionality provides real-time feedback on team performance throughout the tournament.

  - **User Interaction**: A menu-driven interface allows users to interact with the system seamlessly. Users can register teams and players, create schedules, record results, and view current standings in an intuitive manner.

  - **Future Enhancements**: The current implementation serves as a solid foundation for future enhancements, such as adding player statistics, integrating a database for persistent storage, or developing a graphical user interface (GUI) for better user experience.

  This project was an excellent opportunity to apply OOP principles while creating a functional system for managing basketball tournaments. I gained valuable experience in designing classes with clear responsibilities and interactions, resulting in clean and maintainable code. Overall, this Basketball Tournament Management System is both practical and scalable for future development.
* Day 250: Technical Test "subsetsWithDup" and "numDecodings" [LeetCode](https://leetcode.com/problems/)

  - **subsetsWithDup**: Implemented a solution for the "Subsets II" problem, which generates all possible subsets of a given integer array that may contain duplicates. The approach involves sorting the input array to handle duplicates effectively and using backtracking to explore all combinations. The solution ensures that no duplicate subsets are included in the final result by skipping over repeated elements during the generation process. The time complexity is O(2^n), where n is the number of elements in the input array.
    [Problem Description: subsetsWithDup](https://leetcode.com/problems/subsets-ii/description/)

  - **numDecodings**: Developed a solution for the "Decode Ways" problem, which counts the number of ways to decode a given string of digits based on a specific mapping (1 to A, 2 to B, ..., 26 to Z). The solution employs dynamic programming to efficiently compute the number of valid decodings by considering both one-digit and two-digit possibilities at each step. It initializes a dp array to store the number of ways to decode substrings and iterates through the string while checking for valid digit combinations. The time complexity is O(n), where n is the length of the input string.
    [Problem Description: numDecodings](https://leetcode.com/problems/decode-ways/description/)
* Day 251: 🍞 Bakery Management System in Python 🥐

  Today, I developed a Bakery Management System using Python, emphasizing Object-Oriented Programming (OOP) principles. This project allows users to manage bakery items, including adding, removing, updating, and searching for items, as well as calculating the total inventory value. Below are the key highlights:

  - **Encapsulation**: The `BakeryItem` class encapsulates attributes like `name`, `price`, and `quantity`. This ensures that each item has controlled access to its properties, promoting data integrity within the system.

  - **Data Management**: The system allows for comprehensive management of bakery items. Users can add new items with details such as name, price, and quantity. The application supports removing items and updating existing ones, making it flexible for various bakery operations.

  - **Search Functionality**: Users can search for bakery items by name. This feature enhances usability by allowing quick access to specific items without having to sift through the entire inventory.

  - **Total Inventory Value Calculation**: The application calculates and displays the total value of all items in the inventory. This feature is crucial for understanding stock value and making informed business decisions.

  - **User-Friendly Interface**: A menu-driven interface provides an intuitive way for users to interact with the system. Options include viewing all items, adding new items, removing or updating existing items, searching by name, and displaying total inventory value.

  - **Modular Design**: The project follows the Model-View-Controller (MVC) architecture pattern. This separation of concerns ensures that the code is organized and maintainable. The model handles data representation, the view manages user interaction, and the controller processes user inputs and updates the model accordingly.

  This project was a valuable exercise in applying OOP principles to create a functional and maintainable system. It allowed me to deepen my understanding of encapsulation and modular design while building a practical tool tailored for bakery management.
* Day 252:  🎶 Music Melody Generator in Python 🎵

  Today, I developed a **Music Melody Generator** using Python, which leverages recursion and object-oriented programming principles to create random melodies based on predefined musical rules. The project focuses on generating sequences of musical notes, showcasing how simple rules can lead to complex and interesting outputs. Here are the key highlights:

  - **Class Structure**: The `MusicGenerator` class encapsulates the logic for melody generation. It defines production rules that determine which notes can follow each other, allowing for a structured approach to generating music.

  - **Recursive Melody Generation**: The core functionality is implemented in the `generate_melody` method, which uses recursion to build a melody of specified depth. Starting from a given note, the method explores possible next notes based on the defined rules, creating a unique melody each time it is executed.

  - **Random Note Selection**: To add variety and unpredictability to the generated melodies, the program randomly selects the next note from the available options. This randomness ensures that each melody produced is distinct and engaging.

  - **Base Case Handling**: The recursion includes a base case that stops further note generation when the specified depth is reached or when there are no valid next notes. This ensures that the program runs efficiently and produces coherent melodies.

  - **User-Friendly Output**: The generated melodies are printed in a clear format, making it easy for users to listen to or analyze the output. This feature enhances user engagement and provides immediate feedback on the program's functionality.

  - **Potential for Expansion**: This project lays the groundwork for future enhancements, such as adding more complex musical rules, incorporating user input for starting notes or melody lengths, or even integrating sound playback capabilities.

  This project was an exciting exploration of how programming can intersect with music theory. It allowed me to apply concepts of recursion and object-oriented design while creating something artistic and fun. I look forward to expanding this generator further and experimenting with different musical structures!
* Day 253: 🧠 Stroke Prediction Dataset [Kaggle](https://www.kaggle.com/datasets/fedesoriano/stroke-prediction-dataset/data)

  Today, I worked on analyzing the Stroke Prediction Dataset from Kaggle using Python. The focus was on data preprocessing, model training, and evaluation using various machine learning algorithms. This project aims to predict the likelihood of strokes based on health-related features. Below are the key highlights:

  - **Data Loading and Inspection**: The dataset was loaded using Pandas, and initial inspection was performed to understand its structure and identify any missing values.

  - **Data Preprocessing**: 
    - **Handling Missing Values**: Missing values were addressed by filling them with the mean of the respective columns for numerical data.
    - **Encoding Categorical Variables**: Categorical features such as gender, marital status, work type, residence type, and smoking status were encoded into numerical values using `LabelEncoder`.

  - **Feature Selection**: The features were separated from the target variable (stroke), ensuring that only relevant data was used for training the models.

  - **Model Training**: Various classification models were implemented to predict strokes:
    - **Logistic Regression**
    - **Support Vector Classifier**
    - **Random Forest Classifier**
    - **Decision Tree Classifier**
    - **Gradient Boosting Classifier**

  - **Model Evaluation**: Each model's performance was evaluated using accuracy scores and classification reports that included precision, recall, and F1-score. This provided insights into how well each model performed in predicting stroke occurrences.

  - **Results Summary**: The results for each model were compiled, showcasing their accuracy and detailed classification metrics. This analysis helped identify which model performed best for this particular dataset.

  - **User-Friendly Functions**: The project included modular functions that allowed for easy execution of the entire analysis process, enhancing code readability and maintainability.

  This project provided a valuable opportunity to deepen my understanding of machine learning techniques in Python while working with a critical health-related dataset. The experience emphasized the importance of data preprocessing and model evaluation in building effective predictive models.
* Day 254: 📝 Note Taking Application in Python 🗒️

  Today, I developed a Note Taking Application using Python and Tkinter, focusing on creating a user-friendly interface with essential functionalities for managing notes. The project allows users to add, edit, delete, search, and save notes persistently. Below are the key highlights:

  - **User Interface**: The application features a clean and intuitive GUI built with Tkinter. It includes a text area for displaying notes and buttons for various actions, all styled with a dark theme for better visibility.

  - **Persistent Storage**: Notes are saved to a JSON file (`notes.json`) when added or modified. This ensures that users can access their notes even after closing the application. The application loads existing notes at startup, providing a seamless experience.

  - **CRUD Operations**: The application supports full CRUD (Create, Read, Update, Delete) functionality:
    - **Add Note**: Users can create new notes through a simple dialog.
    - **Edit Note**: Existing notes can be modified by selecting the note's index.
    - **Delete Note**: Users can remove notes with a confirmation dialog to prevent accidental deletions.
    - **Search Note**: A search feature allows users to find specific notes based on keywords.

  - **Error Handling**: The application includes error handling for user inputs, ensuring that invalid operations (like editing or deleting non-existent notes) are managed gracefully with informative error messages.

  - **User Experience Enhancements**: 
    - Buttons have distinct colors for different actions, enhancing usability and aesthetics.
    - Hover effects provide visual feedback when interacting with buttons.
    - The text area supports easy navigation and readability.

  - **Future Improvements**: Potential enhancements could include text formatting options (bold, italic), color coding for notes, and keyboard shortcuts for common actions. Additionally, implementing advanced search capabilities could further improve functionality.

  This project was an excellent exercise in applying Python programming skills and working with GUI development using Tkinter. It provided valuable experience in managing data persistently and designing user-friendly interfaces while building a practical tool for note-taking.
* Day 255: 🛒 Shopping List Notification System in Python 📬

  Today, I developed a Shopping List Notification System using Python, leveraging the `plyer` library to send desktop notifications. This simple yet effective project helps users keep track of their shopping items by alerting them with a notification on their Windows desktop. Below are the key highlights:

  - **Notification Feature**: The primary functionality of the system is to send a desktop notification containing the user's shopping list. This is accomplished using the `plyer` library, which provides a straightforward interface for creating notifications across different platforms.

  - **Dynamic Shopping List**: The system allows users to define their shopping list as a list of items. This flexibility enables easy updates and modifications to the list before sending the notification.

  - **User-Friendly Interface**: Although this version is a simple script, it can be easily extended with a user interface (UI) in the future. For now, users can modify the shopping list directly in the code and run the script to receive their notifications.

  - **Code Structure**: The code is organized into a function (`send_shopping_list_notification`) that handles the creation and display of the notification. This modular approach makes it easy to integrate additional features or enhancements later.

  - **Installation Requirements**: Users need to install the `plyer` library to run the script. This can be done easily via pip, ensuring that anyone can set up the project without hassle.

  - **Actionable Notifications**: The notifications provide a clear overview of what items need to be purchased, helping users stay organized and efficient during their shopping trips.

  This project was an engaging exercise in using Python for practical applications beyond just command-line interfaces. It reinforced my understanding of how libraries can enhance functionality and improve user experience through notifications. I look forward to expanding this project with additional features such as user input for dynamic list management or integration with online grocery services.
* Day 256: 📚 Study Notification System in Python ⏰

  Today, I developed a Study Notification System using Python, aimed at helping students manage their study schedules by sending timely notifications for various subjects. This project focuses on enhancing study habits and ensuring that important topics are reviewed in a timely manner. Here are the key highlights:

  - **Scheduled Notifications**: The system sends notifications at specified times for different subjects, utilizing the `schedule` library to manage timing effectively. This ensures that students receive reminders when they need them most.

  - **Dynamic Subject List**: Users can easily define and modify a list of subjects along with their corresponding review times and helpful tips directly in the code. This flexibility allows for quick adjustments to the study schedule as needed.

  - **Helpful Tips**: Each notification includes a relevant tip related to the subject being reviewed. This feature provides additional context and guidance, enhancing the overall study experience.

  - **Code Structure**: The code is organized into functions that handle both the scheduling and sending of notifications. This modular approach promotes maintainability and makes it easy to add new features in the future.

  - **Installation Requirements**: To run the script, users need to install both the `plyer` and `schedule` libraries. These can be installed easily via pip, making it accessible for anyone interested in improving their study habits.

  - **User Engagement**: The notifications serve as actionable reminders, helping students focus on specific topics while providing tips that can improve their understanding and retention of material.

  This project was an excellent opportunity to apply Python in an educational context, demonstrating how technology can assist in effective learning strategies. I look forward to expanding this system with features such as user input for dynamic scheduling or integration with calendar applications.
* Day 257: Technical Test "reverseBetween" and "restoreIpAddresses" [LeetCode](https://leetcode.com/problems/)

  - **reverseBetween**: Implemented a solution for the "Reverse Linked List II" problem, where the task is to reverse a portion of a singly linked list between two given positions, `left` and `right`. The approach uses a two-pointer technique to identify the nodes before and after the segment to be reversed, and then performs the reversal in place. The time complexity is O(n), where n is the number of nodes in the list, as we traverse the list at most twice.
    [Problem Description: reverseBetween](https://leetcode.com/problems/reverse-linked-list-ii/description/)

  - **restoreIpAddresses**: Developed a solution for the "Restore IP Addresses" problem, which generates all possible valid IP addresses from a string of digits. The solution employs backtracking to explore all possible placements of dots in the string while ensuring that each segment formed adheres to the rules for valid IP addresses (0-255 and no leading zeros). The time complexity is O(1) in terms of processing since there are at most 256 valid IP addresses that can be formed from a given string.
    [Problem Description: restoreIpAddresses](https://leetcode.com/problems/restore-ip-addresses/description/)
* Day 258: 🏨 Hotel Booking System in Python 🛏️

  Today, I developed a Hotel Booking System using Python, focusing on recursion to manage room bookings. The project simulates a simple hotel environment where users can book rooms until they choose to stop. Below are the key highlights:

  - **Recursion**: The core functionality of the booking system is implemented using a recursive function. This allows users to book multiple rooms in a seamless manner, where each booking prompts for guest details and confirms the reservation.

  - **User Interaction**: The program engages users by asking for their name and the number of nights they wish to stay. After confirming each booking, it inquires whether they would like to make another reservation, demonstrating an interactive experience.

  - **Room Availability Management**: The system tracks the number of available rooms. If no rooms are available, it informs the user and exits gracefully, ensuring that the user experience remains smooth and informative.

  - **Data Handling**: Although this implementation is basic, it lays the groundwork for managing guest information and room availability. Future enhancements could include storing guest details in a database or file for persistent data management.

  - **Simplicity and Clarity**: The code is structured to be straightforward and easy to understand, making it accessible for beginners learning about recursion and user input handling in Python.

  This project was an excellent opportunity to practice recursion and enhance my skills in creating interactive command-line applications. It allowed me to explore how recursive functions can simplify complex tasks, such as managing repeated user interactions in a hotel booking scenario. I look forward to expanding this system with more features, such as payment processing and room types!
* Day 259: 📊 Data Processing Pipeline in Python 🐍

  Today, I developed a simple Data Processing Pipeline in Python, focusing on the Extract, Transform, Load (ETL) process. This project demonstrates how to efficiently manage data from extraction to transformation and finally loading it into a new format. Below are the key highlights:

  - **Data Extraction**: The pipeline begins by extracting data from a CSV file using the `pandas` library. The `extract_data` function reads the input file and returns a DataFrame containing the raw data. This step is crucial for ensuring that we have a structured format to work with.

  - **Data Transformation**: In the transformation phase, I implemented filtering and additional calculations. Specifically, I filtered out records where the salary is less than $60,000 and added a new column for tax, calculated as 20% of the salary. This step enhances the dataset by providing relevant insights and preparing it for further analysis.

  - **Data Loading**: The final stage involves loading the transformed data into a new CSV file. The `load_data` function saves the processed DataFrame to a specified output path, making it easy to access and utilize in future analyses or applications.

  - **Handling Warnings**: During development, I encountered a `SettingWithCopyWarning`. To resolve this, I ensured that modifications were made on a copy of the DataFrame slice using `.copy()` and utilized `.loc[]` for assignments. This practice not only avoids warnings but also promotes clarity in data manipulation.

  - **Project Structure**: The project is organized into a clear directory structure, with separate folders for input data and output results. This organization facilitates easy access to files and improves maintainability.

  - **User-Friendly Output**: The pipeline outputs a well-structured CSV file containing only relevant records along with calculated fields. This enhances usability for downstream applications or further data analysis tasks.

  This project was an excellent opportunity to apply my knowledge of data processing techniques in Python. It reinforced my understanding of how to build efficient ETL pipelines while managing data integrity and clarity throughout the process. Overall, this experience has equipped me with practical skills that are essential for handling real-world data workflows effectively.
* Day 260: 🌌 Koch Curve Fractal in Python 🌊

  Today, I developed a program to generate and visualize the Koch Curve, a fascinating fractal known for its intricate and self-similar structure. The project utilizes recursion to create the curve and employs Matplotlib for visualization. Here are the key highlights:

  - **Recursion**: The Koch curve is constructed using a recursive approach, where each line segment is divided into thirds and an equilateral triangle is added to create the fractal pattern. This method exemplifies how recursion can simplify complex geometric constructions.

  - **Matplotlib Visualization**: The program uses Matplotlib to plot the generated points of the Koch curve. By extracting the x and y coordinates from the computed points, we can visualize the fractal in a clear and engaging manner.

  - **Modularity**: The code is structured into two main functions: `koch_curve` for generating the fractal points and `plot_koch_curve` for handling the plotting. This modular design enhances readability and allows for easy modifications or extensions of functionality.

  - **Customization**: Users can specify the recursion depth when running the program. This feature enables exploration of different levels of complexity in the Koch curve, allowing for both simple and intricate designs.

  - **Mathematical Insight**: The project provides an opportunity to explore mathematical concepts related to fractals, such as self-similarity and infinite detail. The resulting curves exhibit properties that are both beautiful and mathematically significant.

  - **User-Friendly Interface**: The program is designed to be straightforward to run, requiring minimal input from the user while providing a visually appealing output. This makes it accessible even for those who may not have a strong programming background.

  This project was an exciting way to delve into fractals and their recursive nature while enhancing my skills in Python programming and data visualization. It reinforced my understanding of recursion and its applications in generating complex shapes, all while creating a visually stunning representation of mathematical beauty.
* Day 261: ⏳ Pomodoro Timer System in Python 🍅

  Today, I developed a Pomodoro Timer system using Python, focusing on providing a user-friendly experience for managing work and break sessions. The project implements notifications to alert users when it’s time to work or take a break, following the popular Pomodoro Technique. Here are the key highlights:

  - **Session Management**: The timer allows users to configure the duration of work sessions and break periods. By default, it is set to 25 minutes for work and 5 minutes for breaks, with the option to customize these settings.

  - **Desktop Notifications**: Utilizing the `plyer` library, the system sends desktop notifications to inform users when to start working and when to take a break. This feature enhances user engagement and helps maintain focus during work sessions.

  - **Session Tracking**: The timer keeps track of the number of completed Pomodoro sessions. Users can set a specific number of sessions to complete before taking a longer break, promoting productivity and effective time management.

  - **User Feedback**: After each session, the program prints messages to the console indicating the completion of work or break sessions, providing real-time feedback on progress.

  - **Extensibility**: The structure of the code allows for easy modifications and enhancements. Future improvements could include features such as customizable notification messages, session statistics, or integration with task management tools.

  - **Simple Interface**: The program runs in a command-line interface, making it straightforward to use without any complex setup. Users can simply run the script to start their Pomodoro sessions.

  This project was an excellent opportunity to apply my programming skills in Python while creating a practical tool for improving productivity. I gained valuable experience in working with time management concepts and desktop notifications, all while enhancing my understanding of how to structure code effectively for usability and maintainability.
* Day 262: 📈 Video Game Stocks Analysis[Kaggle](https://www.kaggle.com/datasets/datadrivenx/video-game-stocks-financial-market-data/data) 

  Today, I focused on analyzing the financial market data of top video game stocks using Python. The analysis involved data cleaning, visualization, and modeling to understand trends and performance in the gaming industry. Below are the key highlights of the project:

  - **Data Import and Preparation**: I utilized Pandas to load the dataset from Kaggle, which includes stock prices for various video game companies. The dataset was cleaned to handle missing values and ensure proper formatting for analysis.

  - **Exploratory Data Analysis (EDA)**: I conducted a thorough EDA to visualize stock trends over time. This included:
    - **Time Series Plots**: Line graphs were created to display the stock price movements of different companies over time, allowing for a visual comparison of their performance.
    - **Statistical Summary**: A summary of key statistics (mean, median, standard deviation) was generated for each company's stock prices, providing insights into their volatility and average performance.

  - **Correlation Analysis**: I examined correlations between the stock prices of different companies. A heatmap was generated to visually represent these relationships, helping identify which companies' stocks move together.

  - **Modeling**: Implemented machine learning models such as Logistic Regression and Random Forest Classifier to predict stock price movements based on historical data. The models were evaluated using metrics like accuracy score and classification report.

  - **Visualization Techniques**: Leveraged Matplotlib and Seaborn for creating various plots:
    - **Bar Charts**: Used to compare average stock prices among different companies.
    - **Histograms**: Displayed the distribution of stock prices, aiding in understanding price ranges and frequencies.

  - **User-Friendly Functions**: Developed modular functions for data loading, preprocessing, and visualization. This enhances code reusability and makes it easier to run analyses with different datasets.

  This project provided valuable insights into the financial dynamics of the video game industry, reinforcing the importance of data analysis in making informed investment decisions. The experience highlighted how visualizations can effectively communicate complex financial trends and patterns.
* Day 263: Technical Test "inorderTraversal" and "generateTrees" [LeetCode](https://leetcode.com/problems/)

  - **inorderTraversal**: Implemented a solution for the "Binary Tree Inorder Traversal" problem, which requires returning the values of nodes in an inorder sequence (left, root, right). The approach uses recursion to traverse the tree and collect node values in the correct order. The time complexity is O(n), where n is the number of nodes in the tree.
    [Problem Description: inorderTraversal](https://leetcode.com/problems/binary-tree-inorder-traversal/description/)

  - **generateTrees**: Developed a solution for the "Unique Binary Search Trees II" problem, where the goal is to generate all structurally unique BSTs that can be formed using integers from 1 to n. The algorithm utilizes recursion with memoization to efficiently generate trees by considering each number as a potential root and recursively generating all possible left and right subtrees. The time complexity is O(n^n) due to the exponential number of unique trees that can be formed.
    [Problem Description: generateTrees](https://leetcode.com/problems/unique-binary-search-trees-ii/description/)
* Day 264: 🛒 E-Commerce Shopping Cart in Python 🛍️

  Today, I developed an E-Commerce Shopping Cart application using Python, focusing on Object-Oriented Programming (OOP) principles. This project enables users to manage their shopping cart effectively by adding, removing, and modifying products, while also calculating totals with applicable taxes and discounts. Here are the key highlights:

  - **Encapsulation**: The `Product` class encapsulates attributes such as `name`, `price`, and `stock`, ensuring that product details are protected and can only be modified through defined methods. This prevents unauthorized changes to the product's state.

  - **Shopping Cart Management**: The `ShoppingCart` class manages a collection of products, allowing users to add items while checking stock availability. It provides methods for removing products and modifying quantities, making it easy to manage the cart's contents.

  - **Total Calculation**: The application includes a method to calculate the total price of items in the cart, incorporating optional tax rates and discounts. This feature ensures that users can see the final amount they need to pay, enhancing the shopping experience.

  - **Testing Functionality**: A dedicated testing function simulates various operations on the shopping cart, such as adding products, modifying quantities, removing items, and calculating totals. This helps verify the correctness of the implementation and ensures robustness.

  - **User-Friendly Interface**: Although the application runs directly in Python without a graphical interface, it is designed to be intuitive. Users can easily understand how to interact with the cart through clear method calls and console output.

  - **Future Enhancements**: Potential improvements include implementing user authentication for personalized shopping experiences, adding support for multiple users managing their own carts concurrently, integrating a database for persistent storage, and creating a user-friendly graphical interface.

  This project was an excellent opportunity to apply OOP principles in a practical scenario. I refined my understanding of encapsulation and how it contributes to creating maintainable code while building a functional shopping cart system that could be expanded in future iterations.
* Day 265: 🏀 Basketball Injury Tracker in Python 🏥

  Today, I developed a Basketball Injury Tracker using Python, focusing on Object-Oriented Programming (OOP) principles to create a structured and maintainable system. The project allows coaches and medical staff to monitor player injuries, record recovery times, and maintain injury histories. Below are the key highlights:

  - **Encapsulation**: The `Player` class encapsulates player details and their injury records, ensuring that injury data is managed internally while providing methods for adding and retrieving injuries.

  - **Class Structure**: The system consists of multiple classes:
    - `Player`: Represents a basketball player and maintains their injury history.
    - `Injury`: Represents individual injuries with details such as type and recovery time.
    - `MedicalTeam`: Handles notifications to medical staff when a new injury is recorded.
    - `InjuryTracker`: Manages all players and their injuries, providing a central interface for interaction.

  - **Injury Management**: Coaches can record injuries for players, specifying the type of injury and estimated recovery time. The system automatically notifies the medical team about new injuries, ensuring prompt attention.

  - **Injury History**: Users can view the complete injury history for any player, allowing for better tracking of recurring issues and overall player health management.

  - **Menu-Driven Interface**: A user-friendly command-line interface allows users to interact with the system easily. Users can add players, record injuries, view injury histories, or exit the program through simple menu options.

  - **Future Enhancements**: The project is designed to be easily extendable. Future improvements could include data persistence (e.g., using a database), enhanced notification systems (e.g., email alerts), or a graphical user interface (GUI) for better usability.

  This project was an excellent opportunity to apply OOP principles in a practical context. I refined my understanding of how encapsulation and class design contribute to creating clean and efficient code while building a useful tool for managing basketball player injuries.
* Day 266: 📊 Collatz Conjecture Sequence Visualizer in Python 🌌

  Today, I developed a Collatz Conjecture Sequence Visualizer using Python. This project focuses on generating and plotting the Collatz sequence for a given positive integer, featuring a user-friendly graphical interface. Below are the key highlights:

  - **Collatz Sequence Generation**: The program generates the Collatz sequence for any positive integer input by the user, following the rules of the conjecture: if the number is even, divide it by two; if odd, multiply by three and add one. This process continues until reaching the number one.

  - **Data Visualization**: Utilizing `matplotlib`, the sequence is plotted in a visually appealing manner. The plot includes markers for each step in the sequence, providing a clear representation of how the values change over time.

  - **Dark Background Theme**: The plot features a dark background style, enhancing visibility and aesthetics. This design choice ensures that the plot elements (lines, markers, and grid) stand out clearly against the background.

  - **User Input via GUI**: A simple graphical user interface (GUI) is implemented using `tkinter`. Users can input a positive integer through a dialog box, making the application more interactive and accessible compared to command-line input.

  - **Error Handling**: The program includes error handling for invalid inputs. If a user enters a non-positive integer or cancels the input dialog, appropriate messages are displayed to guide them towards valid input.

  - **Customizable Plot Features**: The plot includes customizable features such as grid lines and tick colors, allowing for an enhanced viewing experience. Users can easily interpret the plotted data thanks to these thoughtful design choices.

  This project was an excellent exercise in data visualization and GUI development in Python. It allowed me to deepen my understanding of how to effectively use libraries like `matplotlib` and `tkinter` to create interactive applications that present mathematical concepts in an engaging way. I enjoyed refining my skills in both coding and design while building this practical tool for exploring the fascinating Collatz conjecture.
* Day 267: 🎯 Subset Sum to Target in Python 🧮

  Today, I worked on a project that focuses on solving the "Subset Sum to Target" problem using Python. The goal of this project is to find all combinations of numbers in a given array that sum up to a specified target value. The implementation leverages recursion to explore all possible subsets. Below are the key highlights:

  - **Recursive Backtracking**: The core of the solution is a recursive backtracking algorithm that explores all potential combinations of numbers. It builds subsets incrementally and checks their sums against the target.

  - **Base Cases**: The algorithm includes essential base cases:
    - If the current sum equals the target, the current subset is added to the results.
    - If the current sum exceeds the target, further exploration is halted for that path.

  - **Dynamic Path Management**: As subsets are built, they are stored in a temporary list (`path`). This allows for easy backtracking by removing the last added element when exploring new combinations.

  - **Exploration of Combinations**: The function iterates through the list of numbers, starting from a given index, ensuring that each number is only considered once per subset. This prevents duplicates and maintains unique combinations.

  - **Example Usage**: An example is provided in the code to demonstrate how to call the function with a sample list and target value. This makes it easy for users to test and modify inputs as needed.

  - **Output**: The program outputs all unique subsets that sum up to the specified target, providing a clear and practical solution to the problem.

  This project was an excellent exercise in understanding recursive algorithms and their applications in combinatorial problems. It enhanced my skills in problem-solving and algorithm design while providing insights into how recursion can be effectively utilized to explore complex scenarios.
* Day 268: 🛠️ Team Role Management System in Python 👥

  Today, I developed a Team Role Management System using Python, focusing on the Model-View-Controller (MVC) architecture and Object-Oriented Programming (OOP) principles. This project allows users to manage roles within a development team by adding, removing, viewing, and updating roles. Below are the key highlights:

  - **Model-View-Controller (MVC)**: The application is structured using the MVC pattern, which separates concerns into three components:
    - **Model**: Manages data and business logic related to roles.
    - **View**: Handles user interface and displays information.
    - **Controller**: Acts as an intermediary between the model and view, processing user input and updating the model accordingly.

  - **Role Management**: Users can perform various operations on roles:
    - **Add New Role**: Users can add new roles with titles and descriptions.
    - **Remove Role**: Users can remove existing roles by title.
    - **View All Roles**: The system displays all current roles in the team.
    - **View Specific Role**: Users can view details of a specific role by its title.
    - **Update Existing Role**: Users can update the title and description of an existing role.

  - **User-Friendly Interface**: The application features a menu-driven interface that allows users to easily navigate through different options. This enhances usability and provides a clear interaction model.

  - **Data Structure**: The roles are encapsulated in a `Role` class, which includes attributes like `title` and `description`. This promotes encapsulation by keeping role-related data organized and manageable.

  - **Extensibility**: The design allows for future enhancements, such as adding more attributes to roles (e.g., responsibilities or required skills) or integrating with a database for persistent storage.

  This project was an excellent exercise in applying OOP principles and the MVC architecture to create a structured and maintainable system. I refined my understanding of how these concepts work together to build clean, reusable code while developing a practical tool for managing team roles effectively.
* Day 269: 🏥 Medical Cost Personal Datasets Analysis 

  Today, I worked on analyzing the Medical Cost Personal Datasets from Kaggle using Python. The focus was on data exploration, feature engineering, and visualization using various libraries such as Pandas, NumPy, Seaborn, and Matplotlib. Below are the key highlights:

  - **Data Loading and Inspection**: 
    - The project begins with loading the dataset using Pandas. We perform an initial inspection to understand the structure and columns of the dataset. This involves checking for null values, data types, and basic statistics.
    - Sample rows from the dataset are displayed to get a quick view of the data.

  - **Statistical Summary**:
    - A function is created to generate a statistical summary of numerical variables, providing insights such as mean, median, standard deviation, minimum, and maximum values. This helps in understanding the central tendency and spread of the data.
    - Descriptive statistics for categorical variables (e.g., region, sex, and smoker status) are also included to gain insights into their distribution.

  - **Exploratory Data Analysis (EDA)**:
    - Visualization of numerical distributions using histograms to detect skewness, outliers, and normality.
    - Box plots are used to visualize distributions across different categories and to detect outliers in the data.
    - The dataset is further analyzed with Seaborn to visualize relationships between variables. Pair plots are used to see scatter plots for numerical variables and to quickly grasp the correlation between them.
    
  - **Categorical Analysis**:
    - Distribution of categorical variables is visualized using bar graphs. This approach allows us to see the frequency of different categories (e.g., smoker status, region) and provides insights into patterns such as healthcare costs across different demographics.

  - **Correlation Analysis**:
    - A correlation matrix is generated to understand relationships between numerical variables. This is visualized using a heatmap to enhance readability and clarity.
    - Insights from the correlation matrix guide further feature engineering and understanding of factors affecting medical costs.

  - **Feature Engineering**:
    - Based on the initial insights from EDA, new features are engineered. For example, BMI (Body Mass Index) is calculated and analyzed in relation to medical costs.
    - The impact of factors such as age, sex, smoking status, and region on healthcare costs is examined.

  - **Modular Analysis Functions**:
    - The project includes functions that allow for easy execution of the analysis. This includes functions to generate the full report, visualize distributions, and check for correlations.
    - The use of modular functions enhances code readability and maintainability.

  This project reinforced the importance of data visualization and feature engineering in understanding complex datasets. It also emphasized the value of modular code for easy maintenance and scalability in data science projects.
* Day 270: Pose Estimation Project with Python 🤖

  Today, I worked on a Pose Estimation project using Python, leveraging the power of MediaPipe and OpenCV. The project focuses on real-time human pose detection from video files, providing visual feedback in the form of landmarks and connections between key points. Below are the key highlights:

  - **Pose Detection**: The system utilizes MediaPipe's Pose module to detect human body landmarks in real-time. It processes each frame of the video to identify and visualize key points such as shoulders, elbows, wrists, hips, knees, and ankles.

  - **Modular Design**: The project is structured into multiple modules:
    - `Basics.py`: This module handles the main functionality of reading video input and displaying detected poses.
    - `PoseModule.py`: Contains the `PoseDetector` class, which encapsulates the logic for pose detection and landmark processing.
    - `Test.py`: Serves as the entry point for testing the pose detection functionality with a selected video file.

  - **User Interaction**: The application allows users to select video files via a graphical user interface (GUI) using `tkinter`. This enhances usability by providing an intuitive way to load videos for processing.

  - **Real-Time Visualization**: Detected landmarks are visualized on the input video frames with circles drawn around each landmark. Additionally, connections between landmarks can be displayed to illustrate the skeletal structure of the detected pose.

  - **FPS Calculation**: The system calculates and displays frames per second (FPS) in real-time, providing insights into the performance of the pose detection algorithm during video playback.

  - **Landmark Data Export**: Users have the option to save detected landmark positions to a CSV file for further analysis or record-keeping. This feature is useful for applications in sports science, physical therapy, and motion analysis.

  - **Documentation and Code Quality**: The code is well-documented with comments explaining each section and function. This ensures that future developers can easily understand and extend the functionality of the project.

  This project was an excellent opportunity to apply my knowledge of computer vision and machine learning in a practical context. I gained valuable experience working with MediaPipe for pose estimation and learned how to structure a Python application in a modular way. Overall, this project showcases my ability to integrate different technologies to create a functional tool for real-time human pose analysis.
* Day 271: Technical Test "numTrees" and "isInterleave" [LeetCode](https://leetcode.com/problems/)

  - **numTrees**: Implemented a solution for the "Unique Binary Search Trees" problem, which requires calculating the number of structurally unique BSTs that can be formed with `n` nodes, where each node has a unique value from 1 to `n`. The solution utilizes dynamic programming to build a table that counts the unique trees based on previously computed values. The time complexity of this approach is \(O(n^2)\), making it efficient for reasonable values of `n`.
    [Problem Description: numTrees](https://leetcode.com/problems/unique-binary-search-trees/description/)

  - **isInterleave**: Developed a solution for the "Interleaving String" problem, which checks if a string `s3` can be formed by interleaving two other strings `s1` and `s2`. The approach employs dynamic programming to create a table that tracks whether substrings of `s1` and `s2` can form substrings of `s3`. The time complexity is \(O(n \times m)\), where `n` and `m` are the lengths of `s1` and `s2`, respectively.
    [Problem Description: isInterleave](https://leetcode.com/problems/interleaving-string/description/)