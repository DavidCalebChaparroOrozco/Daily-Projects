# Daily-Projects
This repository contains my daily projects, challenging me to create something new every day. From small utilities to full-fledged applications, they reflect my growth as a developer. Each project has a brief description of technologies, challenges and lessons. It is a record of my progress and a constantly evolving portfolio.
* Day 01:  Polar Plots in Python with Matplotlib by Neural Nine
  * Today we learn how to work with polar coordinates and how to create polar plots in Python using Matplotlib.
* Day 02: Spotify Oldies Dataset 🎶: A Treasury of Classics [Kaggle](https://www.kaggle.com/datasets/kanchana1990/spotify-oldies-dataset/data)
  * Today I'm going to work with a dataset called Spotify Oldies Dataset: A Treasury of Classics.
* Day 03: Pomodoro Timer GUI
  * In this project, I developed a graphical user interface (GUI) for a Pomodoro Timer using Tkinter in Python. The Pomodoro Technique is a time management method that uses a timer to break down work into intervals, traditionally 25 minutes in length, separated by short breaks. This GUI application allows users to start, reset, and skip timers for Pomodoro sessions, short breaks, and long breaks, providing visual feedback on the remaining time for each interval. It serves as a practical tool for enhancing productivity and focus during work or study sessions.
* Day 04: To Do App
  * Today, I created a To Do application using Flask and SQLAlchemy. This app allows users to add, edit, and delete tasks, as well as mark them as completed or in progress. Users can also search and filter tasks by various criteria such as title, completion status, priority, and due date. Additionally, the app supports sorting tasks by ID, title, or completion status, and offers bulk actions to mark tasks as completed, in progress, or not completed. It's a simple yet practical tool for managing daily tasks efficiently.
* Day 05: ContactManager
  * This project involves creating a contact manager application using Python's Tkinter library. The ContactManager allows users to add, edit, view, and delete contacts. It provides features such as pagination, searching, importing/exporting contacts from/to CSV files, and input validation for contact details. It offers a user-friendly interface for managing contact information effectively.
* Day 06: Income Prediction Adult Income [Kaggle](https://www.kaggle.com/datasets/wenruliu/adult-income-dataset)
  * In today's project, I implemented a machine learning model to predict adult income using the Adult Income dataset. The dataset contains various demographic and employment-related features such as age, education level, occupation, and work hours per week, along with the target variable indicating whether an individual earns more than $50,000 annually. I utilized the Random Forest algorithm to train the model and extracted feature importance scores to identify the key factors influencing income prediction. The model achieved an accuracy of  0.86%, demonstrating its capability to classify individuals into different income groups. This project enhances my understanding of supervised learning techniques and their application in real-world scenarios.
* Day 07: Pokedex GUI Application
  * In this project, I developed a graphical user interface (GUI) application for a Pokedex using Python's Tkinter library. The Pokedex is a digital encyclopedia that catalogues information about different species of Pokémon, a popular franchise of fictional creatures.
* Day 08: Flet Chat Application
  * Created a chat application using Flet library in Python. This application allows users to join a chat room, send and receive messages in real-time. It features a graphical user interface (GUI) for displaying chat messages, input field for sending messages, and user authentication. The application utilizes Flet components for UI design and integrates functionalities for sending, receiving, and displaying messages efficiently. It serves as a practical tool for real-time communication and collaboration among users.
* Day 09: Video Game Sales [Kaggle](https://www.kaggle.com/datasets/gregorut/videogamesales/data)
  * Today's project delves into the world of video game sales analysis. Leveraging the Video Game Sales dataset from Kaggle, I explore trends and patterns in the gaming industry. This dataset contains information on video game sales across different platforms, regions, genres, and years, providing valuable insights into consumer preferences and market dynamics. Through data exploration, visualization, and potentially predictive modeling, I aim to uncover hidden gems and understand what makes a successful video game title. Stay tuned for the journey through pixels and polygons! 🎮✨
* Day 10: Summarize News Articles
  * Worked on a project to summarize news articles using web scraping and natural language processing libraries like newspaper3k and TextBlob.
* Day 11: Sudoku Solver
  * In this project, I've crafted a Sudoku solver leveraging the backtracking algorithm in Python. This application empowers users to input incomplete Sudoku puzzles, generating a valid solution for the board. To enhance user experience, I integrated the Tkinter graphical library to craft an interactive interface. Through this interface, users can input Sudoku numbers and witness the solution unfold step by step. This project not only offers an efficient solution for Sudoku puzzles but also serves as an educational tool to delve into backtracking algorithms and Python-based interactive user interfaces.
* Day 12: Snake Pygame
  * In today's project, I built a classic Snake game using Pygame, a popular Python library for creating 2D games. The Snake game is a timeless arcade classic where the player controls a snake that moves around the screen, eating food to grow longer while avoiding collisions with itself and the boundaries of the game area.
* Day 13: Titanic Dataset 🚢 [Kaggle](https://www.kaggle.com/c/titanic)
  * Today, we delve into the exciting world of data analysis with the famous Titanic dataset. This dataset, available on Kaggle, provides information about the passengers aboard the Titanic, including details such as age, gender, ticket class, fare paid, and more. Our task is to explore this dataset, understand its key features, and possibly develop predictive models to determine the likelihood of a passenger's survival based on various factors. Through this project, we will not only enhance our data analysis skills but also honor the memory of the Titanic passengers by extracting meaningful insights from this historic dataset.
* Day 14: Email Python
  * Today's project involves creating a Python script for sending automated emails. Leveraging libraries such as smtplib, schedule, and dotenv, we develop a script capable of sending daily inspirational emails to a specified email address. The script reads quotes from a file, selects a random quote, and sends it via SMTP protocol. Utilizing environment variables for storing email credentials ensures security and flexibility. By scheduling the script to run periodically using the schedule library, we automate the process of sending daily inspiration to recipients, fostering motivation and positivity. This project not only demonstrates practical use cases of Python for automation but also serves as a reminder of the power of uplifting messages in our daily lives.
* Day 15: Guess the Number
  * Today's project involves creating a number guessing game using Python's Tkinter library for building the graphical user interface (GUI). The game prompts the player to guess a randomly generated number between 1 and 99 within a limited number of attempts. Through input validation and dynamic feedback, the game guides the player to adjust their guesses until they either correctly identify the number or exhaust their attempts. This project not only showcases interactive GUI development with Tkinter but also reinforces concepts of random number generation, user input handling, and game logic implementation. It provides an entertaining and engaging experience for players while honing programming skills in Python. Can you beat the odds and guess the secret number? Let the guessing game begin! 🎲
* Day 16: Virtual Bookshelves
  * In this project, I'll create a virtual bookshelf management system using Python and SQLite. The application will allow users to add, remove, update, and view books in their virtual bookshelves. Each book will have attributes such as title, author, year published, and genre. The system will utilize SQLite for database management and provide a user-friendly interface for interacting with the bookshelves. This project aims to simulate real-world bookshelf management scenarios and provide users with a convenient way to organize their reading materials. Let's embark on the journey of building virtual bookshelves to enhance our reading experiences! 📚✨
* Day 17: RSS Feed Reader
  * In this project, I'll develop an RSS feed reader using Python and BeautifulSoup. The RSS feed reader will be capable of fetching and parsing RSS feeds from various sources. It will extract relevant information such as titles, descriptions, and links from the feeds, presenting them in a user-friendly format. By implementing this RSS feed reader, I aim to enhance my skills in web scraping, XML parsing, and data presentation. Stay tuned for an efficient tool to stay updated with the latest news and content from your favorite websites! 📰🚀
* Day 18: Customer Manager JSON
  * In this project, I've developed a customer management system using Python and JSON. The system allows users to store and manage information about customers, including names, email addresses, cities, etc. It implements functionalities such as searching for customers by name, updating contact information, deleting customers, and adding new customers. Leveraging JSON as the data storage format ensures portability and simplicity in data management. This project enhances my skills in file handling, data manipulation, and user interface design. It serves as a practical tool for organizing customer data efficiently and facilitating effective communication and interaction with clients. Let's embark on the journey of customer management and streamline the process of customer engagement! 📊👥
* Day 19: Expense Tracking App
  * Created an expense tracking application using Python's Tkinter library. This app allows users to record their expenses, including item name, price, and purchase date. Users can add, edit, delete, and view expense records, providing a convenient way to manage their finances. Additionally, the app calculates the total expense and remaining balance, offering insights into spending habits. It serves as a practical tool for budgeting and financial management. 📊💰
* Day 20: Hangman
  * Implemented the classic Hangman game using Python and Flask. Players can guess letters to reveal a hidden word within a limited number of attempts. The game features a user-friendly interface and supports error handling for invalid inputs. Test your vocabulary and strategic thinking in this timeless word-guessing challenge! 🎩🔤
* Day 21: Image Editor
  * In this project, I developed an image editor using Python and Tkinter. The Image Editor allows users to open image files, apply filters such as black and white, blur, sharpen, and more, flip and rotate images, draw lines over the images, change pen color, erase drawn lines, and save edited images. It provides a user-friendly interface for basic image editing tasks and serves as a practical tool for enhancing and modifying images. Let your creativity flow with the Image Editor! 🎨🖼️
* Day 22: Faker User
  * In this project, I utilized the Faker library in Python to generate synthetic user data. From names and email addresses to phone numbers and job titles, Faker User creates realistic user profiles effortlessly. Whether for testing, prototyping, or data augmentation, Faker User streamlines the process of generating diverse and customizable datasets.
* Day 23: Simple Stock Price (Steamlit)
  * Today's project revolves around creating a Simple Stock Price application using Streamlit. This application enables users to visualize stock price data, including closing prices, volume, and candlestick charts, for various companies. Leveraging the yfinance library, the app fetches historical stock data and presents it in an interactive and user-friendly manner. Users can select a company from a dropdown menu, view different metrics, and analyze performance metrics such as returns, volatility, and Sharpe ratio. With its intuitive interface and insightful visualizations, this project serves as a valuable tool for investors and enthusiasts alike to track and analyze stock market trends.
* Day 24: Quality Of Wine [Kaggle](https://www.kaggle.com/datasets/uciml/red-wine-quality-cortez-et-al-2009)
  * Exploring the quality of wine dataset from Kaggle, I aim to analyze factors influencing the quality of red wine. Leveraging data analysis and visualization techniques, I seek to uncover patterns and relationships among various chemical properties and wine quality ratings. By applying machine learning algorithms, I intend to develop predictive models to classify wine quality based on its attributes. This project provides insights into the intricate world of wine quality assessment and demonstrates the application of data science in the domain of viticulture. Cheers to discovering the essence of fine wine! 🍷📊
* Day 25: Extract Dominant Colors
  * In this project, I'll delve into the fascinating realm of image processing to extract the dominant colors from images. Utilizing Python libraries such as ColorThief and Matplotlib, I'll develop a script capable of identifying the primary colors present in an image. By analyzing color palettes and visualizing dominant hues, this endeavor aims to provide insights into the aesthetic composition of images. Join me as I explore the vibrant spectrum of colors and uncover the beauty hidden within digital imagery. 🎨🖼️
* Day 26: Tree Node
  * On day 26, I focused on the implementation of a fundamental data structure, the tree node. Through Python, I constructed a TreeNode class capable of representing nodes within a binary search tree. With the aid of methods like insertion and various traversal techniques (preorder, inorder, and postorder), I delved into the intricacies of managing and navigating through binary trees. This exploration lays the groundwork for comprehending more complex tree-based algorithms and data structures, providing a solid foundation for further study in computer science and programming. 🌳🔍
* Day 27: ML with FastAPI
  * Today we learn how to easily turn machine learning models into usable APIs using FastAPI in Python.
* Day 28: Tutorial Guide (Python Types Intro) [FastAPI](https://fastapi.tiangolo.com/python-types/)
  * On day 28, we delve into an essential aspect of Python programming - types. This tutorial guide provides an introduction to Python types, focusing particularly on their usage within the FastAPI framework. Understanding Python types is crucial for developing robust and maintainable code, and integrating this knowledge with FastAPI facilitates the creation of efficient and scalable web APIs. By exploring the intricacies of Python types within the context of FastAPI, we equip ourselves with powerful tools for building robust and type-safe applications. 🐍✨
* Day 29: Parking Space Counter
  * We implemented a parking space counter application using Python and OpenCV. This project enables users to define parking spaces on an image, count full and empty parking spots, and visualize the counts in real-time. The application leverages computer vision techniques to identify parking space boundaries and utilizes event handling to interactively mark full and empty spaces. This project serves as a practical example of applying Python and OpenCV for image processing and computer vision tasks, demonstrating their utility in real-world applications such as parking management systems. 🅿️🚗🅿️
* Day 30: [TensorFlow](https://www.tensorflow.org/tutorials/keras/classification) Guide (Beginner ~ ML Basics with Keras)
  * Explore the fundamentals of machine learning with TensorFlow and Keras in this beginner's guide. This guide provides a comprehensive overview of TensorFlow, a powerful open-source machine learning framework developed by Google. Through practical examples and step-by-step tutorials, you'll learn how to build and train neural networks using Keras, a high-level neural networks API that runs on top of TensorFlow. From basic concepts to hands-on implementation, this guide is designed to introduce you to the essentials of machine learning and empower you to start building your own ML models with TensorFlow and Keras. 🤖📚🔍
* Day 31: Spam Emails Dataset [Kaggle](https://www.kaggle.com/datasets/venky73/spam-mails-dataset/code)
  * We explored a Spam Emails Dataset available on Kaggle. This dataset contains a collection of emails labeled as spam or ham (not spam). Leveraging this dataset, we embarked on a data analysis and preprocessing journey using Python and pandas. Through this process, we gained insights into the structure of the data and performed necessary preprocessing steps to prepare it for machine learning tasks. By delving into real-world data and preparing it for analysis, we honed our data manipulation and preprocessing skills, essential for any data science or machine learning project. 📧🔍🛠️
* Day 32: Dijkstra's Algorithm Implementation
  * We implemented the Dijkstra algorithm, which is a design algorithm used to find the shortest path between nodes in a graph. The implementation is made in Python and uses a linear array to precisely search the graph and calculate the shortest distance from the starting point to all other points. Dijkstra's algorithm is widely used in a variety of applications, including network protocol routing  and  video game routing. By applying this algorithm, we increased 's design understanding  and strengthened our algorithmic problem-solving skills. 📈🔍💡
* Day 33: Technical Test "Add Two Numbers" and "FizzBuzz" [LeetCode](https://leetcode.com/problems/)
  * Add Two Numbers: We tackled the "Add Two Numbers" problem from LeetCode, which involves adding two non-empty linked lists representing non-negative integers. The digits are stored in reverse order, and each node contains a single digit. We implemented a Python solution that traverses both linked lists simultaneously, summing the corresponding digits and handling any carry. This problem enhances our understanding of linked list manipulation and problem-solving skills.
  [Problem Description](https://leetcode.com/problems/add-two-numbers/description/?source=submission-ac)
  
  * FizzBuzz: The second problem we solved was "FizzBuzz," also from LeetCode. This classic programming problem requires generating the FizzBuzz sequence up to a given number. We crafted a Python solution that iterates through the numbers from 1 to the given number, appending "Fizz" for multiples of 3, "Buzz" for multiples of 5, "FizzBuzz" for multiples of both 3 and 5, and the number itself if none of the conditions are met. This exercise reinforces our ability to write concise and efficient code to solve common programming challenges.
  [Problem Description](https://leetcode.com/problems/fizz-buzz/description/)
* Day 34: Quicksort
  * We implemented Quicksort, a divide-and-conquer algorithm used for sorting arrays or lists. Quicksort selects a pivot element, partitions the other elements into two sub-arrays based on whether they are less than or greater than the pivot, and recursively sorts the sub-arrays. Known for its efficiency, Quicksort is often used as a benchmark for comparison with other sorting algorithms, enhancing our understanding of algorithmic efficiency and problem-solving skills. 🔄📊🔍
* Day 35: Live Weather Forecast Flask App
  * In today's project, we'll develop a live weather forecast Flask app. This app will take a city name as input and provide various weather characteristics such as temperature in Celsius and Fahrenheit, humidity, wind speed, and more.
* Day 36: Random Passwords Generator
  * Today, we created a Random Passwords Generator program. This program prompts the user to specify the desired length of the password and generates a strong password consisting of a mix of lowercase and uppercase letters, digits, and special characters. Additionally, we implemented a function to save the generated passwords to a CSV file for later use. This project enhances our understanding of string manipulation, random number generation, and file handling in Python, while also providing practical utility by creating a tool for generating secure passwords. 🔒💡💻
* Day 37: Site Connectivity Checker
  * Today, we developed a Site Connectivity Checker application using Flask. This application allows users to input a URL and checks its connectivity by sending a request to the specified website. We enhanced the functionality by adding URL validation, error handling for various connection issues, and logging of activity to track the status of site connections over time. By building this project, we gained practical experience in web development with Flask, handling HTTP requests, error management, and logging, all of which are essential skills for creating robust web applications. 🌐🔍🚀
* Day 38: Heart Attack Analysis & Prediction Dataset [Kaggle](https://www.kaggle.com/datasets/rashikrahmanpritom/heart-attack-analysis-prediction-dataset/data)
  * We explored the Heart Attack Analysis & Prediction Dataset available on Kaggle. This dataset provides valuable insights into factors contributing to heart attacks and includes various health parameters such as age, sex, cholesterol levels, blood pressure, and more. By analyzing this dataset, we aim to gain a deeper understanding of the relationships between different risk factors and the likelihood of a heart attack occurrence. Leveraging statistical analysis and machine learning techniques, we strive to develop predictive models that can assist in early detection and prevention efforts for cardiovascular diseases. This project underscores the importance of data-driven approaches in healthcare and reinforces our skills in data analysis, predictive modeling, and domain knowledge application. ❤️📊🔬
* Day 39: [TensorFlow](https://www.tensorflow.org/tutorials/keras/classification) Guide Basic text Classification (Beginner ~ ML Basics with Keras)
  * Continuing from Day 30, delve deeper into machine learning with TensorFlow and Keras by exploring basic text classification. In this guide, you'll learn how to apply machine learning concepts to classify text data using TensorFlow and Keras. By following step-by-step tutorials and practical examples, you'll understand the fundamentals of text classification, including preprocessing text data, building neural network models, and evaluating model performance. Whether you're new to machine learning or looking to expand your knowledge, this guide provides valuable insights and hands-on experience to enhance your skills in natural language processing and text classification tasks. 🤖📚🔍
* Day 40: Technical Test "Minimum Height Trees" and "Zigzag Conversion" [LeetCode](https://leetcode.com/problems/)
  * Minimum Height Trees: Today, we encountered the "Minimum Height Trees" problem on LeetCode. This problem revolves around identifying the roots of minimum height trees in an undirected graph, given the number of nodes and an array of edges representing connections between nodes. We crafted a Python solution employing graph traversal and manipulation techniques to determine the roots with minimum height efficiently. This challenge enhances our ability to work with graphs, analyze graph structures, and devise optimal algorithms for graph-related problems. [Problem Description](https://leetcode.com/problems/minimum-height-trees/description/)
  * Zigzag Conversion: In addition, we tackled the "Zigzag Conversion" problem on LeetCode. This problem involves converting a given string into a zigzag pattern with a specified number of rows and then reading the string line by line. We devised a Python solution that constructs the zigzag pattern by iteratively placing characters in the appropriate rows, simulating the pattern formation and reading process. Solving this problem reinforces our understanding of string manipulation techniques and enhances our problem-solving skills in handling complex pattern-based challenges. [Problem Description](https://leetcode.com/problems/zigzag-conversion/description/)
* Day 41: Tkinter - Map View
  * Explore Tkinter's capabilities in displaying interactive maps with the Tkinter MapView project. This Tkinter-based application allows users to visualize maps, search for addresses, and adjust zoom levels seamlessly within a GUI interface. By integrating functionalities such as address lookup, zoom control, and map display, this project showcases the potential of Tkinter for creating dynamic and user-friendly applications. Dive into the world of Tkinter and enhance your skills in GUI development with the MapView project. 🗺️🖥️🔍
* Day 42: Tkinter - Digital Clock
  * Explore the world of GUI development with Tkinter by creating a digital clock application. In this project, I utilized Tkinter's functionalities to design an attractive and functional digital clock interface. By leveraging Python's time module and Tkinter's Label widget, I implemented a dynamic clock display that updates in real-time. Join me as I continue to delve into Tkinter and expand my skills in creating intuitive and visually appealing graphical user interfaces. ⏰🖥️🔧
* Day 43: PySpark (Quickstart: DataFrame)[https://spark.apache.org/docs/3.3.1/api/python/getting_started/quickstart_df.html]
  * Dive into the world of big data processing with PySpark as we explore the Quickstart guide for DataFrames. PySpark is a powerful tool for processing large-scale datasets using the Apache Spark framework. In this project, we'll delve into the basics of working with DataFrames, a distributed collection of data organized into named columns. By following the Quickstart guide, we'll learn how to create, manipulate, and analyze DataFrames efficiently. Join me on this journey as we harness the power of PySpark to tackle big data challenges with ease and scalability. 🚀💻🔍
* Day 44: Daily Routine with Desktop Notifications
  * In this project, I crafted a personalized daily routine assistant utilizing desktop notifications. Leveraging Python libraries such as `win10toast` and `schedule`, I created a system that sends timely notifications for various activities throughout the day. Whether it's studying English, working on Python projects, taking short breaks, or even enjoying a joke break, this routine keeps me organized and on track. By scheduling notifications at specific times using the schedule module, I ensure I stay productive and maintain a healthy balance between work and relaxation. Join me as I automate my daily routine and optimize my productivity with desktop notifications! 📅⏰🖥️
* Day 45: Language Detection
  * Enhancing my text processing capabilities, I delved into language detection. Leveraging the langdetect and langcodes libraries in Python, I developed a program capable of identifying the language of input text. By utilizing the powerful language detection algorithms provided by these libraries, I crafted a user-friendly interface using Tkinter. This project allows users to input text and receive instant feedback on the detected language, aiding in various applications such as multilingual text analysis, translation services, and content filtering. Join me as I explore the fascinating world of language detection and broaden the scope of text processing possibilities! 🌐🔍📝
* Day 46: Technical Test "MedianSortedArrays" and "lengthOfLongestSubstring" [LeetCode](https://leetcode.com/problems/)
  * MedianSortedArrays: Today, we encountered the "Median of Two Sorted Arrays" problem on LeetCode. This problem involves finding the median of two sorted arrays, which are of different sizes, m and n. The challenge is to achieve a time complexity of O(log(m+n)). We tackled this problem by employing the binary search approach. By partitioning the arrays and comparing elements at partition points, we efficiently determine the median. Solving this problem enhances our understanding of algorithmic complexity and binary search techniques, crucial for tackling similar problems efficiently. [Problem Description](https://leetcode.com/problems/median-of-two-sorted-arrays/)

  * lengthOfLongestSubstring: In addition, we tackled the "Longest Substring Without Repeating Characters" problem on LeetCode. This problem requires finding the length of the longest substring within a given string that does not contain any repeating characters. We approached this problem using a sliding window technique, which allows us to efficiently traverse the string while keeping track of the characters encountered. By updating the window's boundaries based on repeating characters, we determine the longest substring without repetition. Solving this problem enhances our understanding of string manipulation and sliding window algorithms, essential for solving various string-related challenges. [Problem Description](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)
* Day 47: Currency Converter
  * Today, I embarked on a journey to create a currency converter application using Python. Leveraging the tkinter library for graphical user interface (GUI) development and the forex_python library for currency conversion functionality, I crafted a simple yet effective tool for converting between different currencies. This project involved setting up dropdown menus for selecting the source and target currencies, implementing an entry widget for inputting the amount to convert, and integrating a button to trigger the conversion process. By handling exceptions and displaying conversion results dynamically, I ensured a smooth user experience. Join me as I explore the world of currency conversion and develop a handy tool for everyday use! 💱💼🔀
* Day 48: Perceptron
  * In today's project, I delved into the world of artificial neural networks by implementing a perceptron from scratch. The perceptron, a fundamental building block of neural networks, is a simple algorithm capable of learning binary classifiers. Leveraging the NumPy library for numerical operations, I crafted a perceptron class capable of training on labeled datasets and making predictions. By defining the perceptron's architecture, including input features, weights, and activation functions, I gained insight into the inner workings of neural networks. Through iterative training and weight updates based on prediction errors, the perceptron learns to separate linearly separable classes in feature space. This project serves as a foundational step towards understanding more complex neural network architectures and their applications in machine learning and artificial intelligence. Join me as I explore the basic principles of neural networks and implement a perceptron algorithm from scratch! 🧠💻🤖
* Day 49: Technical Test "Reverse Integer" and "Longest Palindromic Substring" [LeetCode](https://leetcode.com/problems/)
  * Today's technical challenge involves the "Reverse Integer" problem on LeetCode. This problem requires reversing the digits of a signed 32-bit integer. If the reversed integer overflows, the function should return 0. We'll tackle this problem by implementing a solution that handles both positive and negative integers, considering overflow conditions carefully. Solving this problem enhances our skills in handling numerical operations and edge cases effectively. [Problem Description](https://leetcode.com/problems/reverse-integer/description/)
  * "Longest Palindromic Substring": Additionally, we'll tackle the "Longest Palindromic Substring" problem on LeetCode. This problem involves finding the longest palindromic substring within a given string. We'll devise an algorithm to efficiently determine the longest palindrome, leveraging techniques such as dynamic programming or expanding around centers. By addressing this challenge, we deepen our understanding of string manipulation and algorithmic problem-solving strategies. [Problem Description](https://leetcode.com/problems/longest-palindromic-substring/description/)
* Day 50: Students Performance in Exams [Kaggle](https://www.kaggle.com/datasets/whenamancodes/students-performance-in-exams/data)
  * Today, we delve into the realm of educational data analysis by exploring a student performance dataset from Kaggle. This dataset offers valuable insights into factors that may influence student achievement in exams. By delving into this data, we can uncover patterns, trends, and relationships that can inform educational practices and improve student learning outcomes.
* Day 51: Interactive Menu for YouTube and Web Searches
  * Today's focus is on creating a music player application. Building a music player involves integrating functionalities to play, pause, skip, and control the playback of audio files. Additionally, we'll explore features such as creating playlists, displaying metadata, and providing a user-friendly interface for an immersive music listening experience. By developing a music player, we deepen our understanding of GUI frameworks, multimedia handling, and software design principles.
* Day 52: Task Manager Performance
  * Today's task revolves around analyzing the performance of a task manager application. Task managers play a crucial role in monitoring system resources, managing processes, and optimizing performance. Through this analysis, we aim to evaluate the efficiency, responsiveness, and resource utilization of the task manager under various conditions. By examining performance metrics such as CPU usage, memory consumption, and task responsiveness, we can identify areas for improvement and enhance the overall functionality of the task manager application.
* Day 53: Technical Test "Integer to Roman" and "Container With Most Water" [LeetCode](https://leetcode.com/problems/)
  * Integer to Roman:
    Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M. Implement a function to convert an integer into its corresponding Roman numeral representation.
    Given an integer, convert it to a Roman numeral. [Problem Description](https://leetcode.com/problems/integer-to-roman/)
  * Container With Most Water: You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store. [Problem Description](https://leetcode.com/problems/container-with-most-water/description/)
* Day 54: Background Remove Flask
  * Today's focus is on implementing a background removal functionality within a Flask web application. Background removal is a crucial task in image processing and computer vision, allowing users to isolate subjects from their backgrounds. By integrating this functionality into a web application using Flask, we aim to provide users with a convenient and accessible tool for background removal tasks. Throughout this process, we'll explore techniques for image manipulation, integration of third-party libraries, and web development with Flask. By building a background removal tool, we enhance our understanding of image processing algorithms, web application development, and practical applications of computer vision technology.
* Day 55: Multiple Files Renamer
  * Today's focus is on developing a multiple files renamer application. Renaming multiple files in bulk is a common task, especially when organizing files or preparing them for specific purposes. This application will provide users with the ability to select a folder containing files, specify renaming criteria, and execute the renaming process efficiently. By creating this utility, we aim to streamline file management tasks and enhance productivity for users dealing with large numbers of files. Throughout the development process, we'll explore file handling techniques, user interface design, and implementation of renaming algorithms to ensure a robust and user-friendly application.
* Day 56: Technical Test "threeSum" and "threeSumClosest" [LeetCode](https://leetcode.com/problems/)
  Today's focus is on solving technical problems related to array manipulation and algorithmic thinking. We'll tackle two problems from LeetCode:
  * threeSum: Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j, i != k`, and `j != k, and nums[i] + nums[j] + nums[k] == 0`. The solution set must not contain duplicate triplets. [Problem Description](https://leetcode.com/problems/3sum/description/)
  * threeSumClosest: Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. [Problem Description](https://leetcode.com/problems/3sum-closest/description/)
* Day 57: KeyLogger 
  * Today's focus is on developing a KeyLogger application. A KeyLogger is a program that records the keystrokes made by a user on their computer. It's commonly used for various purposes such as monitoring employee activity, parental control, or debugging software. Our KeyLogger application will capture keystrokes and store them in a log file, providing users with the ability to monitor keyboard activity. Through this project, we'll delve into event handling, file I/O operations, and potentially explore additional features such as email notifications for logged keystrokes, enhancing the utility and versatility of the KeyLogger.
* Day 58: Matrix Effect
  * Today's focus is on creating a Matrix Effect, inspired by the iconic "Matrix" movie. This project involves generating a cascading effect of characters resembling the falling code seen in the film. Through this project, we'll explore concepts such as terminal manipulation, randomization, and animation. By implementing this Matrix Effect, we aim to recreate the visually stunning display seen in the movie, offering a fun and engaging coding exercise.
* Day 59: Dice-Rolling [realpython.com](https://realpython.com/python-dice-roll/#step-1-code-the-tui-of-your-python-dice-rolling-app)
  * Today's focus is on implementing a Dice-Rolling application. This project involves creating a Python program to simulate rolling dice. We'll explore concepts such as random number generation, user input validation, and ASCII art for visual representation of dice faces. Additionally, we'll delve into creating a text-based user interface (TUI) for the application. By developing this Dice-Rolling application, we aim to provide users with a fun and interactive way to simulate rolling dice, suitable for various gaming and recreational purposes.
* Day 60: Technical Test "letterCombinations" and "4Sum" [LeetCode](https://leetcode.com/problems/)
  * **Letter Combinations of a Phone Number**: Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. [Problem Description](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)
  * **4Sum**: Given an array `nums` of n integers, return an array of all the unique quadruplets `[nums[a], nums[b], nums[c], nums[d]]` such that:
     - `0 <= a, b, c, d < n`
     - `a, b, c, and d` are distinct.
     - `nums[a] + nums[b] + nums[c] + nums[d] == target`
  You may return the answer in any order. [Problem Description](https://leetcode.com/problems/4sum/)
* Day 61: Anemia Types Classification [Kaggle](https://www.kaggle.com/datasets/ehababoelnaga/anemia-types-classification/data)
  * Today, we focus on anemia types classification using a dataset from Kaggle. This dataset contains CBC (Complete Blood Count) data labeled with the diagnosis of anemia type, collected from several CBCs and diagnosed manually. By analyzing this dataset, we aim to understand the relationships between CBC parameters and different types of anemia. This analysis can provide valuable insights for medical diagnosis and treatment strategies.
* Day 62: Cinema Management System using OOP
  * Today, we delve into a cinema project focusing on Object-Oriented Programming (OOP). The project involves designing classes to simulate various aspects of a cinema system, including movies, rooms, reservations, and the cinema itself. Through this project, we aim to implement key OOP principles such as encapsulation, inheritance, and polymorphism. By structuring the code in an object-oriented manner, we can create a modular and scalable system that effectively models the functionalities of a real-world cinema. This project provides an excellent opportunity to practice OOP concepts while developing a practical application.
* Day 63: Technical Test "removeNthFromEnd" and "isMatch" [LeetCode](https://leetcode.com/problems/).
  * Today's technical test on LeetCode involves two problems:
  * removeNthFromEnd: Given the head of a linked list, remove the nth node from the end of the list and return its head. This problem challenges your ability to manipulate linked lists efficiently. [Problem Description](https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/)
  * isMatch: Implement regular expression matching with support for '.' and '*', where '.' matches any single character and '*' matches zero or more of the preceding element. The matching should cover the entire input string (not partial). [Problem Description](https://leetcode.com/problems/regular-expression-matching/description/).
  
  These problems test your proficiency in data structures and algorithms, particularly in linked list manipulation and dynamic programming. Working on them will enhance your problem-solving skills and algorithmic thinking.
* Day 64: Contour Plots in Matplotlib - Visualize 3D Functions in 2D [NeuralNine](https://www.youtube.com/watch?v=DYn9HdTmt0E)
  * In today's session, we explore how to create contour plots in Matplotlib, a powerful visualization tool in Python. Contour plots allow us to represent 3D functions in 2D, providing a clear view of the function's behavior over a plane. We will generate 2D grids using `numpy.meshgrid` and define various 3D functions to visualize. The session includes creating both surface plots and filled contour plots using Matplotlib's `plot_surface` and `contourf` functions, respectively. This exercise will help you understand how to effectively visualize complex functions, enhancing your data presentation skills and making your plots more informative and visually appealing.
* Day 65: Technical Test "isValidParentheses" and "MergeTwoSortedLists" [LeetCode](https://leetcode.com/problems/).
  * isValidParentheses: Given a string `s` containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if:
      * Open brackets must be closed by the same type of brackets.
      * Open brackets must be closed in the correct order.
      * Every close bracket has a corresponding open bracket of the same type. 
      [Problem Description](https://leetcode.com/problems/valid-parentheses/description/)
  * MergeTwoSortedLists: Given the heads of two sorted linked lists `list1` and `list2`, merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. [Problem Description](https://leetcode.com/problems/merge-two-sorted-lists/description/)
* Day 66: Web Scraping Job Listings with Python
  * In today's session, we delve into the world of web scraping using Python. Our goal is to extract job listings from the Python.org jobs page and save the data into a CSV file. We will use the `requests` library to fetch the HTML content of the webpage and `BeautifulSoup` for parsing the HTML and extracting the job details. The details we will extract include the job title, company name, location, posting date, and job type. After extracting the data, we will write it into a CSV file using Python's `csv` module. This exercise will enhance your skills in web scraping, data extraction, and handling CSV files, providing a practical approach to gather and organize data from web sources.
* Day 67: [TensorFlow](https://www.tensorflow.org/tutorials/keras/regression) Regression (Beginner ~ ML Basics with Keras)
  * Today, we embark on a journey into the basics of regression analysis using TensorFlow and Keras. This tutorial covers the essential steps to build, train, and evaluate regression models. We will start by loading and cleaning the Auto MPG dataset, which includes features like 'Horsepower', 'Weight', and 'Acceleration'. After preprocessing the data, we'll split it into training and testing sets, and normalize it to improve model performance. You'll learn how to construct simple linear regression models, first with a single input and then with multiple inputs. Furthermore, we'll explore more complex models using deep neural networks (DNNs). This hands-on guide will help you understand the fundamentals of regression analysis, model training, evaluation, and making predictions, providing a strong foundation in machine learning with TensorFlow and Keras. 🚗📈🤖
* Day 68: Recursion "SierpinskiTriangle" and "FractalTree".
  * On day 68, we explore the concept of recursion through the creation of two classic fractals: the Sierpinski Triangle and the Fractal Tree. Both examples utilize Python's turtle graphics library to visualize the recursive processes.
    * Sierpinski Triangle: This fractal is formed by recursively subdividing an equilateral triangle into smaller triangles. Each subdivision step reduces the size of the triangles and changes their color based on the recursion depth. This exercise helps in understanding how recursion can break down complex problems into simpler, repeatable tasks.
    * Fractal Tree: This fractal simulates the natural growth patterns of a tree. Starting with a trunk, the tree branches into smaller sub-branches, each at a specific angle and length decrement. By adjusting the recursion depth, angle, and length decrement, different tree shapes and complexities can be generated. This project emphasizes the power of recursion in modeling natural phenomena and visualizing algorithmic patterns.
* Day 69: Ticket management GUI
  * On day 69, we delve into building a web-based Ticket Management System using Flask. This project includes two primary interfaces: one for clients to generate tickets for order claims, and another for providers to manage and track the tickets. The client-side allows users to enter their name, generate a ticket with a unique number, and record the time of generation. The provider-side interface displays the next ticket in the queue along with the current ticket being attended to and which counter is handling it. This system demonstrates the basics of web development with Flask, including form handling, data storage, and dynamic content rendering. By completing this project, you will gain practical experience in creating web applications, managing state, and ensuring smooth interactions between different user roles. 🧾🖥️✨
* Day 70: Scientific GUI Calculator
  * On day 70, we constructed a Graphical User Interface (GUI) for a scientific calculator using the tkinter library in Python. This calculator provides a wide range of mathematical functions, including basic arithmetic operations, trigonometric functions, logarithmic functions, and more. Users can input numerical values, perform calculations, and view results conveniently through the intuitive interface. The calculator's design incorporates various buttons for different mathematical operations, making it easy to use and navigate. By creating this project, you will enhance your skills in GUI development, event handling, and integrating complex mathematical operations into user-friendly applications. 🧮💻🔍
* Day 71: Technical Test "generateParenthesis" and "mergeKLists" [LeetCode](https://leetcode.com/problems/).
  * generateParenthesis: Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
  [Problem Description](https://leetcode.com/problems/generate-parentheses/description/)
  * mergeKLists: You are given an array of `k` linked-lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.[Problem Description](https://leetcode.com/problems/merge-k-sorted-lists/description/)
* Day 72: Knight's Tour Problem Solver
  * On day 72, we explore the classic Knight's Tour problem using Python. This project involves developing an algorithm to find a sequence of moves that allows a knight to visit every square on an N x N chessboard exactly once. The solution employs backtracking to systematically search for a valid tour, ensuring that all board positions are covered without repetition. The implementation includes functions to validate moves, print the board, and recursively attempt to solve the tour from a given starting position. By tackling this problem, you will gain a deeper understanding of recursion, backtracking, and algorithmic problem-solving. This project is an excellent exercise in enhancing your skills in algorithm development and Python programming. ♞📐💡
* Day 73: Tic-Tac-Toe Multiplayer [NeuralNine](https://youtu.be/s6HOPw_5XuY?si=ZlnrpRTxmJiYtGv8)
  * On day 73, we developed a multiplayer Tic-Tac-Toe game using Python. This project allows two players to connect over a network and play Tic-Tac-Toe in real-time. One player hosts the game, while the other player connects to it. The implementation includes setting up a server-client architecture using the socket library and managing game state and turns through a combination of functions for move validation, board updates, and win condition checks. The game uses threading to handle simultaneous communication between players. By completing this project, you will enhance your understanding of network programming, client-server communication, and basic game development in Python. 🎮🕹️💻
* Day 74: Technical Test "twoSum" and "myAtoi" [LeetCode](https://leetcode.com/problems/).
  * twoSum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.
  [Problem Description](https://leetcode.com/problems/two-sum/description/)
  * myAtoi: Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer. The function follows a specific algorithm to ignore leading whitespace, determine the sign, read digits, and handle integer overflow by clamping the result within the 32-bit signed integer range.
  [Problem Description](https://leetcode.com/problems/string-to-integer-atoi/description/)
* Day 75: Spotify Songs Album [Kaggle](https://www.kaggle.com/datasets/zeesolver/spotfy/data)
  * Today, we embark on a journey into the realm of music data analysis with a dataset sourced from Kaggle, focusing on Spotify songs albums. This dataset provides a comprehensive collection of information about various songs, including attributes such as danceability, energy, and acousticness. By delving into this dataset, we aim to uncover intriguing insights into the characteristics of popular songs, trends in music streaming, and the impact of different attributes on song popularity. Through exploratory data analysis and visualization techniques, we will unravel patterns, correlations, and unique features within the dataset, shedding light on the dynamic landscape of the music industry. Join us as we dissect this rich dataset to discover the rhythms and melodies that shape our musical experiences.
* Day 76: Bank Queue Management System
  * Today, we delve into the development of a robust bank queue management system designed for "Su ahorrito". This system aims to streamline the process of managing customer service operations, focusing on assigning and managing customer turns efficiently. Our system encompasses several key functionalities:
    - User Management: Create and manage user profiles, including user ID, name, and client type (General, Preferential1, Preferential2).
    - Turn Assignment: Automatically assign turns to users, categorizing each turn with a specific transaction type (Deposit, Withdrawal, Bill Payment).
    - Customer Service: Facilitate the process of attending to customers, ensuring that completed transactions are recorded and stored systematically.
    - Transaction Analysis: Calculate and display the percentage distribution of different transaction types, providing insights into customer needs and service trends.
    - Turn Management: Enable the removal of specific turns and display the number of turns assigned to each user.
    - Transaction History: Maintain and showcase a history of all completed transactions, ensuring transparency and record-keeping.
Through this project, we aim to enhance the efficiency of customer service in a banking environment by leveraging Python to build an intuitive and effective queue management system. Join us as we implement and explore this essential application, ensuring a smoother experience for both bank staff and customers.
* Day 77: Inventory Management GUI
Today, we embarked on the development of a Graphical User Interface (GUI) for an Inventory Management System. Leveraging the Flask web framework in Python, we crafted an intuitive interface that enables users to efficiently manage their inventory of products. The system offers a range of features to enhance inventory control and streamline operations, including:
  - **Product Management:** Users can easily add, edit, and delete products from the inventory, facilitating seamless product catalog management.
  - **Real-time Inventory Monitoring:** The application provides a comprehensive view of the current inventory status, allowing users to track product quantities and make informed decisions.
  - **Report Generation:** With built-in reporting capabilities, users can generate detailed reports on inventory status, product performance, and more, empowering data-driven decision-making.
  - **Low Stock Alerts:** The system automatically alerts users to products with low stock levels, helping prevent stockouts and optimize inventory replenishment.
  - **Data Export:** Users can export inventory data to CSV or Excel formats for further analysis or integration with external systems.

  By developing this Inventory Management GUI, we aimed to provide businesses with a powerful tool to effectively manage their inventory, improve efficiency, and optimize resource utilization. Join us as we continue to explore the intersection of technology and business operations, empowering organizations to thrive in today's dynamic marketplace. 📦💻📊
* Day 78: Technical Test "swapPairs" and "reverseKGroup" [LeetCode](https://leetcode.com/problems/).
  * swapPairs: Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed) [Problem Description](https://leetcode.com/problems/swap-nodes-in-pairs/description/)
  * reverseKGroup: Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k, then the left-out nodes at the end should remain as they are. You may not alter the values in the list's nodes, only nodes themselves may be changed. [Problem Description](https://leetcode.com/problems/reverse-nodes-in-k-group/description/)
* Day 79: Minesweeper GUI Pygame
  * Today, we're diving into the development of a Minesweeper game with a Graphical User Interface (GUI) using Pygame. This classic game challenges players to uncover hidden mines on a grid-based board without detonating any of them. Our implementation leverages Pygame's intuitive interface to provide an engaging and immersive gaming experience. Players can reveal tiles, flag potential mines, and navigate through various difficulty levels or customize their game settings. Join us as we explore the world of game development with Python and Pygame, bringing the timeless excitement of Minesweeper to life in a modern and visually appealing format. 🕹️💣🎮
* Day 80: Student Practice Management System
  * Today, we developed a Python-based system to manage student internships. This system features:
    - **Practice Registration**: Capture student details, company name, and practice duration.
    - **Internship Tracking**: Monitor ongoing practices with detailed views.
    - **Average Duration Calculation**: Display the average length of internships.
    - **Company-Specific Intern Count**: Determine the number of interns per company.
    - **Company Update for Practices**: Modify the company associated with a student's practice.
    - **User-Friendly Menu Interface**: Easily navigate and interact with the system.

  This system aims to streamline the management of student internships, benefiting both students and administrators. 🎓🏢📊
* Day 81: Random Roulette
  * Today, we're building a Random Roulette web application using Flask. This app allows users to add and modify options for the roulette, and then spin to select a random option. With Flask's lightweight and flexible framework, we'll create an interactive and dynamic web interface where users can easily manage their options. The application features a simple design with an intuitive navigation system, ensuring a seamless user experience. Join us as we delve into web development with Flask, creating a fun and functional tool for making random selections. 🎡🔄✨
* Day 82: Test Projects "celsius_to_fahrenheit"
  * Today, we're focusing on writing unit tests for a simple function that converts temperatures from Celsius to Fahrenheit. Testing is a crucial part of software development, ensuring that our code works as expected and helps prevent bugs from creeping into our projects. We'll use Python's unittest module to create and run our tests. This exercise will help you understand the basics of writing tests and how to use them to verify the correctness of your code.
* Day 83: Technical Test "removeDuplicates" and "removeElement" [LeetCode](https://leetcode.com/problems/).
  * removeDuplicates: Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums. [Problem Description](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)
  * removeElement: Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val. [Problem Description](https://leetcode.com/problems/remove-element/description/)
* Day 84: Complaint Management System
  * Today, we developed a Python-based system to manage complaints for the General Prosecutor's Office. This system features:
    - **Complaint Creation**: Record details such as complainant, accused, date, type, and unique code.
    - **Complaint Deletion**: Remove complaints using a unique code.
    - **Sublist Creation**: Generate a sublist of complaints involving a specific person.
    - **Type-Based Percentage Calculation**: Calculate the percentage of each type of complaint.
    - **Complaint Display**: Show all registered complaints.
    - **Date Modification**: Update the date of a specific complaint.
    - **User-Friendly Menu Interface**: Easily navigate and interact with the system.

  This system is designed to streamline the management of complaints, making it easier for the General Prosecutor's Office to handle and organize them effectively. 📅📝🔍
* Day 85: Convert Word Files To PDF [NeuralNine](https://www.youtube.com/watch?v=i57uYpW5Ng8)
  * Today, we worked on a project to convert Word files (.docx) to PDF format. This project was inspired by a video tutorial from NeuralNine. While the tutorial provided the basic functionality for converting a single DOCX file to PDF, we expanded the project by adding several new features:
    - **Graphical User Interface (GUI)**: Using `tkinter`, we created an intuitive interface that allows users to easily select files and specify output options.
    - **Single File Conversion**: Users can convert a single DOCX file to PDF by selecting the file and choosing a destination.
    - **Multiple File Conversion**: Users can select multiple DOCX files and convert them all to PDF at once, saving the converted files in a specified directory.
    - **Error Handling**: The application includes robust error handling to inform users of any issues during the conversion process.
    - **User Notifications**: After a successful conversion, the application provides a notification to the user.
    
  These enhancements make the tool more user-friendly and versatile, offering a complete solution for converting Word documents to PDF efficiently.

* Day 86: Goldner-Harary Graph in 3D
  * Today, we explored the fascinating world of graph theory by creating and visualizing the Goldner-Harary graph in 3D. This project helped us understand the properties of planar graphs and verify Euler's formula. Here are the key features and steps we implemented:
    - **Graph Construction**: We created the Goldner-Harary graph, which consists of 11 vertices and 27 edges.
    - **3D Visualization**: Using `matplotlib` and `networkx`, we plotted the graph in a 3D space, providing a comprehensive visual representation of its structure.
    - **Planarity Check**: We verified the graph's planarity, confirming that it can be drawn on a plane without any edges crossing.
    - **Euler's Formula Verification**: We checked Euler's formula (v - e + f = 2) for the graph, ensuring it holds true for planar graphs.
    - **Graph Information**: We displayed essential information about the graph, including the number of vertices, edges, and faces.
    
  This project not only enhanced our understanding of graph theory but also provided practical experience with 3D data visualization techniques. The Goldner-Harary graph, with its complex structure, served as an excellent example for studying planar graphs and their properties. 🌐📊🔍
* Day 87: Building Management System
  * Today, we developed a Python-based Building Management System. This system offers functionalities such as generating invoices, making payments, and tracking property ownership. Key features include:
    - **Invoice Generation**: Automatically generate monthly invoices for property owners.
    - **Payment Processing**: Record and manage payments made by proprietors.
    - **Account Statements**: Generate account statements for proprietors, detailing payments and dues.
    - **Delinquency Monitoring**: Identify delinquent apartments based on overdue balances.
    
  This system streamlines property management tasks, enhancing efficiency and organization. 🏢💼💰
* Day 88: Technical Test "strStr" and "divide" [LeetCode](https://leetcode.com/problems/).
  * strStr: Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. This classic problem tests your ability to efficiently search substrings within a larger string. [Problem Description](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)
  * divide: Given two integers, dividend and divisor, divide them without using multiplication, division, and mod operator. Ensure the result is truncated toward zero. This problem challenges you to implement efficient division using basic arithmetic operations. [Problem Description](https://leetcode.com/problems/divide-two-integers/description/)
* Day 89: Dragon Ball Radar Animation with DBSCAN Clustering
  * Today, we crafted an animated Dragon Ball radar using Python, leveraging DBSCAN clustering to detect clusters of Dragon Balls. Here's a breakdown of what we accomplished:
    - **Radar Animation**: We animated a radar line sweeping through 360 degrees, simulating the iconic Dragon Ball radar from the anime series.
    - **DBSCAN Clustering**: Utilizing the DBSCAN algorithm, we clustered randomly generated Dragon Ball positions, mimicking their distribution across the radar's range.
    - **Cluster Visualization**: Each cluster of Dragon Balls was represented by a yellow point on the radar, with the number of Dragon Balls in each cluster displayed alongside.
    - **Interactive Animation**: The animation included blinking points and text to add dynamism and visual appeal to the radar display.

  This project blends entertainment with data science, offering a playful yet educational exploration of clustering algorithms and animated visualizations. 🐉🔍✨
* Day 90: Pong Game Development in Python
  * Today, we developed a classic Pong game using Python and the Pygame library. Here's a summary of our progress:
    - **Game Mechanics**: We implemented the basic mechanics of Pong, including ball movement, paddle control, and collision detection.
    - **Scoring System**: A scoring system was added, with the game ending when a player reaches 5 points. The score is displayed on the screen, and a winning message is shown at the end.
    - **Paddle Customization**: The paddles were given distinct colors (red for the left paddle and blue for the right paddle) to enhance the visual appeal.
    - **Smooth Animation**: The game runs smoothly at 60 frames per second, providing a responsive and enjoyable gaming experience.

  This project demonstrates the fundamentals of game development in Python, showcasing the power and flexibility of Pygame for creating interactive applications. 🎮🚀✨
* Day 91: Flask-based Online Survey Application
  Today, we created a Flask-based Online Survey Application. This project allows users to create surveys and participate in them. Key functionalities include:

    - **Survey Creation**: Users can create new surveys with customizable options.
    - **Survey Participation**: Other users can vote in existing surveys.
    - **Results Display**: The application displays results for each survey, showing the distribution of votes.
    
  This project aims to provide a straightforward platform for conducting surveys online, enhancing user engagement and feedback collection. 📊🖥️✅
* Day 92: Tower of Hanoi and N Queens Problem Solutions
  * Today, we implemented solutions to the classic Tower of Hanoi and N Queens problems in Python. Here's a summary of our progress:
    - **Tower of Hanoi**: We developed a recursive function to solve the Tower of Hanoi problem, which involves moving disks from one peg to another according to specific rules. The function efficiently moves disks from the source peg to the target peg using an auxiliary peg.
    - **N Queens Problem**: We implemented a backtracking algorithm to solve the N Queens problem, which involves placing N queens on an NxN chessboard such that no queen attacks another. The algorithm ensures that each queen is placed safely by checking for conflicts with other queens in the same row, column, or diagonal.

  These projects demonstrate the power of Python for solving complex problems and the importance of recursion and backtracking in solving these types of problems. 🎯👑

* Day 93: Word Search Puzzle GUI
  * Today, we created a graphical user interface (GUI) for a word search puzzle using Python's Tkinter library. Here's an overview of what we accomplished:
    - **Word Entry**: We added an input field for users to enter words (comma-separated) which will be hidden in the word search grid.
    - **Grid Generation**: We implemented a function to generate a grid filled with random letters, ensuring that the words are placed in random directions (horizontal, vertical, diagonal).
    - **Word Selection**: We enabled cell selection in the grid. Selected cells highlight in yellow until a word is completely formed. If the word is valid, the cells change to green, indicating that the word has been found. If not, the cells revert to their original state.
    - **Word List Display**: The words are displayed on the right side of the interface. Found words are struck through.
    - **Timer**: We added a configurable timer (5 to 10 minutes) that counts down. If the user doesn't find all the words within the time limit, a message prompts them to try again.
    - **Solve Button**: A centrally placed "Solve" button highlights all the words in the grid, assisting the user in finding the words.
    - **Completion and Reset**: Upon finding all the words or the timer running out, the user is prompted to play again, allowing the game to reset.

  This project demonstrates the integration of Python with Tkinter to create interactive applications, enhancing user experience and interface design. 🧩🕹️

* Day 94: Technical Test "findSubstring" and "nextPermutation" [LeetCode](https://leetcode.com/problems/).
  * findSubstring: Given a string `s` and an array of strings `words`, find all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once and without any intervening characters. [Problem Description](https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/)
  * nextPermutation: Implement the next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order). The replacement must be in place and use only constant extra memory. [Problem Description](https://leetcode.com/problems/next-permutation/description/)
* Day 95: PhishGuard - Anti-Phishing Email and Website Filter
  * Today, we developed a phishing protection filter called **PhishGuard** using Python. Here's an overview of what we accomplished:
    - **Keyword Detection**: Implemented a function to identify phishing keywords in email content.
    - **URL Analysis**: Extracted and analyzed URLs from emails, checking them against a list of known phishing domains.
    - **Email Filtering**: Created a filter to process a list of emails, blocking those identified as phishing attempts.
    - **Hotmail Example**: Tested the filter with example Hotmail emails to demonstrate its effectiveness.
      
  This project highlights how Python can be used to enhance email security by detecting and blocking potential phishing attacks. 🛡️📧
* Day 96: World Clock GUI
  * Today, we developed a **World Clock GUI** using Python and Tkinter. Here's an overview of what we accomplished:
    - **Time Zone Updates**: Implemented a function to update and display the current time for multiple time zones including Colombia, New York, China, Germany, and Norway.
    - **GUI Design**: Created a user-friendly graphical interface with labeled clocks for each time zone, enhancing the visual appeal and usability.
    - **Icon and Flags**: Added an application icon and country flags to represent each time zone, providing a clear and engaging visual representation.
    - **Dynamic Updates**: Ensured the clock times are updated dynamically every second, keeping the displayed times accurate.

  This project showcases how Python can be used to create a functional and visually appealing world clock application. 🕒🌍
* Day 97: Pipelines for inference [🤗 Transformers](https://huggingface.co/docs/transformers/pipeline_tutorial)
  * Today, I explored the powerful pipeline feature from the Hugging Face Transformers library to perform automatic speech recognition (ASR) and text generation tasks. Here's a summary of what I accomplished:
    - **Automatic Speech Recognition**: Utilized the `pipeline()` function for ASR to transcribe audio files into text. Implemented and tested the OpenAI Whisper model for improved accuracy.
    - **Batch Processing**: Leveraged batch processing to handle multiple audio files efficiently, enhancing the pipeline's performance on a GPU.
    - **Task-Specific Parameters**: Experimented with parameters such as `return_timestamps` for subtitling and `chunk_length_s` for processing long audio files, demonstrating the flexibility of the pipeline.
    - **Device Management**: Configured the pipeline to run on the appropriate device (CPU or GPU) based on availability, optimizing computational resources.
    - **Dataset Integration**: Integrated the pipeline with datasets to perform inference on large datasets, showing the capability of the pipeline to handle extensive data inputs seamlessly.

  This project highlights the versatility and ease of using Hugging Face's pipeline feature for various NLP and ASR tasks, showcasing the practical applications of machine learning models in real-world scenarios.
* Day 98: Vehicle Management System
  * Today, I developed a Vehicle Management System to help the Universidad de Envigado manage the vehicles that enter and exit the campus. The system identifies each vehicle by its license plate and entry date. Here's a summary of what I accomplished:
    - **Vehicle Entry**: Implemented functionality to add a vehicle to the active vehicles list and log its entry time.
    - **Vehicle Exit**: Created a method to remove a vehicle from the active list and log its exit in the history.
    - **Date-Specific Entry Count**: Added a feature to determine the number of vehicles that entered the campus on a specific date.
    - **Entry Count by Vehicle**: Developed a function to list the number of times a specific vehicle has entered the campus.
    - **User-Friendly Menu**: Designed an interactive menu for users to manage vehicle entries and exits, check vehicle counts, and handle inputs gracefully, including validation for empty inputs.

  This project showcases the application of object-oriented programming principles to solve real-world problems, providing an efficient solution for managing campus vehicle traffic. The user-friendly interface ensures ease of use, while robust input validation enhances reliability.
* Day 99: 🌬️ Asthma Disease Dataset 🌬️ [Kaggle](https://www.kaggle.com/datasets/rabieelkharoua/asthma-disease-dataset/data)
  * Today, I worked with the Asthma Disease Dataset from Kaggle, aiming to analyze and model the factors contributing to asthma diagnosis. Here's a summary of what I accomplished:
    - **Data Exploration and Cleaning**: Conducted an initial exploration of the dataset to understand its structure and identify missing values. Cleaned the data by handling missing values and irrelevant columns.
    - **Feature Analysis**: Performed an exploratory data analysis (EDA) to visualize distributions of numerical features, correlations, and demographic insights. Created plots to understand the relationships between various factors and asthma diagnosis.
    - **Descriptive Statistics**: Calculated and interpreted key statistics for age distribution, gender, ethnicity, and education level among diagnosed and non-diagnosed patients.
    - **Pie Charts and Histograms**: Generated pie charts for categorical variables like ethnicity, gender, and education level. Plotted histograms for age distribution of diagnosed patients to identify trends.
    - **Correlation Heatmap**: Created a heatmap to visualize correlations between numerical features, helping to identify significant relationships.
    - **Model Training and Evaluation**: Developed and evaluated several machine learning models, including Logistic Regression, Random Forest, Gradient Boosting, Support Vector Machine, XGBoost, and K-Nearest Neighbors. Assessed model performance using accuracy and ROC AUC scores.
    - **Scaling and Splitting Data**: Preprocessed the data by scaling features and splitting it into training and testing sets to ensure robust model evaluation.

  This project highlights the importance of data preprocessing, exploratory analysis, and model evaluation in the context of medical data. The insights and models developed can help in understanding the factors influencing asthma diagnosis and potentially aid in early detection and prevention strategies.
* Day 100: 🎮 2048 Game with Flask 🎮

  * Today, I created a web-based 2048 game using Flask. The project involved building the game logic, setting up a server, and creating a responsive user interface. Here's a summary of what I accomplished:
    - **Flask Application Setup**: Initialized a Flask application to handle game logic and API endpoints. Defined routes for starting a new game, making moves, and autoplay functionality.
    - **Game Logic Implementation**: Developed functions to initialize the game board, add new tiles, and perform moves in all directions (left, right, up, down). Ensured that the game logic correctly merges tiles and adds new ones after each move.
    - **Autoplay Feature**: Implemented an autoplay feature that simulates moves automatically until the game ends. This feature helps demonstrate the game mechanics and provides a way to observe strategies for achieving higher scores.
    - **Game Over Check**: Added functionality to detect when the game is over, offering the option to restart the game and encouraging continuous play.
    - **User Interface Design**: Created a responsive UI using HTML and CSS, ensuring the game board is centered and visually appealing. Applied a dark background for better visibility and user experience.
    - **Styling with CSS**: Separated CSS into an external file, focusing on clean design and readability. Styled the board and cells to clearly display game states and centered numbers within their cells.
    - **JavaScript Integration**: Moved JavaScript code to an external file for better organization. Handled user input for moves, board rendering, and autoplay functionality.
    - **Restart Option**: Added a restart button to allow users to start a new game when the current game ends.
    - **Enhanced User Experience**: Improved the overall user experience by ensuring smooth interactions, clear game states, and responsive design elements.

  This project demonstrates the integration of front-end and back-end technologies to create an interactive web application. It highlights the importance of clean code organization, user-centric design, and robust game logic implementation. The 2048 game serves as a fun and engaging way to explore web development with Flask.

* Day 101: Technical Test "longestValidParentheses" and "search" [LeetCode](https://leetcode.com/problems/).
  * longestValidParentheses: Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. [Problem Description](https://leetcode.com/problems/longest-valid-parentheses/description/)
  * search: Given an array of integers `nums` sorted in ascending order, which is possibly rotated at an unknown pivot, and an integer `target`, find the index of `target` in `nums` or return -1 if it is not in `nums`. The algorithm must run in O(log n) time complexity. [Problem Description](https://leetcode.com/problems/search-in-rotated-sorted-array/description/)

* Day 102: 🍦 Object-Oriented Programming in Python with Ice Cream Example 🍦

  * Today, I explored the fundamentals of Object-Oriented Programming (OOP) in Python using a fun and relatable example: an ice cream shop. This project highlights the six basic principles of OOP—inheritance, cohesion, abstraction, polymorphism, coupling, and encapsulation. Here's a summary of what I accomplished:

    - **Abstraction and Encapsulation**: Created an abstract base class `IceCream` to represent the common attributes and behaviors of all ice creams. Encapsulated the flavor and price attributes to protect them from direct modification.
    - **Inheritance**: Developed two subclasses, `ScoopIceCream` and `Sundae`, inheriting from the `IceCream` class. These subclasses extend the base class by adding specific attributes like the number of scoops and toppings.
    - **Polymorphism**: Implemented a function `print_ice_cream_details` that takes any `IceCream` object and prints its details. This demonstrates how different ice cream objects can be handled through a single interface.
    - **Cohesion**: Ensured each class has a single, well-defined responsibility. For example, `ScoopIceCream` handles the specifics of scoop-based ice cream, while `Sundae` manages sundae-specific attributes.
    - **Coupling**: Maintained loose coupling between classes to ensure that changes in one class minimally affect others. This was achieved through well-defined interfaces and clear separation of responsibilities.
    - **Encapsulation**: Used private attributes to encapsulate the internal state of the objects, providing getter methods to access the values.
* Day 103: [TensorFlow](https://www.tensorflow.org/tutorials/keras/text_classification_with_hub) Text classification with TF Hub

  * Today, I explored text classification using TensorFlow Hub and TensorFlow Datasets. This project focused on building a neural network model to classify movie reviews as positive or negative. Here's a summary of what I accomplished:

    - **Data Loading and Preparation**: Utilized TensorFlow Datasets to download and prepare the IMDB dataset, splitting it into training, validation, and test sets.
    - **Exploration**: Examined the dataset to understand its structure and content. Each example in the dataset consists of a movie review (text) and a corresponding label (0 for negative, 1 for positive).
    - **Text Embedding**: Leveraged a pre-trained text embedding from TensorFlow Hub to convert sentences into embedding vectors. This approach simplifies text preprocessing, benefits from transfer learning, and provides a fixed-size output.
    - **Model Building**: Constructed a neural network model using Keras Sequential API. The model includes:
      - A TensorFlow Hub layer for text embedding.
      - A Dense layer with 16 hidden units and ReLU activation.
      - A Dense output layer with a single unit for binary classification.
    - **Loss Function and Optimizer**: Configured the model with the `binary_crossentropy` loss function and the Adam optimizer. This setup is suitable for binary classification tasks.
    - **Model Training**: Trained the model for 10 epochs using mini-batches of 512 samples, monitoring the loss and accuracy on the validation set.
    - **Model Evaluation**: Evaluated the model on the test set to measure its performance, reporting both loss and accuracy.

  This project demonstrates the application of TensorFlow and TensorFlow Hub for natural language processing tasks. It highlights the importance of using pre-trained models for efficient text embedding and the benefits of a well-structured neural network for text classification.
* Day 104: Battleship Game with Flask
  * Today, I developed a Battleship game using Flask, a micro web framework for Python. This project involved creating a web-based version of the classic Battleship game, where users can guess the locations of ships on a grid. Here's a summary of what I accomplished:

    - **Setting Up Flask Application**: Initialized a Flask project, set up routes, and managed sessions to maintain game state between requests.
    - **Game Logic Implementation**: Implemented the core game logic in Python, including functions for creating ships, processing user guesses, and checking for game over conditions.
    - **Session Management**: Utilized Flask sessions to store the hidden and guess boards, ensuring the game state is preserved between user interactions.
    - **User Interface**: Developed HTML templates using Jinja2 to render the game board and provide a user-friendly interface. Included labels for rows and columns to guide the user.
    - **Game Mechanics**: Added functionality to handle user guesses, update the game board, and provide feedback on hits and misses. Also implemented logic to reveal ship locations if the user runs out of turns.

  This project showcases how to build a simple yet interactive web application with Flask. It emphasizes the importance of session management in web applications and demonstrates how to create a dynamic user interface with Jinja2 templates. Additionally, it illustrates the implementation of classic game mechanics in a web-based environment.

* Day 105: Technical Test "searchRange" and "searchInsert" [LeetCode](https://leetcode.com/problems/).

  - **searchRange**: Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given target value. If the target is not found in the array, return [-1, -1]. The algorithm must run in O(log n) time complexity.
  [Problem Description](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/)
    
  - **searchInsert**: Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. The algorithm must run in O(log n) time complexity. [Problem Description](https://leetcode.com/problems/search-insert-position/description/)
* Day 106: Create a Multipage App with Streamlit [Streamlit Tutorial](https://docs.streamlit.io/get-started/tutorials/create-a-multipage-app)
  * Today, I focused on building a multipage web application using Streamlit, a popular open-source app framework for Machine Learning and Data Science projects. This project involved creating a web application that can navigate between different pages, each displaying unique content or functionality. Here's a summary of what I accomplished:

    - **Setting Up Streamlit Environment**: Installed Streamlit and set up the development environment.
    - **Creating Pages**: Developed multiple pages for the application, each serving a distinct purpose. For example, a home page, a data visualization page, and a user input page.
    - **Navigation Implementation**: Implemented a navigation system to switch between different pages. Used Streamlit’s built-in components to create a user-friendly interface for navigation.
    - **Dynamic Content**: Ensured each page displays dynamic content based on user interactions. For instance, visualizations that update based on user input or data selections.
    - **User Interface Design**: Designed the layout and style of the application to make it intuitive and visually appealing. Leveraged Streamlit’s layout options and widgets to enhance the user experience.

  This project showcases the versatility of Streamlit in creating interactive and multipage web applications. It emphasizes the ease of setting up a multi-page structure and the ability to integrate dynamic content seamlessly. This was an excellent exercise in web development and user interface design, demonstrating how to build comprehensive applications using Streamlit.
* Day 107: Twenty One Card Game GUI
  * Today, I developed a Twenty-One card game (similar to Blackjack) in Python. This project involved creating the core game logic, displaying cards, handling user interactions, and implementing the rules of the game. Here's a summary of what I accomplished:

    - **Card Display Function**: Created a function to display cards in a visually appealing format using ASCII art. This function helps players see their cards and the dealer's cards clearly.
    - **Random Card Generation**: Implemented a function to generate random cards, ensuring a mix of suits and values for each game.
    - **Card Value Calculation**: Developed a function to calculate the value of each card, considering the special case for Aces, which can be worth either 1 or 11 points.
    - **Game Logic**: Implemented the main game loop, handling the player's turn and the dealer's turn, including decision-making processes and win/lose conditions.
    - **User Interaction**: Added functionality for user input to decide whether to continue playing or stop, and to determine if the player wants to try again after a game ends.

  This project demonstrates the implementation of a classic card game using Python, focusing on interactive gameplay and dynamic card management. It emphasizes the importance of user-friendly design and accurate game mechanics.
* Day 108: Character-Level Language Model with RNN
  * Today, I developed a simple character-level language model using Recurrent Neural Networks (RNN) with TensorFlow and Keras. This project involved creating a model to predict the next character in a sequence of text. Here's a summary of what I accomplished:

    - **Text Preparation**: Prepared the input text by creating mappings from characters to indices and vice versa. Split the text into sequences for training.
    - **Dataset Creation**: Generated training data by creating overlapping sequences of characters and the corresponding next character to predict.
    - **Model Building**: Constructed an RNN model using Keras. The model includes:
      - An Embedding layer to learn character embeddings.
      - A SimpleRNN layer to capture sequential dependencies.
      - A Dense output layer with softmax activation to predict the next character.
    - **Model Compilation**: Compiled the model using categorical cross-entropy loss and the Adam optimizer.
    - **Model Training**: Trained the model on the prepared dataset, using a batch size of 2 and running for 100 epochs.
    - **Prediction Function**: Implemented a function to predict the next character given a sequence of characters. This function uses the trained model to generate predictions.

  This project showcases the process of building a character-level language model using RNNs. It emphasizes the importance of text preprocessing, sequence generation, and model training for sequential data tasks. The model is capable of predicting the next character in a sequence, demonstrating the potential of RNNs in natural language processing.
* Day 109: PolarsVSPandas (Polars Is The Faster Pandas) [NeuralNine](https://www.youtube.com/watch?v=zthI91ASV58)
  * Today, I explored the performance differences between Pandas and Polars for data manipulation tasks. This project was inspired by NeuralNine's video on Polars being faster than Pandas. Here's a summary of what I accomplished:

    - **Data Preparation**: Created a dataset with 120,000 rows of random data using NumPy.
    - **DataFrame Creation**: Generated DataFrames using both Pandas and Polars to compare their performance.
    - **Reading Data**: Measured the time taken to read the data into Pandas and Polars DataFrames.
    - **Aggregation**: Performed aggregation operations to calculate the mean of column 'B' and the sum of column 'C' grouped by column 'A'.
    - **Filtering**: Filtered the data to include only rows where column 'A' is greater than 50.
    - **Joining**: Conducted join operations to merge two DataFrames on column 'A'.
    - **Conditional Column Addition**: Added a new column to a DataFrame based on a condition using both Pandas and Polars.

  This project demonstrates the significant performance improvements that Polars offers over Pandas for certain data manipulation tasks. It highlights the importance of choosing the right tools for data processing to achieve efficient and scalable solutions. Special thanks to NeuralNine for the step-by-step guide provided in his video.

* Day 110: Technical Test "isValidSudoku" and "solveSudoku" [LeetCode](https://leetcode.com/problems/).

  - **isValidSudoku**: Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
    - Each row must contain the digits 1-9 without repetition.
    - Each column must contain the digits 1-9 without repetition.
    - Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
    Note:
    - A Sudoku board (partially filled) could be valid but is not necessarily solvable.
    - Only the filled cells need to be validated according to the mentioned rules.
    [Problem Description](https://leetcode.com/problems/valid-sudoku/description/)
    
  - **solveSudoku**: Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules:
    - Each of the digits 1-9 must occur exactly once in each row.
    - Each of the digits 1-9 must occur exactly once in each column.
    - Each of the digits 1-9 must occur exactly once in each of the nine 3x3 sub-boxes of the grid.
    The '.' character indicates empty cells.
    [Problem Description](https://leetcode.com/problems/sudoku-solver/description/)
* Day 111: Library Management System

  - Today, I developed a Flask-based system for managing books, members, loans, and returns in a library setting. Data storage is handled using JSON files.
    - **Features**:
      - **Books Management**: Add, view, and list books.
      - **Members Management**: Add and list members.
      - **Loans Management**: Loan and return books with member associations.
    - **Technologies**: Flask, JSON, HTML/CSS.
    - **Project Structure**:
      - **app.py**: Flask application handling routes and data operations.
      - **templates/**: HTML templates for rendering pages.
      - **static/**: CSS styles for frontend.
    - **Future Enhancements**: Implement editing and deletion functionalities for books and members, search functionality, and user authentication.
* Day 112: Maze Generator and Solver
  - **Maze Generator**: Implemented a recursive maze generator using the turtle graphics library in Python. The maze is generated by moving the turtle to adjacent cells based on the least visited neighbors.
  - **Maze Solver**: Developed a recursive solver to find the path from the start to the end of the maze. The path is drawn using a different color to indicate the solution.

  This project showcases the use of recursive algorithms for generating and solving mazes, highlighting the power of Python's turtle graphics library for visualizing the process.
* Day 113: Basketball Scoreboard in Flask

  - **Basketball Scoreboard**: Created a web application using Flask to simulate a basketball scoreboard. The scoreboard allows users to input the names of the home and away teams, track scores (1-point, 2-point, and 3-point baskets), fouls, and display the current quarter or overtime. The game progresses through regular quarters, halftime, and overtime periods as needed, with a final winner determined based on scores.

  This project demonstrates the use of Flask for web development and real-time updating of game states, showcasing interactive elements like score tracking, foul recording, and game progression logic.
* Day 114: Internet Speed Test Application

  - **Internet Speed Test Application**: Developed a desktop application using Tkinter to measure internet speed. The application tests the download and upload speed as well as the ping of the user's internet connection. Results are displayed in the application window in real-time.

    - **Speed Test**: Utilized the Speedtest library to measure download and upload speeds in Mbps, and ping in milliseconds. The results are displayed in a user-friendly format.
    - **User Interface**: Designed a simple and intuitive GUI using Tkinter, with buttons to start the speed test, display information about the application, and exit the program.
    - **Information Dialog**: Added an information dialog box to provide users with details about the application's functionality.

  This project demonstrates the use of Tkinter for building desktop applications and integrating third-party libraries to perform real-time internet speed tests.
* Day 115: Steganography Application using Flask

  - **Steganography Application**: Developed a web application using Flask to hide and reveal secret messages within images using the Stegano library. This project involved creating a user-friendly interface for uploading images and entering messages to hide or reveal.

    - **Hide Message**: Implemented functionality to allow users to upload an image and input a message, which is then hidden within the image using the LSB (Least Significant Bit) method provided by the Stegano library. The resulting image is saved and displayed to the user.
    - **Reveal Message**: Added functionality to upload an image and extract any hidden message from it. The extracted message, if any, is displayed to the user along with the image.
    - **User Interface**: Designed a clean and intuitive web interface with routes for hiding and revealing messages, ensuring ease of use and smooth user experience.

    This project demonstrates the use of Flask for building web applications, integrating third-party libraries for steganography, and handling file uploads and processing.
* Day 116: Technical Test "countAndSay" and "combinationSum" [LeetCode](https://leetcode.com/problems/).

  - **countAndSay**: Generate the nth term in the count-and-say sequence. The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
    - countAndSay(1) = "1"
    - countAndSay(n) is the run-length encoding of countAndSay(n - 1).
    
    For example, to compress the string "3322251" using run-length encoding, replace "33" with "23", replace "222" with "32", replace "5" with "15" and replace "1" with "11". Thus the compressed string becomes "23321511".
    [Problem Description](https://leetcode.com/problems/count-and-say/description/)

  - **combinationSum**: Return a list of all unique combinations of candidates where the chosen numbers sum to a given target. Each number in candidates may be used an unlimited number of times in the combination. Two combinations are unique if the frequency of at least one of the chosen numbers is different.

    Given an array of distinct integers `candidates` and a target integer `target`, this problem finds all unique combinations of candidates that sum to the target. The test cases are generated such that the number of unique combinations that sum up to the target is less than 150 combinations for the given input.
    [Problem Description](https://leetcode.com/problems/combination-sum/description/)
* Day 117: Recursion "BinaryTreeExpressionEvaluator"
  * This project defines a binary tree where each node can be a numeric value or an operator. It evaluates the expression represented by the binary tree using recursion. The supported operations are addition, subtraction, multiplication, division, and exponentiation.
  
  - **TreeNode Class**: A class that represents a node in the binary tree.
    - `value`: The value of the node, which can be an integer (leaf node) or an operator (internal node).
    - `left`: The left child node.
    - `right`: The right child node.
  
  - **evaluate_tree Function**: A function that evaluates the binary tree to compute the result of the expression it represents.
    - It takes the root node of the binary tree as an argument.
    - It returns the result of the expression as an integer or float.
    - It raises a `ValueError` if there is an attempt to divide by zero.
  
  - **Example Usage**: The project includes an example usage of creating a binary tree for the expression `((3 + 2) * (4 - 1)) ^ 2` and evaluating it to get the result.

  This project showcases the power of recursion in evaluating complex expressions represented by binary trees, highlighting the versatility of binary trees in computational problems.
* Day 118: Shirt Store
  * Implemented a Python application for managing a shirt store using object-oriented programming concepts. The application allows users to add shirts to the store's inventory, manage customer interactions including adding to cart and purchasing, and view store and customer details.
* Day 119: Household Basket
  - **Household Basket Application**: Developed a desktop application using Tkinter to manage household items in a basket, including fruits, vegetables, meat, dairy, and other categories. The application connects to an SQLite database to store and manage the items.

    - **Add Item**: Implemented functionality to add items to the household basket. Users can select a category, enter the name and quantity of the item, and add it to the database. Validation ensures proper input for name and quantity fields.
    - **View Items**: Added a treeview to display all items in the household basket. Users can see the item ID, category, name, and quantity.
    - **Delete Item**: Included functionality to delete selected items from the basket. Users can select an item from the treeview and remove it from the database with a single click.
    - **Database Management**: Utilized SQLite to create a persistent storage solution for the household basket items. Functions were developed to create the table, insert items, retrieve items, and delete items from the database.
    - **User Interface**: Designed a user-friendly and responsive interface with Tkinter, ensuring a smooth user experience. The interface includes input fields, buttons, and a treeview to manage and display items effectively.
* Day 120: Copa America 2024 Groups [Dataset](https://en.wikipedia.org/wiki/2024_Copa_Am%C3%A9rica)
  - **Copa America 2024 Groups**: Developed a Python script to scrape and process data from the Wikipedia page for the 2024 Copa América, extracting the group stage tables and organizing them into a dictionary for easy access and manipulation.
    - **Data Scraping**: Used the `pandas` library to read all tables from the Wikipedia page, focusing on the relevant indices to extract the tables for Groups A to D.
    - **Data Processing**: Renamed the second column of each table to "Team" and removed the "Qualification" column for cleaner data representation.
    - **Data Organization**: Stored the processed tables in a dictionary, with group letters as keys for easy retrieval and display.
    - **Data Persistence**: Saved the dictionary to a file using the `pickle` library for persistent storage and later use.
* Day 121: Technical Test "combinationSum2" and "firstMissingPositive" [LeetCode](https://leetcode.com/problems/).
  - **combinationSum2**: Find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination, and the solution set must not contain duplicate combinations. This problem involves using a backtracking approach to explore all possible combinations, ensuring that no duplicates are included in the result set. [Problem Description](https://leetcode.com/problems/combination-sum-ii/description/)

  - **firstMissingPositive**: Return the smallest positive integer that is not present in an unsorted integer array `nums`. The algorithm must run in O(n) time and use O(1) auxiliary space. The solution involves rearranging the array so that each positive integer `n` is placed at index `n-1`. Then, the first index that does not contain the correct integer indicates the missing positive integer. [Problem Description](https://leetcode.com/problems/first-missing-positive/description/)
* Day 122: Recursion "Knapsack"

  * This project tackles the Knapsack problem using both recursive and dynamic programming approaches. The Knapsack problem is a classic algorithmic problem that involves selecting items with given weights and values to maximize the total value without exceeding the weight capacity.

  - **knapsack_recursive Function**: A recursive function to solve the Knapsack problem.
    - `weights`: A list of weights of the items.
    - `values`: A list of values of the items.
    - `W`: The maximum weight capacity of the knapsack.
    - `n`: The number of items.
    - This function returns the maximum value that can be obtained by including or excluding the nth item.
    - Base cases include no items left or a knapsack capacity of 0. The function chooses the maximum value between including and not including the nth item.

  - **knapsack_dynamic Function**: A dynamic programming function to solve the Knapsack problem.
    - `weights`: A list of weights of the items.
    - `values`: A list of values of the items.
    - `W`: The maximum weight capacity of the knapsack.
    - This function returns the maximum value that can be obtained using a bottom-up approach to build a table `dp` where `dp[i][w]` represents the maximum value that can be obtained with the first `i` items and a knapsack capacity of `w`.
    - The function iterates over the items and capacities, filling the table based on whether the item is included or not.

  - **Example Usage**: The project includes an example with weights `[1, 2, 3, 4]`, values `[10, 20, 30, 40]`, and a knapsack capacity `W = 5`. It demonstrates the maximum value calculation using both recursive and dynamic programming approaches.
* Day 123: [TLC Trip Record Data](https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page)
  - **NYC Taxi Data Analysis**: Developed a data analysis project using PySpark and Pandas to process and visualize the NYC Yellow Taxi Trip data. This project involved extensive data cleaning, transformation, and visualization to uncover patterns and insights from the dataset.

    - **Data Cleaning and Transformation**: Utilized PySpark for efficient handling of large datasets. Performed data cleaning steps such as filtering out invalid data, handling missing values, and creating new columns for analysis.
      - **Trip Duration Calculation**: Calculated trip duration from pickup and dropoff timestamps and added it as a new column.
      - **Sampling**: Extracted a sample of the data to facilitate visualization and analysis in Pandas.

    - **Data Visualization**: Converted the cleaned data to a Pandas DataFrame for visualization using Seaborn and Matplotlib.
      - **Distribution of Trip Durations**: Plotted a histogram to show the distribution of trip durations.
      - **Trips per Hour**: Visualized the number of trips per hour to identify peak times for taxi rides.
      - **Trip Distance vs Fare Amount**: Created scatter plots to explore the relationship between trip distance and fare amount.
      - **Heatmaps of Pickup and Dropoff Locations**: Generated heatmaps to show the frequency of pickups and dropoffs by location ID.
      - **Passenger Count Distribution**: Displayed the distribution of the number of passengers per trip.
      - **Payment Type Distribution**: Visualized the distribution of different payment types used in the trips.
      - **Total Amount vs Tip Amount**: Plotted the relationship between the total fare amount and the tip amount.

  This project demonstrates the use of PySpark for big data processing and Pandas/Seaborn for detailed data visualization, providing insights into the NYC taxi operations and passenger behaviors.
* Day 124: 🏫 Object-Oriented Programming in Python with University Enrollment System 🏫

  * Today, I worked on a university enrollment system project to reinforce the principles of Object-Oriented Programming (OOP) in Python. This project incorporates key OOP concepts such as inheritance, encapsulation, and abstraction. Here's a summary of what I accomplished:

    - **Abstraction and Encapsulation**: Created an abstract base class `Person` to represent common attributes and behaviors for both students and teachers. Encapsulated the name and ID number attributes to protect them from direct modification. Implemented abstract methods to enforce a consistent interface for subclasses.
    - **Inheritance**: Developed two subclasses, `Student` and `Teacher`, inheriting from the `Person` class. These subclasses extend the base class by adding specific attributes and methods like enrolling in courses and assigning courses.
    - **Course Management**: Created a `Course` class to represent a university course, including attributes for course name, credits, teacher, and maximum number of students. Added methods to handle student enrollment, calculate total students, and determine the cost per student.
    - **User Interaction**: Implemented a menu-driven interface to allow users to enroll students in courses, display student details, and show course information. This interactive component showcases how OOP can be used to structure complex, real-world applications.
    - **Data Storage**: Used dictionaries to manage and store student instances, demonstrating the practical use of data structures in conjunction with OOP to handle multiple objects efficiently.

  This project provided a comprehensive exercise in applying OOP principles to a realistic scenario, reinforcing the importance of well-structured, maintainable, and scalable code.
* Day 125: Technical Test "trap" and "multiply" [LeetCode](https://leetcode.com/problems/).
  - **trap**: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. This problem involves using a two-pointer approach to traverse the elevation map and calculate the trapped water by comparing the heights of bars. It requires understanding how to efficiently track the maximum heights from both ends of the array to determine the water level at each position. [Problem Description](https://leetcode.com/problems/trapping-rain-water/description/)

  - **multiply**: Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string. The solution must not use any built-in BigInteger library or convert the inputs to integers directly. This problem requires implementing a manual multiplication algorithm similar to the one learned in school, handling digit-by-digit multiplication, and managing carry-over between digits. [Problem Description](https://leetcode.com/problems/multiply-strings/description/)
* Day 126: Basketball Ground Using Turtle
  * Created a visual representation of a basketball court using the Turtle graphics library in Python. This project involves drawing a complete basketball court with various elements like the court boundaries, center circle, and basket areas.

  - **Drawing the Court**: Utilized Turtle graphics to draw the court boundaries, including the outer lines and the rectangular playing area.
  - **Center Circle and Baskets**: Implemented functions to draw the center circle and the areas around the baskets, including the semi-circles and rectangles that represent the key areas on the court.
  - **Colors and Aesthetics**: Used different colors and fill patterns to differentiate various parts of the court, enhancing the visual appeal and clarity of the representation.

  This project showcases the capabilities of the Turtle graphics library for creating detailed and visually appealing graphics. It also emphasizes the importance of geometric calculations and the use of loops and functions to create complex shapes and patterns.

  The code for this project was adapted from an example on GeekforGeeks: [Create a Basketball Ground Using Turtle Library in Python](https://www.geeksforgeeks.org/create-a-basketball-ground-using-turtle-library-in-python/).
* Day 127: Employee Hours
  - **Employee Hours Management System**: Developed a web application using Flask and SQLite to manage and track employee working hours. This project includes functionalities for user authentication, logging working hours, editing logged hours, and visualizing the weekly work schedule.

    - **User Authentication**: Implemented login and registration features to ensure secure access to the application.
      - **Login**: Users can log in with their username and password. If credentials are invalid, an error message is displayed.
      - **Registration**: New users can register by providing a username and password. The registration page is linked from the login page.

    - **Logging Working Hours**: Provided functionality to log working hours with task details.
      - **Form Validation**: Ensured that logged hours are within weekdays (Monday to Friday) and between 06:00 and 23:00. If the user tries to log hours outside these constraints, an error message is displayed.

    - **Editing Logged Hours**: Allowed users to edit previously logged hours.
      - **Task and Start Time Modification**: Users can update the task description and the start time of logged hours, with the same validation constraints as logging new hours.

    - **Data Visualization**: Displayed the logged hours in a tabular format showing the weekly schedule.
      - **Weekly Schedule Table**: Organized logged hours by day and time, highlighting the tasks performed.
      - **Total Hours Calculation**: Summed up the total hours worked in a week and displayed it. If total hours exceed 42, the overtime hours are also shown.

    - **Database Management**: Used SQLite to store user credentials and logged hours.
      - **Database Initialization**: Created tables for users and logged hours if they do not exist.

    - **Additional Features**:
      - **Clear Hours**: Added a button to clear all logged hours for the next week, ensuring a fresh start.
      - **Responsive Design**: Implemented a professional CSS for a better user experience and user interface.

    This project demonstrates the use of Flask for web development, SQLite for database management, and JavaScript for client-side validation. It provides a comprehensive solution for managing and tracking employee working hours, ensuring data integrity and user-friendliness.
* Day 128: Recursion "Letter Combinations"

  * This project focuses on solving the "Letter Combinations of a Phone Number" problem using recursion. Given a string containing digits from 2-9 inclusive, the goal is to return all possible letter combinations that the number could represent. The mapping of digits to letters is based on the traditional telephone keypad.

  - **letter_combinations Function**: A recursive function to find all possible letter combinations for a given phone number.
    - `digits`: A string containing the digits from 2-9.
    - This function returns a list of all possible letter combinations.
    - The function uses a helper function `backtrack` to perform backtracking and explore all possible combinations.
    - The `phone_map` dictionary maps each digit to its corresponding letters.
    - The `backtrack` function iterates over all letters that map to the next available digit, appending the current letter to the combination and proceeding with the next digit until all digits are processed.
* Day 129: Pneumonia Detection Using Deep Learning

  - **Pneumonia Detection System**: Developed a deep learning model to detect pneumonia from chest X-ray images. This project includes data wrangling, model training, and evaluation using TensorFlow.

    - **Data Collection and Preparation**: 
      - **Dataset**: Utilized a dataset from Kaggle containing chest X-ray images categorized as "NORMAL" or "PNEUMONIA".
      - **Pathlib for File Handling**: Separated the dataset into training, validation, and test sets using Pathlib.
      - **Data Wrangling**: Generated labels for the images based on their directory names.

    - **Model Development**: 
      - **Data Preprocessing**: Implemented functions to load, transform, and create TensorFlow datasets from the image paths and labels.
      - **Model Architecture**: Used ResNet50V2 as the backbone for the CNN model, followed by GlobalAveragePooling2D and Dense layers with a sigmoid activation function.
      - **Regularization Techniques**: Added dropout and L2 regularization to improve model generalization and prevent overfitting.

    - **Model Training**: 
      - **Compilation**: Compiled the model with the Adam optimizer and binary cross-entropy loss, tracking accuracy, precision, and recall metrics.
      - **Callbacks**: Implemented ModelCheckpoint and EarlyStopping to save the best model and stop training early if no improvement was observed.
      - **Training Process**: Trained the model on the training dataset, validating it with the validation dataset over multiple epochs.

    - **Evaluation and Interpretation**: 
      - **Model Evaluation**: Evaluated the model on the test dataset to calculate accuracy, precision, and recall.
      - **Visualizations**: Plotted the training and validation metrics over epochs to interpret the model's performance.

    - **Complete Model and Deployment**: 
      - **Saving the Model**: Saved the best model weights and the complete trained model for future use.
      - **Loading and Testing**: Loaded the saved model and tested it on new images to ensure it works as expected.

    This project demonstrates the use of deep learning for medical image classification, involving data preprocessing, model building, training, and evaluation with TensorFlow. It provides a comprehensive solution for detecting pneumonia from chest X-rays, showcasing the potential of AI in healthcare.
* Day 130: Technical Test "WildcardisMatch" and "jump" [LeetCode](https://leetcode.com/problems/)
  - **WildcardisMatch**: Given an input string `s` and a pattern `p`, implement wildcard pattern matching with support for `?` and `*`. The `?` matches any single character, while the `*` matches any sequence of characters (including the empty sequence). The solution should cover the entire input string, not just a partial match. This problem involves using dynamic programming to efficiently manage the different matching scenarios and ensure the pattern matches the entire string. [Problem Description](https://leetcode.com/problems/wildcard-matching/description/)
  - **jump**: Given a 0-indexed array of integers `nums` of length `n`, where each element `nums[i]` represents the maximum length of a forward jump from index `i`, return the minimum number of jumps to reach `nums[n - 1]`. The solution should use a greedy algorithm to track the farthest point that can be reached and count the jumps needed to reach the last index. The test cases guarantee that you can reach the last index. [Problem Description](https://leetcode.com/problems/jump-game-ii/description/)
* Day 131: 🐕 Dogs vs Cats 🐈 [Kaggle](https://www.kaggle.com/datasets/salader/dogs-vs-cats)

  * Today, I worked with the Dogs vs Cats dataset from Kaggle, focusing on developing a Convolutional Neural Network (CNN) to classify images of dogs and cats. Here's a summary of what I accomplished:
    - **Data Preparation**: Downloaded and extracted the dataset, and created training and validation datasets using TensorFlow’s `image_dataset_from_directory` function. The images were normalized for better model performance.
    - **Model Architecture**: Built a CNN using Keras, consisting of multiple Conv2D layers with Batch Normalization and MaxPooling. The model included three Conv2D layers with increasing filter sizes (32, 64, 128) to extract features from the images.
    - **Fully Connected Layers**: Added fully connected Dense layers to the model, with Dropout for regularization, to perform the final classification.
    - **Model Compilation**: Compiled the model with Adam optimizer and binary cross-entropy loss function, suitable for binary classification tasks.
    - **Training**: Trained the model on the prepared dataset for 9 epochs, validating its performance on the validation dataset. Visualized the training and validation accuracy and loss over epochs using Matplotlib.
    - **Testing**: Tested the model with sample images of dogs and cats to verify its predictions.

  This project highlights the importance of proper data preprocessing, designing a robust neural network architecture, and evaluating the model's performance to achieve accurate image classification. The insights and models developed can be further refined and used for various image classification tasks.
* Day 132: 🎬 Object-Oriented Programming in Python with Movie Subscription System 🎬

  * Today, I worked on a movie subscription system project to reinforce the principles of Object-Oriented Programming (OOP) in Python. This project incorporates key OOP concepts such as inheritance, encapsulation, and abstraction. Here's a summary of what I accomplished:

    - **Abstraction and Encapsulation**: Created an abstract base class `Person` to represent common attributes and behaviors for both viewers and directors. Encapsulated the name and ID number attributes to protect them from direct modification. Implemented abstract methods to enforce a consistent interface for subclasses.
    - **Inheritance**: Developed two subclasses, `Viewer` and `Director`, inheriting from the `Person` class. These subclasses extend the base class by adding specific attributes and methods like subscribing to genres and adding movies to the director's filmography.
    - **Movie Management**: Created a `Movie` class to represent a movie, including attributes for the movie title, genre, director, rating, and duration. Added methods to handle movie details and categorize movies by genre.
    - **User Interaction**: Implemented a menu-driven interface to allow users to subscribe viewers to genres, display viewer details, and show movie information. This interactive component showcases how OOP can be used to structure complex, real-world applications.
    - **Data Storage**: Used dictionaries to manage and store viewer instances, demonstrating the practical use of data structures in conjunction with OOP to handle multiple objects efficiently.

  This project provided a comprehensive exercise in applying OOP principles to a realistic scenario, reinforcing the importance of well-structured, maintainable, and scalable code.
* Day 133: 🤖 Implementing a Simple Neural Network in Python with Backpropagation 🤖

  * Today, I worked on a project to build a simple neural network from scratch in Python, focusing on the fundamental concepts of neural networks and backpropagation. Here's a summary of what I accomplished:

    - **Activation Function**: Implemented the sigmoid function and its derivative, which are essential for the forward and backward passes in the neural network.
    - **Loss Function**: Used the mean squared error (MSE) as the loss function to measure the performance of the neural network.
    - **Network Initialization**: Created a `NeuralNetwork` class with two hidden layers. Randomly initialized the weights for connections between the input layer, hidden layers, and output layer.
    - **Forward Propagation**: Developed a method to pass input data through the network, compute the activations of the hidden layers and the final output.
    - **Backward Propagation**: Implemented the backpropagation algorithm to update the weights based on the error between predicted and actual outputs. This involved calculating deltas for each layer and adjusting the weights using the learning rate.
    - **Training the Network**: Trained the neural network using a small dataset, splitting it into training and validation sets. Monitored the training and validation loss to ensure the network was learning correctly.
    - **Prediction**: Added a function to test the trained network with new input data, demonstrating its ability to make predictions.

  This project provided a hands-on exercise in understanding and implementing the core components of a neural network, from initialization to training and prediction. It reinforced key concepts in machine learning, such as forward and backward propagation, weight updates, and performance evaluation.
* Day 134: ♟️ Building a Chess Game in Python with Object-Oriented Programming ♟️

  * Today, I worked on a project to create a chess game in Python, focusing on the principles of Object-Oriented Programming (OOP). This project involved designing classes for different chess pieces and implementing their movements on the board. Here's a summary of what I accomplished:

    - **ChessPiece Base Class**: Developed an abstract `ChessPiece` class to represent a generic chess piece. This class includes a `color` attribute and an abstract method `get_legal_moves` which must be implemented by subclasses.
    
    - **King Class**: Created a `King` class that inherits from `ChessPiece` and implements the `get_legal_moves` method to return all possible legal moves for the king, considering its unique movement rules.

    - **Queen Class**: Developed a `Queen` class that combines straight and diagonal moves, mimicking the behavior of both a rook and a bishop. This class uses helper methods `get_straight_moves` and `get_diagonal_moves` to calculate all legal moves.

    - **Rook Class**: Created a `Rook` class that inherits from `ChessPiece` and reuses the `get_straight_moves` method from the `Queen` class to determine its legal moves.

    - **Bishop Class**: Implemented a `Bishop` class that inherits from `ChessPiece` and reuses the `get_diagonal_moves` method from the `Queen` class to calculate its legal moves.

    - **Knight Class**: Designed a `Knight` class with a unique movement pattern, implementing its own `get_legal_moves` method to return all possible L-shaped moves.

    - **Pawn Class**: Developed a `Pawn` class that includes specific movement rules such as moving forward one or two squares from the starting position and capturing diagonally.

    - **ChessBoard Class**: Created a `ChessBoard` class to initialize the board with all pieces in their starting positions. This class includes methods to display the board, move pieces, check for valid moves, and evaluate the position.

    - **Move Validation**: Implemented logic in the `move_piece` method to ensure moves are legal according to each piece's movement rules. This method also switches the current turn between white and black players.

    - **Evaluation and Legal Moves Generation**: Added methods to evaluate the board's position and generate all legal moves for a given color, providing a foundation for future enhancements like check and checkmate detection.

  This project provided a comprehensive exercise in applying OOP principles to a classic game, reinforcing the importance of creating maintainable and scalable code. It also offered a practical way to implement and test various chess piece movements and game mechanics.
* Day 135: ☕ Analyzing Worldwide Coffee Consumption Trends with Python ☕

  Today, I focused on a data analysis project that examines coffee consumption patterns across various countries using a dataset that spans from 2000 to 2023. This project provided valuable insights into how coffee is enjoyed around the world. Here's a summary of what I accomplished:

  - **Loading the Data**: Imported the dataset containing information on coffee consumption, prices, types of coffee consumed, and population for different countries.

  - **Data Exploration**: Explored the dataset to understand its structure, including the number of records, data types, and basic statistics.
    - **Fields and Data Types**:
      - `Country`: The name of the country where the data was collected.
      - `Year`: The year of the record, spanning from 2000 to 2023.
      - `Coffee Consumption (kg per capita per year)`: The amount of coffee consumed per person annually.
      - `Average Coffee Price (USD per kg)`: The average price of coffee per kilogram in US dollars.
      - `Type of Coffee Consumed`: The most popular types of coffee enjoyed in each country.
      - `Population (millions)`: The estimated population of each country.

  - **Data Cleaning**: Renamed columns to remove spaces and make them more code-friendly.

  - **Handling Missing Data**: Checked for and handled any missing data to ensure the dataset was complete and accurate for analysis.

  - **Exploratory Data Analysis (EDA)**: Conducted various analyses to gain insights into the data:
    - **Distributions**: Plotted histograms for numerical features to understand their distributions.
    - **Trends Over Time**: Analyzed the number of records per year for different types of coffee.
    - **Correlation Analysis**: Created a heatmap to visualize the correlations between numerical features.
    - **Pie Charts**: Visualized the distribution of different types of coffee consumed.
    - **Stacked Bar Chart**: Showed the trends of coffee types consumed over the years.
    - **Box Plot**: Compared coffee prices across different countries.
    - **Top Countries Analysis**: Identified and analyzed the top 10 countries by average coffee consumption.
    - **Heatmap**: Displayed the distribution of different types of coffee consumed across countries.

  This project provided a comprehensive exercise in data analysis, helping to reinforce key concepts in data cleaning, exploration, visualization, and interpretation.
* Day 136: Technical Test "permute" and "permuteUnique" [LeetCode](https://leetcode.com/problems/)
  - **permute**: Given an array `nums` of distinct integers, return all possible permutations. The solution involves using backtracking to generate permutations by swapping elements and recursively building each permutation until the entire array is permuted. [Problem Description: Permutations](https://leetcode.com/problems/permutations/description/)
  - **permuteUnique**: Given a collection of numbers that might contain duplicates, return all possible unique permutations. The solution sorts the input array and uses backtracking with a set to skip over duplicate elements during the permutation process. [Problem Description: Permutations II](https://leetcode.com/problems/permutations-ii/description/)
* Day 137: Test Projects "NotesManager"
  * Today, we're focusing on writing unit tests for a simple Note Manager application. Testing is a crucial part of software development, ensuring that our code works as expected and helps prevent bugs from creeping into our projects. We'll use Python's unittest module to create and run our tests. This exercise will help you understand the basics of writing tests and how to use them to verify the correctness of your code.
* Day 138: 🐾 Developing a Pet Store Management System in Python with Unit Testing 🐾

  * Today, I worked on a project to create a Pet Store Management System in Python, emphasizing the principles of Object-Oriented Programming (OOP) and unit testing. This project involved designing classes for customers, staff, and pets, and implementing a menu-driven interface for interactions. Here's a summary of what I accomplished:

    - **Person Base Class**: Developed an abstract `Person` class to represent a generic person in the system, including attributes for name and ID number. This class also includes an abstract method `get_description` which must be implemented by subclasses.

    - **Customer Class**: Created a `Customer` class that inherits from `Person` and includes methods to adopt pets and retrieve a list of adopted pets. The class also implements the `get_description` method to return customer details.

    - **Staff Class**: Developed a `Staff` class that inherits from `Person` and includes methods to assign pets to staff and retrieve a list of assigned pets. This class also implements the `get_description` method to return staff details.

    - **Pet Class**: Designed a `Pet` class with attributes for name, breed, age, and price. This class includes a method `get_description` to return pet details.

    - **Menu Interface**: Implemented a menu-driven interface that allows users to adopt a pet, display customer details, and display pet details. The interface interacts with the `Customer`, `Staff`, and `Pet` classes to manage the store's operations.

    - **Unit Testing**: Wrote comprehensive unit tests using Python's `unittest` module to verify the functionality of the application. The tests cover:
      - Adding pets to customers and ensuring they are correctly added to the list.
      - Assigning pets to staff and verifying the assignment.
      - Retrieving and verifying descriptions of customers, staff, and pets.

  This project provided an in-depth exercise in applying OOP principles and writing effective unit tests to maintain code quality. It reinforced the importance of encapsulation, inheritance, and abstraction in creating maintainable and scalable code.
* Day 139: Top 20 Play Store App Reviews [Kaggle](https://www.kaggle.com/datasets/odins0n/top-20-play-store-app-reviews-daily-update/data)

  * Today, I worked with the Top 20 Play Store App Reviews dataset from Kaggle, focusing on analyzing review sentiments using the DistilBERT model. Here's a summary of what I accomplished:
    - **Data Loading**: Loaded the dataset using Pandas to get a comprehensive view of the reviews and their scores.
    - **Review Analysis**: 
      - Visualized the distribution of review scores to understand the general sentiment of the reviews.
      - Sampled 200 reviews from the dataset for detailed analysis.
    - **Sentiment Analysis with DistilBERT**:
      - Utilized the DistilBERT model for sentiment analysis. The model was fine-tuned on the SST-2 dataset for sentiment classification.
      - Created a sentiment analysis pipeline using the model and tokenizer.
      - Performed sentiment analysis on the reviews and added the results to the dataset.
    - **Visualization**:
      - Plotted the distribution of sentiments (Positive vs. Negative) to get an overview of the sentiment spread.
    - **Model Evaluation**:
      - Evaluated the model's performance using a confusion matrix and classification report.
      - Compared the sentiment analysis results with the actual review scores to assess the model's accuracy.
    - **Key Insights**:
      - The model achieved an overall accuracy of 85% in predicting sentiments.
      - Highlighted the balance between precision and recall, showing effective performance in classifying both positive and negative reviews.

  This project demonstrates the practical application of pre-trained transformer models in sentiment analysis, emphasizing the importance of data preprocessing, model evaluation, and visualization in deriving meaningful insights from textual data.
* Day 140: 🎮 Memory Game 🎮
  * Today, I created a memory game using Pygame, focusing on building a fun and interactive application that challenges players to find matching pairs of colored cards. Here's a summary of what I accomplished:
    - **Game Setup**: Initialized Pygame and set up the display with a grid of cards.
    - **Card Generation**: 
      - Defined a set of colors and created pairs for the memory game.
      - Shuffled the colors and assigned them to the cards in a grid layout.
    - **Game Logic**: 
      - Implemented the logic for flipping cards and checking for matches.
      - Handled user input to select and flip cards, and checked for matched pairs.
      - Included a mechanism to hide unmatched cards after a short delay.
    - **Graphics and Display**:
      - Drew the cards on the screen, showing either the card back or the front color based on their state.
      - Added text to display a winning message when all pairs are found.
    - **Game Loop**: 
      - Managed the main game loop to handle events, update the game state, and redraw the screen.
      - Ensured the game runs smoothly and responds to user actions.

  This project highlights the use of Pygame for game development, emphasizing the importance of game logic, user interaction, and visual display to create an engaging user experience. The memory game is a great way to practice Pygame and develop skills in interactive application design.
* Day 141: 🧮 EMI Calculator with Tkinter and Matplotlib 📊
  * Today, I developed an EMI (Equated Monthly Installment) Calculator using Tkinter for the GUI and Matplotlib for visualizing the EMI breakdown. This project involved creating a user-friendly interface and implementing the logic for EMI calculation and graphical representation. Here's a summary of what I accomplished:

    - **GUI Setup**:
      - Created the main window using Tkinter and set the title and background color.
      - Registered validation commands to ensure the user inputs are valid.

    - **Input Fields**:
      - Added input fields for total loan amount, loan period (years and months), and interest rate.
      - Used Tkinter's Entry widget for text inputs and Spinbox for selecting years and months.

    - **Calculation Logic**:
      - Implemented the EMI calculation formula to compute the monthly payment.
      - Calculated the total payment, interest amount, and the breakdown of payments over time.

    - **Result Display**:
      - Formatted and displayed the calculation results in a message box.
      - Showed the monthly payment, total EMI period, total amount, interest amount, and total payment.

    - **Graphical Visualization**:
      - Utilized Matplotlib to plot the EMI breakdown over time.
      - Displayed the balance, interest, and principal components month-wise in a line graph.
      - Added titles, labels, legends, and grid to the plot for better readability.

    - **Clear Functionality**:
      - Implemented a clear function to reset all input fields and prepare the form for new input.

    This project demonstrates the integration of Tkinter for building interactive GUI applications and Matplotlib for data visualization. The EMI Calculator is a practical tool for understanding loan repayment schedules and visualizing the impact of different loan parameters.
* Day 142: Technical Test "rotate" and "groupAnagrams" [LeetCode](https://leetcode.com/problems/)
  - **rotate**: This function rotates an `n x n` 2D matrix by 90 degrees clockwise. The solution involves first transposing the matrix (swapping rows and columns) and then reversing each row. [Problem Description: Rotate Image](https://leetcode.com/problems/rotate-image/description/)
  - **groupAnagrams**: This function groups anagrams together from a list of strings. The solution uses a dictionary where the key is the sorted version of the word and the value is the list of words that, when sorted, match the key. [Problem Description: Group Anagrams](https://leetcode.com/problems/group-anagrams/description/)
* Day 143: 🎵 Object-Oriented Programming in Python with Music Subscription System 🎵
  * Today, I worked on a music subscription system project to reinforce the principles of Object-Oriented Programming (OOP) in Python. This project incorporates key OOP concepts such as inheritance, encapsulation, and abstraction. Here's a summary of what I accomplished:
    - **Abstraction and Encapsulation**: Created an abstract base class `Person` to represent common attributes and behaviors for both listeners and artists. Encapsulated the name and ID number attributes to protect them from direct modification. Implemented abstract methods to enforce a consistent interface for subclasses.
    - **Inheritance**: Developed two subclasses, `Listener` and `Artist`, inheriting from the `Person` class. These subclasses extend the base class by adding specific attributes and methods like subscribing to genres and adding songs to the artist's discography.
    - **Song Management**: Created a `Song` class to represent a song, including attributes for the song title, genre, artist, rating, and duration. Added methods to handle song details and categorize songs by genre.
    - **User Interaction**: Implemented a menu-driven interface to allow users to register listeners and artists, subscribe listeners to genres, register songs, display listener details, display song information, and show artist details. This interactive component showcases how OOP can be used to structure complex, real-world applications.
    - **Data Storage**: Used dictionaries to manage and store listener, artist, and song instances, demonstrating the practical use of data structures in conjunction with OOP to handle multiple objects efficiently.

  This project provided a comprehensive exercise in applying OOP principles to a realistic scenario, reinforcing the importance of well-structured, maintainable, and scalable code.
* Day 144: 🌀 Mandelbrot Set Visualization 🌀
  * Today, I delved into the fascinating world of fractals by visualizing the Mandelbrot set using Python. This project involved implementing the mathematical principles behind the Mandelbrot set and generating a beautiful visual representation. Here's a summary of what I accomplished:

    - **Mathematical Foundations**: Implemented the Mandelbrot sequence using a function that iterates a complex number to determine if it belongs to the Mandelbrot set. The function returns the iteration count, which is used to determine the color of each point in the visualization.
    - **Grid Creation**: Generated a grid of complex numbers representing the real and imaginary parts of the Mandelbrot set. Used `numpy` to create linear spaces for the real and imaginary components, and iterated over this grid to compute the Mandelbrot values.
    - **Visualization**: Utilized `matplotlib` to plot the computed Mandelbrot set. Applied a color map to visually represent the iteration count, creating a vivid and intricate fractal image. Added labels and a color bar for better readability.
    - **Code Organization**: Structured the code into functions to improve readability and maintainability. This modular approach ensures that each part of the computation and visualization process is clearly defined and easy to understand.
    - **Inspiration**: Based this project on a tutorial by NeuralNine. You can watch the video here: [NeuralNine YouTube Tutorial](https://www.youtube.com/watch?v=xjjmkg9J7Gg).

  This project provided a deep dive into both mathematical computation and data visualization, reinforcing the importance of combining theoretical concepts with practical implementation.
* Day 145: 🌳 Recursive Tree Animation 🌳
  * Today, I explored the world of recursive graphics by creating an animated visualization of a fractal tree using Python. This project combined recursion with animation to produce a dynamic and captivating visual representation. Here's a summary of what I accomplished:

    - **Recursive Tree Drawing**: Implemented a recursive function to draw a tree. The function calculates the end points of each branch using trigonometric functions and recursively draws smaller branches at specified angles. This method creates the characteristic fractal structure of a tree.
    - **Animation Setup**: Used `matplotlib` and `numpy` to set up the initial figure and axis for the animation. Defined the limits and aspect ratio to ensure the tree is displayed correctly.
    - **Frame Updates**: Created an animation function that updates the tree's depth with each frame, gradually increasing the depth of recursion to animate the growth of the tree. This function clears the previous frame, sets the axis limits, and draws the tree with the current depth.
    - **Creating the Animation**: Utilized `matplotlib.animation.FuncAnimation` to create the animation. Defined the initial and maximum depth, and set the interval between frames to control the animation speed.
    - **Displaying the Animation**: Configured `matplotlib` to display the animation, showcasing the growth of the fractal tree in real-time.

  This project provided an exciting opportunity to delve into recursive algorithms and animation techniques, demonstrating the power of combining mathematical concepts with visual art.
* Day 146: 🏦 ATM Machine Simulation 🏦
  * Today, I ventured into the realm of GUI programming by creating an ATM machine simulation using Python and Tkinter. This project involved developing a user-friendly interface that mimics the functionalities of a real ATM, providing an interactive experience for users. Here's a summary of what I accomplished:

    - **GUI Design**: Designed the main application window with Tkinter, setting up the initial balance and PIN. Configured the window to be non-resizable and applied a consistent color scheme for a professional look.
    - **PIN Validation**: Implemented a PIN entry system to authenticate users. The application verifies the entered PIN and provides appropriate feedback using message boxes.
    - **ATM Menu**: Created a menu with options to check balance, deposit money, withdraw money, and exit. Each menu option is linked to its corresponding function, ensuring smooth navigation.
    - **Balance Check**: Developed a function to display the current balance in a message box.
    - **Deposit Money**: Added functionality to allow users to deposit money into their account. Implemented input validation to ensure the deposited amount is a positive number.
    - **Withdraw Money**: Enabled users to withdraw money, with validation to check for sufficient balance and ensure the withdrawn amount is positive.
    - **Code Organization**: Structured the code into functions and classes to enhance readability and maintainability. This modular approach ensures that each part of the application is clearly defined and easy to understand.

  This project provided valuable insights into GUI development and user interaction, demonstrating the importance of creating intuitive and functional interfaces.
* Day 147: Technical Test "myPow" and "NQueens" [LeetCode](https://leetcode.com/problems/)
  - **myPow**: Implemented a function that calculates \( x^n \) (x raised to the power n) efficiently. This problem involves optimizing the power calculation by leveraging recursion and handling edge cases such as negative powers. [Problem Description: myPow](https://leetcode.com/problems/powx-n/description/)
  - **NQueens**: Solved the N-Queens problem, which involves placing n queens on an n x n chessboard so that no two queens attack each other. The solution uses backtracking to explore all possible placements and returns all distinct configurations. [Problem Description: NQueens](https://leetcode.com/problems/n-queens/description/)
* Day 148: 🎮 Video Game Subscription System in Python 🎮

  * Today, I expanded my understanding of Object-Oriented Programming (OOP) by developing a Video Game Subscription System using Python. This project leverages fundamental OOP principles such as inheritance, encapsulation, and abstraction. Here’s a summary of the key elements:

    - **Abstraction and Encapsulation**: Defined an abstract base class `Person` representing common features for both `Player` and `Developer`. Encapsulated attributes like name and ID number to ensure data integrity. The abstract method `get_description` enforces a consistent interface for subclasses.
    - **Inheritance**: Created two subclasses, `Player` and `Developer`, that inherit from `Person`. These subclasses add specific attributes and methods, such as subscribing to game genres for `Player` and adding games to a portfolio for `Developer`.
    - **Game Management**: Introduced a `Game` class to represent individual games, including details such as title, genre, developer, rating, and release year. Methods within this class manage game-related information and allow interaction with player and developer objects.
    - **User Interaction**: Built a menu-driven interface allowing users to register players and developers, add new games, subscribe players to game genres, and display details for players, games, and developers. This interactive component illustrates the practical application of OOP in creating user-friendly software systems.
    - **Data Organization**: Employed dictionaries to efficiently manage and store instances of players, developers, and games. This approach highlights the integration of OOP and data structures to handle complex, real-world data scenarios.

  This project provided an engaging and insightful exercise in implementing OOP principles to simulate a real-world application, reinforcing the importance of design patterns and code maintainability.
* Day 149: 🧩 Wordle Game with Flask and CSS 🖥️

  * Today, I worked on developing a Wordle-inspired game using Flask for the backend and custom CSS for styling. This project integrates web development skills with game logic to create an interactive user experience. Here’s a summary of the key components:

    - **Flask Application**: Implemented a Flask application to handle game logic, including word selection, guess validation, and feedback management. Used session variables to track game state, including the target word, attempts, and game status.
    - **Word Management**: Loaded a list of possible words from a text file and used it to randomly select a word for each game session. Validated player guesses against this word and provided feedback on correctness, presence, or absence of letters.
    - **User Interface**: Designed a user-friendly interface using HTML and CSS, featuring forms for guess input, feedback display, and game status updates. The interface also includes a responsive design to ensure compatibility across different devices.
    - **Feedback System**: Incorporated a feedback mechanism to visually represent the correctness of each guessed letter, including color-coded indicators for correct, present, and absent letters.
    - **Game Flow Control**: Managed game flow with options to restart the game or handle game-over scenarios, providing an engaging experience with clear instructions and error handling.

  This project allowed me to apply web development and design skills in a practical context, creating an enjoyable and visually appealing game experience.

* Day 150: 🧠 Brain Tumor Dataset 🧠 Analysis [Kaggle](https://www.kaggle.com/datasets/odins0n/brain-tumor-dataset)

  * Today, I worked with the Brain Tumor dataset from Kaggle, focusing on exploring various aspects of the data and performing detailed analyses. Here's a summary of what I accomplished:
    - **Data Loading**: Loaded the dataset using Pandas, and explored the initial structure of the data.
    - **Data Cleaning**:
      - Renamed columns for consistency and easier access.
      - Checked for and handled missing data, ensuring the dataset was ready for analysis.
    - **Exploratory Data Analysis (EDA)**:
      - **Categorical Features**: 
        - Created count plots for features like Tumor Type, Location, and Gender to visualize their distributions.
        - Analyzed the correlation between Tumor Location and Grade using a heatmap.
      - **Numerical Features**:
        - Generated correlation heatmaps to understand relationships between numeric features like Age and Tumor Size.
        - Visualized the distribution of Tumor Grade by Age and Gender, and Tumor Size by Type and Grade.
      - **Outlier Detection**:
        - Used boxplots to detect outliers in Age and Tumor Size, identifying specific data points for further investigation.
    - **Principal Component Analysis (PCA)**:
      - Applied PCA to reduce dimensionality, focusing on numeric features like Age and Size.
      - Visualized the resulting principal components to explore potential clustering by Tumor Type.
    - **Feature Engineering**:
      - Grouped Age into categories to simplify analysis.
      - Created a binary feature indicating whether a tumor was in a critical location.
    - **Automated Report**:
      - Developed functions to generate a statistical summary, distribution graphs, and correlation analysis for both numerical and categorical variables.
      - Automated the generation of visual and textual insights from the dataset.

  * This work provided valuable insights into the distribution and relationships within the dataset, which could be crucial for understanding and predicting outcomes related to brain tumors. The automated report functions developed can also be reused for similar datasets in future projects.
* Day 151: 🏗️ Tower of Babel - Recursive Algorithm 🏗️

  * Today, I implemented and explored the Tower of Babel problem, a variation of the classic Tower of Hanoi, using a recursive algorithm. This project focused on moving blocks from one position to another following specific rules. Here's a summary of what I accomplished:
    - **Recursive Function Design**:
      - Developed a recursive function `build_tower` that moves blocks between positions to simulate the construction of a tower.
      - The base case handles the movement of a single block, while the recursive case manages the movement of multiple blocks.
    - **Block Movement Logic**:
      - Implemented the `move_block` function to transfer blocks between positions, ensuring that each move is printed to the console for clarity.
    - **Initial and Final Tower States**:
      - Initialized the tower with a specific number of blocks in one position.
      - The recursive process successfully moved all blocks to the target position, maintaining the rules of the problem.
    - **Visualization and Debugging**:
      - Provided clear output of the tower's state before and after the recursive process, aiding in debugging and understanding the algorithm's flow.
      - Used print statements to trace each block movement, making it easier to follow the recursive calls.

  * This exercise was a great opportunity to reinforce my understanding of recursion, particularly in solving problems that involve multiple recursive calls and complex state management. The Tower of Babel problem also highlights the importance of clear base cases and recursive steps in algorithm design.
* Day 152: Technical Test "totalNQueens" and "maxSubArray" [LeetCode](https://leetcode.com/problems/)
  - **totalNQueens**: Implemented a solution to the N-Queens II problem, which involves counting the number of distinct solutions for placing n queens on an n x n chessboard so that no two queens attack each other. The solution uses backtracking to explore all valid placements and utilizes arrays to track columns and diagonals that are under attack. The efficient marking and unmarking of attacked positions allow the algorithm to explore all configurations systematically. [Problem Description: totalNQueens](https://leetcode.com/problems/n-queens-ii/description/)

  - **maxSubArray**: Solved the Maximum Subarray problem, where the goal is to find the contiguous subarray within a one-dimensional numeric array that has the largest sum. The solution employs a dynamic programming approach, where the maximum sum is updated as the algorithm iterates through the array, considering each element either as a standalone subarray or as an extension of the previous subarray. This approach ensures an optimal solution with a time complexity of O(n). [Problem Description: maxSubArray](https://leetcode.com/problems/maximum-subarray/description/)
* Day 153: 🎮 Rock Paper Scissor Game with Tkinter 🎮

  * Today, I developed a Rock Paper Scissor game using Python's Tkinter library. The game allows the player to select between Rock, Paper, or Scissors, while the computer randomly selects its move. Here’s a summary of the key components of this project:
    - **Graphical User Interface (GUI) Design**:
      - Created an intuitive and user-friendly interface with buttons for the player's choices, as well as labels for displaying the results.
      - Utilized Tkinter widgets such as `Label`, `Button`, and `Frame` to organize the layout and display game elements.
    - **Game Logic Implementation**:
      - Implemented the game logic for Rock, Paper, Scissors, where the player’s choice is compared with the computer’s random selection.
      - Handled different outcomes such as "Player Wins", "Computer Wins", or "Match Draw" based on the rules of the game.
    - **Reset and State Management**:
      - Added a reset button to allow players to restart the game without closing the application.
      - Disabled buttons after each round to prevent multiple choices in a single game, ensuring a fair gameplay experience.
    - **Random Computer Selection**:
      - Used Python's `random` library to simulate the computer's choice, making the game unpredictable and engaging.

  * This project was a great way to practice my skills in building GUI applications with Tkinter, as well as implementing simple game mechanics in Python. It reinforced concepts such as event handling, state management, and the importance of a well-structured user interface.
* Day 154: 🏥 Medical Appointment System in Python 🩺

  * Today, I developed a Medical Appointment System using Python, implementing Object-Oriented Programming (OOP) principles such as inheritance, encapsulation, and abstraction. This project focuses on managing patients, doctors, and appointments in an organized and scalable manner. Here's a summary of the key features:

    - **Abstraction and Encapsulation**: Defined an abstract base class `Person` to represent common attributes for both `Patient` and `Doctor`, ensuring a consistent interface through the abstract method `get_description`. Encapsulated sensitive data like name and ID number to protect the integrity of the information.
    - **Inheritance**: Created two subclasses, `Patient` and `Doctor`, that extend the functionality of the `Person` class. The `Patient` class manages patient-specific data like age and appointments, while the `Doctor` class tracks the doctor's specialty and assigned patients.
    - **Appointment Scheduling**: Introduced an `Appointment` class to manage the scheduling of appointments between patients and doctors, storing details like date, time, and reason for the visit. This class ties together both patient and doctor information, ensuring smooth coordination.
    - **Menu-Driven Interaction**: Built a user-friendly interface that allows the registration of new patients and doctors, scheduling of appointments, and viewing detailed information about patients and doctors. This menu system showcases the integration of OOP with real-world applications.
    - **Data Management**: Used dictionaries to organize and store instances of patients and doctors efficiently. This approach facilitates quick access and updates to patient and doctor records, demonstrating the importance of effective data structures in software systems.

  This project was a great opportunity to practice implementing OOP concepts in a practical scenario, creating a robust system for managing medical appointments. It deepened my understanding of how OOP principles can streamline the organization of complex data and processes.
* Day 155: 🎬 Movie Ratings Analysis with PySpark and Seaborn 🎥 [Dataset](https://grouplens.org/datasets/rating-disposition-2023/)

  * Today, I worked on a data analysis project focused on movie ratings using PySpark for distributed data processing and Seaborn for visualizations. The project involved cleaning, processing, and analyzing a dataset of movie ratings to uncover trends and insights. Here's a breakdown of the key features:

    - **Data Processing with PySpark**: Utilized PySpark to handle a large dataset of movie ratings, allowing efficient computation on big data. I loaded the data into a DataFrame, filtered, and aggregated it using PySpark’s powerful functions like `groupBy`, `agg`, and `filter` to analyze ratings per movie and user.
    - **Average Rating Calculation**: Calculated the average rating for each movie and determined the number of ratings each movie received. This information was crucial for identifying popular movies and trends in user preferences.
    - **User Activity Analysis**: Analyzed user behavior by calculating the average rating given by each user and identifying the most active users, showcasing how PySpark can be used to extract valuable insights from large datasets.
    - **Visualization with Seaborn**: Converted the PySpark DataFrame to a pandas DataFrame and used Seaborn to create a bar chart representing the distribution of ratings across movies. This visual representation helped highlight the most common rating values and their occurrences.
    - **Interactive Data Exploration**: Implemented a menu-driven interface allowing exploration of the data, including displaying top-rated movies, most active users, and the distribution of ratings. This approach ties together both data processing and visualization in a cohesive project.

  This project was a great opportunity to dive deeper into big data processing with PySpark, as well as exploring data visualization techniques with Seaborn. It enhanced my ability to work with large datasets and transform them into meaningful insights, while reinforcing the importance of visualizations in data analysis.
* Day 156: 🗒️ To-Do List Application with Flet 📝

  * Today, I created a To-Do List application using Flet, a modern framework for building interactive web applications in Python. This project was a fantastic exercise in using Flet to manage user input, display dynamic content, and handle interactive events. Here's a summary of the key features:

    - **User Interface Design**: Designed a clean and user-friendly interface with a centered layout. The application features a title, input field, and button for adding tasks, along with a dynamically updated list of tasks.
    - **Task Management**: Implemented functionality to add new tasks to the list and display them with checkboxes. Tasks are displayed in a list view, allowing users to see and manage their to-dos easily.
    - **Interactive Elements**: Incorporated interactive elements such as a `TextField` for task input and a `FilledButton` to add tasks. Added checkboxes next to each task to allow users to mark tasks as completed.
    - **Dynamic Updates**: Created functions to update the task list and display selected tasks based on user interactions. The list updates in real-time to reflect new tasks and changes in task selection.
    - **Data Handling**: Used a list to manage and store tasks, and updated the displayed list dynamically. The application tracks which tasks are selected and updates the display accordingly.

  This project was an excellent opportunity to explore Flet's capabilities in building interactive web applications and to apply concepts of UI design and event handling in a practical context.
* Day 157: Technical Test "spiralOrder" and "canJump" [LeetCode](https://leetcode.com/problems/)

  - **spiralOrder**: Solved the Spiral Matrix problem, where the task is to traverse a 2D matrix in spiral order and return the elements in the order they are visited. The algorithm follows a structured approach by traversing the matrix in four directions (right, down, left, up) while adjusting the boundaries (top, bottom, left, right) as the spiral tightens. This method ensures that each element is visited exactly once. The solution has a time complexity of O(m * n), where m and n are the dimensions of the matrix. [Problem Description: Spiral Order](https://leetcode.com/problems/spiral-matrix/description/)

  - **canJump**: Implemented a solution for the Jump Game problem, which asks whether it is possible to reach the last index of an array given that each element represents the maximum jump length from that position. The algorithm utilizes a greedy approach to track the farthest reachable index as it iterates through the array. If at any point the current index is beyond the farthest reachable index, the function returns `False`. Otherwise, it returns `True` if the last index is reachable. This solution operates in linear time with a time complexity of O(n). [Problem Description: Can Jump](https://leetcode.com/problems/jump-game/description/)
* Day 158: 🖌️ Floodfill Image Color Changer with Tkinter 🖌️

  * Today, I created a graphical application in Python using Tkinter that allows users to apply a floodfill operation to an image. The application provides a simple interface for loading an image, selecting a color, and applying the floodfill to change the color of a specific region. Here’s a summary of the key components of this project:
    - **Image Loading and Display**:
      - Implemented a file dialog to allow users to select an image from their system. The selected image is then displayed on a Tkinter canvas.
      - Utilized the PIL (Python Imaging Library) to handle image loading and conversion to the RGB format, ensuring compatibility with various image types.
    - **Floodfill Operation**:
      - Added a floodfill feature where the user can choose a color using a color chooser dialog, and apply it to a specific pixel on the image.
      - The floodfill algorithm fills all connected pixels with the chosen color, making it easy to change the appearance of large areas within the image.
    - **Saving the Modified Image**:
      - Integrated a save dialog that allows users to save the modified image in their desired format (PNG, JPEG, etc.).
      - Ensured that the application handles any errors during the save process, providing user feedback through message boxes.
    - **User Interface**:
      - Designed a clean and intuitive user interface with buttons for loading, applying floodfill, and saving the image. The interface is styled with colors and fonts to enhance the user experience.
    - **Error Handling**:
      - Included comprehensive error handling to manage issues like unsupported image formats, out-of-bound pixel selections, and file save errors, ensuring a robust application.

  * This project was an excellent exercise in working with images and enhancing my skills in Tkinter and PIL. It allowed me to delve deeper into image processing techniques and GUI development in Python.
* Day 159: 🏠 Real Estate Data Visualization with Folium 🗺️

  * Today, I worked on a project that visualizes real estate data using Folium, a powerful Python library for creating interactive maps. The project was inspired by a [NeuralNine](https://www.youtube.com/watch?v=5UQyxgiQAzk) video, which provided a great foundation for this type of data visualization. Here’s a summary of the key components of this project:
  
    - **Data Handling**:
      - Utilized the California Housing dataset provided by Scikit-Learn to analyze various features such as median house value, average number of rooms, and population.
      - Converted the dataset into a Pandas DataFrame for easy manipulation and analysis.

    - **Map Initialization**:
      - Created an interactive map centered on the average latitude and longitude of the data points.
      - Used Folium to set up the base map with a zoom level appropriate for visualizing the entire California region.

    - **Marker Creation**:
      - Iterated through each row of the dataset to add circle markers on the map, with each marker representing a location in the dataset.
      - Adjusted the size of the markers based on the normalized average number of rooms, providing a visual indication of housing density.
      - Applied a color gradient to the markers based on the median house value, allowing for quick visual identification of high-value areas.

    - **Popup Information**:
      - Added detailed popups to each marker, displaying information such as median house value, average rooms, population, and median income.
      - Ensured the popups are clear and informative, making the map not only visually appealing but also data-rich.

    - **Additional Features**:
      - Integrated a minimap plugin for better navigation and spatial context, enhancing the user’s ability to explore different regions.
      - Saved the final interactive map as an HTML file, making it easy to share and view on any web browser.

  * This project was a great exercise in combining data science with geographic visualization. It allowed me to deepen my understanding of how to represent complex datasets in a user-friendly manner using Python and Folium. Special thanks to NeuralNine for the inspiration!