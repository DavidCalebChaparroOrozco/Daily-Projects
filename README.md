# Daily-Projects
This repository contains my daily projects, challenging me to create something new every day. From small utilities to full-fledged applications, they reflect my growth as a developer. Each project has a brief description of technologies, challenges and lessons. It is a record of my progress and a constantly evolving portfolio.
* Day 01:  Polar Plots in Python with Matplotlib by Neural Nine
  * Today we learn how to work with polar coordinates and how to create polar plots in Python using Matplotlib.
* Day 02: Spotify Oldies Dataset 🎶: A Treasury of Classics [Kaggle](https://www.kaggle.com/datasets/kanchana1990/spotify-oldies-dataset/data)
  * Today I'm going to work with a dataset called Spotify Oldies Dataset: A Treasury of Classics.
* Day 03: Pomodoro Timer GUI
  * In this project, I developed a graphical user interface (GUI) for a Pomodoro Timer using Tkinter in Python. The Pomodoro Technique is a time management method that uses a timer to break down work into intervals, traditionally 25 minutes in length, separated by short breaks. This GUI application allows users to start, reset, and skip timers for Pomodoro sessions, short breaks, and long breaks, providing visual feedback on the remaining time for each interval. It serves as a practical tool for enhancing productivity and focus during work or study sessions.
* Day 04: To Do App
  * Today, I created a To Do application using Flask and SQLAlchemy. This app allows users to add, edit, and delete tasks, as well as mark them as completed or in progress. Users can also search and filter tasks by various criteria such as title, completion status, priority, and due date. Additionally, the app supports sorting tasks by ID, title, or completion status, and offers bulk actions to mark tasks as completed, in progress, or not completed. It's a simple yet practical tool for managing daily tasks efficiently.
* Day 05: ContactManager
  * This project involves creating a contact manager application using Python's Tkinter library. The ContactManager allows users to add, edit, view, and delete contacts. It provides features such as pagination, searching, importing/exporting contacts from/to CSV files, and input validation for contact details. It offers a user-friendly interface for managing contact information effectively.
* Day 06: Income Prediction Adult Income [Kaggle](https://www.kaggle.com/datasets/wenruliu/adult-income-dataset)
  * In today's project, I implemented a machine learning model to predict adult income using the Adult Income dataset. The dataset contains various demographic and employment-related features such as age, education level, occupation, and work hours per week, along with the target variable indicating whether an individual earns more than $50,000 annually. I utilized the Random Forest algorithm to train the model and extracted feature importance scores to identify the key factors influencing income prediction. The model achieved an accuracy of  0.86%, demonstrating its capability to classify individuals into different income groups. This project enhances my understanding of supervised learning techniques and their application in real-world scenarios.
* Day 07: Pokedex GUI Application
  * In this project, I developed a graphical user interface (GUI) application for a Pokedex using Python's Tkinter library. The Pokedex is a digital encyclopedia that catalogues information about different species of Pokémon, a popular franchise of fictional creatures.
* Day 08: Flet Chat Application
  * Created a chat application using Flet library in Python. This application allows users to join a chat room, send and receive messages in real-time. It features a graphical user interface (GUI) for displaying chat messages, input field for sending messages, and user authentication. The application utilizes Flet components for UI design and integrates functionalities for sending, receiving, and displaying messages efficiently. It serves as a practical tool for real-time communication and collaboration among users.
* Day 09: Video Game Sales [Kaggle](https://www.kaggle.com/datasets/gregorut/videogamesales/data)
  * Today's project delves into the world of video game sales analysis. Leveraging the Video Game Sales dataset from Kaggle, I explore trends and patterns in the gaming industry. This dataset contains information on video game sales across different platforms, regions, genres, and years, providing valuable insights into consumer preferences and market dynamics. Through data exploration, visualization, and potentially predictive modeling, I aim to uncover hidden gems and understand what makes a successful video game title. Stay tuned for the journey through pixels and polygons! 🎮✨
* Day 10: Summarize News Articles
  * Worked on a project to summarize news articles using web scraping and natural language processing libraries like newspaper3k and TextBlob.
* Day 11: Sudoku Solver
  * In this project, I've crafted a Sudoku solver leveraging the backtracking algorithm in Python. This application empowers users to input incomplete Sudoku puzzles, generating a valid solution for the board. To enhance user experience, I integrated the Tkinter graphical library to craft an interactive interface. Through this interface, users can input Sudoku numbers and witness the solution unfold step by step. This project not only offers an efficient solution for Sudoku puzzles but also serves as an educational tool to delve into backtracking algorithms and Python-based interactive user interfaces.
* Day 12: Snake Pygame
  * In today's project, I built a classic Snake game using Pygame, a popular Python library for creating 2D games. The Snake game is a timeless arcade classic where the player controls a snake that moves around the screen, eating food to grow longer while avoiding collisions with itself and the boundaries of the game area.
* Day 13: Titanic Dataset 🚢 [Kaggle](https://www.kaggle.com/c/titanic)
  * Today, we delve into the exciting world of data analysis with the famous Titanic dataset. This dataset, available on Kaggle, provides information about the passengers aboard the Titanic, including details such as age, gender, ticket class, fare paid, and more. Our task is to explore this dataset, understand its key features, and possibly develop predictive models to determine the likelihood of a passenger's survival based on various factors. Through this project, we will not only enhance our data analysis skills but also honor the memory of the Titanic passengers by extracting meaningful insights from this historic dataset.
* Day 14: Email Python
  * Today's project involves creating a Python script for sending automated emails. Leveraging libraries such as smtplib, schedule, and dotenv, we develop a script capable of sending daily inspirational emails to a specified email address. The script reads quotes from a file, selects a random quote, and sends it via SMTP protocol. Utilizing environment variables for storing email credentials ensures security and flexibility. By scheduling the script to run periodically using the schedule library, we automate the process of sending daily inspiration to recipients, fostering motivation and positivity. This project not only demonstrates practical use cases of Python for automation but also serves as a reminder of the power of uplifting messages in our daily lives.
* Day 15: Guess the Number
  * Today's project involves creating a number guessing game using Python's Tkinter library for building the graphical user interface (GUI). The game prompts the player to guess a randomly generated number between 1 and 99 within a limited number of attempts. Through input validation and dynamic feedback, the game guides the player to adjust their guesses until they either correctly identify the number or exhaust their attempts. This project not only showcases interactive GUI development with Tkinter but also reinforces concepts of random number generation, user input handling, and game logic implementation. It provides an entertaining and engaging experience for players while honing programming skills in Python. Can you beat the odds and guess the secret number? Let the guessing game begin! 🎲
* Day 16: Virtual Bookshelves
  * In this project, I'll create a virtual bookshelf management system using Python and SQLite. The application will allow users to add, remove, update, and view books in their virtual bookshelves. Each book will have attributes such as title, author, year published, and genre. The system will utilize SQLite for database management and provide a user-friendly interface for interacting with the bookshelves. This project aims to simulate real-world bookshelf management scenarios and provide users with a convenient way to organize their reading materials. Let's embark on the journey of building virtual bookshelves to enhance our reading experiences! 📚✨
* Day 17: RSS Feed Reader
  * In this project, I'll develop an RSS feed reader using Python and BeautifulSoup. The RSS feed reader will be capable of fetching and parsing RSS feeds from various sources. It will extract relevant information such as titles, descriptions, and links from the feeds, presenting them in a user-friendly format. By implementing this RSS feed reader, I aim to enhance my skills in web scraping, XML parsing, and data presentation. Stay tuned for an efficient tool to stay updated with the latest news and content from your favorite websites! 📰🚀
* Day 18: Customer Manager JSON
  * In this project, I've developed a customer management system using Python and JSON. The system allows users to store and manage information about customers, including names, email addresses, cities, etc. It implements functionalities such as searching for customers by name, updating contact information, deleting customers, and adding new customers. Leveraging JSON as the data storage format ensures portability and simplicity in data management. This project enhances my skills in file handling, data manipulation, and user interface design. It serves as a practical tool for organizing customer data efficiently and facilitating effective communication and interaction with clients. Let's embark on the journey of customer management and streamline the process of customer engagement! 📊👥
* Day 19: Expense Tracking App
  * Created an expense tracking application using Python's Tkinter library. This app allows users to record their expenses, including item name, price, and purchase date. Users can add, edit, delete, and view expense records, providing a convenient way to manage their finances. Additionally, the app calculates the total expense and remaining balance, offering insights into spending habits. It serves as a practical tool for budgeting and financial management. 📊💰
* Day 20: Hangman
  * Implemented the classic Hangman game using Python and Flask. Players can guess letters to reveal a hidden word within a limited number of attempts. The game features a user-friendly interface and supports error handling for invalid inputs. Test your vocabulary and strategic thinking in this timeless word-guessing challenge! 🎩🔤
* Day 21: Image Editor
  * In this project, I developed an image editor using Python and Tkinter. The Image Editor allows users to open image files, apply filters such as black and white, blur, sharpen, and more, flip and rotate images, draw lines over the images, change pen color, erase drawn lines, and save edited images. It provides a user-friendly interface for basic image editing tasks and serves as a practical tool for enhancing and modifying images. Let your creativity flow with the Image Editor! 🎨🖼️
* Day 22: Faker User
  * In this project, I utilized the Faker library in Python to generate synthetic user data. From names and email addresses to phone numbers and job titles, Faker User creates realistic user profiles effortlessly. Whether for testing, prototyping, or data augmentation, Faker User streamlines the process of generating diverse and customizable datasets.
* Day 23: Simple Stock Price (Steamlit)
  * Today's project revolves around creating a Simple Stock Price application using Streamlit. This application enables users to visualize stock price data, including closing prices, volume, and candlestick charts, for various companies. Leveraging the yfinance library, the app fetches historical stock data and presents it in an interactive and user-friendly manner. Users can select a company from a dropdown menu, view different metrics, and analyze performance metrics such as returns, volatility, and Sharpe ratio. With its intuitive interface and insightful visualizations, this project serves as a valuable tool for investors and enthusiasts alike to track and analyze stock market trends.
* Day 24: Quality Of Wine [Kaggle](https://www.kaggle.com/datasets/uciml/red-wine-quality-cortez-et-al-2009)
  * Exploring the quality of wine dataset from Kaggle, I aim to analyze factors influencing the quality of red wine. Leveraging data analysis and visualization techniques, I seek to uncover patterns and relationships among various chemical properties and wine quality ratings. By applying machine learning algorithms, I intend to develop predictive models to classify wine quality based on its attributes. This project provides insights into the intricate world of wine quality assessment and demonstrates the application of data science in the domain of viticulture. Cheers to discovering the essence of fine wine! 🍷📊
* Day 25: Extract Dominant Colors
  * In this project, I'll delve into the fascinating realm of image processing to extract the dominant colors from images. Utilizing Python libraries such as ColorThief and Matplotlib, I'll develop a script capable of identifying the primary colors present in an image. By analyzing color palettes and visualizing dominant hues, this endeavor aims to provide insights into the aesthetic composition of images. Join me as I explore the vibrant spectrum of colors and uncover the beauty hidden within digital imagery. 🎨🖼️
* Day 26: Tree Node
  * On day 26, I focused on the implementation of a fundamental data structure, the tree node. Through Python, I constructed a TreeNode class capable of representing nodes within a binary search tree. With the aid of methods like insertion and various traversal techniques (preorder, inorder, and postorder), I delved into the intricacies of managing and navigating through binary trees. This exploration lays the groundwork for comprehending more complex tree-based algorithms and data structures, providing a solid foundation for further study in computer science and programming. 🌳🔍
* Day 27: ML with FastAPI
  * Today we learn how to easily turn machine learning models into usable APIs using FastAPI in Python.
* Day 28: Tutorial Guide (Python Types Intro) [FastAPI](https://fastapi.tiangolo.com/python-types/)
  * On day 28, we delve into an essential aspect of Python programming - types. This tutorial guide provides an introduction to Python types, focusing particularly on their usage within the FastAPI framework. Understanding Python types is crucial for developing robust and maintainable code, and integrating this knowledge with FastAPI facilitates the creation of efficient and scalable web APIs. By exploring the intricacies of Python types within the context of FastAPI, we equip ourselves with powerful tools for building robust and type-safe applications. 🐍✨
* Day 29: Parking Space Counter
  * We implemented a parking space counter application using Python and OpenCV. This project enables users to define parking spaces on an image, count full and empty parking spots, and visualize the counts in real-time. The application leverages computer vision techniques to identify parking space boundaries and utilizes event handling to interactively mark full and empty spaces. This project serves as a practical example of applying Python and OpenCV for image processing and computer vision tasks, demonstrating their utility in real-world applications such as parking management systems. 🅿️🚗🅿️
* Day 30: [TensorFlow](https://www.tensorflow.org/tutorials/keras/classification) Guide (Beginner ~ ML Basics with Keras)
  * Explore the fundamentals of machine learning with TensorFlow and Keras in this beginner's guide. This guide provides a comprehensive overview of TensorFlow, a powerful open-source machine learning framework developed by Google. Through practical examples and step-by-step tutorials, you'll learn how to build and train neural networks using Keras, a high-level neural networks API that runs on top of TensorFlow. From basic concepts to hands-on implementation, this guide is designed to introduce you to the essentials of machine learning and empower you to start building your own ML models with TensorFlow and Keras. 🤖📚🔍
* Day 31: Spam Emails Dataset [Kaggle](https://www.kaggle.com/datasets/venky73/spam-mails-dataset/code)
  * We explored a Spam Emails Dataset available on Kaggle. This dataset contains a collection of emails labeled as spam or ham (not spam). Leveraging this dataset, we embarked on a data analysis and preprocessing journey using Python and pandas. Through this process, we gained insights into the structure of the data and performed necessary preprocessing steps to prepare it for machine learning tasks. By delving into real-world data and preparing it for analysis, we honed our data manipulation and preprocessing skills, essential for any data science or machine learning project. 📧🔍🛠️
* Day 32: Dijkstra's Algorithm Implementation
  * We implemented the Dijkstra algorithm, which is a design algorithm used to find the shortest path between nodes in a graph. The implementation is made in Python and uses a linear array to precisely search the graph and calculate the shortest distance from the starting point to all other points. Dijkstra's algorithm is widely used in a variety of applications, including network protocol routing  and  video game routing. By applying this algorithm, we increased 's design understanding  and strengthened our algorithmic problem-solving skills. 📈🔍💡
* Day 33: Technical Test "Add Two Numbers" and "FizzBuzz" [LeetCode](https://leetcode.com/problems/)
  * Add Two Numbers: We tackled the "Add Two Numbers" problem from LeetCode, which involves adding two non-empty linked lists representing non-negative integers. The digits are stored in reverse order, and each node contains a single digit. We implemented a Python solution that traverses both linked lists simultaneously, summing the corresponding digits and handling any carry. This problem enhances our understanding of linked list manipulation and problem-solving skills.
  [Problem Description](https://leetcode.com/problems/add-two-numbers/description/?source=submission-ac)
  
  * FizzBuzz: The second problem we solved was "FizzBuzz," also from LeetCode. This classic programming problem requires generating the FizzBuzz sequence up to a given number. We crafted a Python solution that iterates through the numbers from 1 to the given number, appending "Fizz" for multiples of 3, "Buzz" for multiples of 5, "FizzBuzz" for multiples of both 3 and 5, and the number itself if none of the conditions are met. This exercise reinforces our ability to write concise and efficient code to solve common programming challenges.
  [Problem Description](https://leetcode.com/problems/fizz-buzz/description/)
* Day 34: Quicksort
  * We implemented Quicksort, a divide-and-conquer algorithm used for sorting arrays or lists. Quicksort selects a pivot element, partitions the other elements into two sub-arrays based on whether they are less than or greater than the pivot, and recursively sorts the sub-arrays. Known for its efficiency, Quicksort is often used as a benchmark for comparison with other sorting algorithms, enhancing our understanding of algorithmic efficiency and problem-solving skills. 🔄📊🔍
* Day 35: Live Weather Forecast Flask App
  * In today's project, we'll develop a live weather forecast Flask app. This app will take a city name as input and provide various weather characteristics such as temperature in Celsius and Fahrenheit, humidity, wind speed, and more.
* Day 36: Random Passwords Generator
  * Today, we created a Random Passwords Generator program. This program prompts the user to specify the desired length of the password and generates a strong password consisting of a mix of lowercase and uppercase letters, digits, and special characters. Additionally, we implemented a function to save the generated passwords to a CSV file for later use. This project enhances our understanding of string manipulation, random number generation, and file handling in Python, while also providing practical utility by creating a tool for generating secure passwords. 🔒💡💻
* Day 37: Site Connectivity Checker
  * Today, we developed a Site Connectivity Checker application using Flask. This application allows users to input a URL and checks its connectivity by sending a request to the specified website. We enhanced the functionality by adding URL validation, error handling for various connection issues, and logging of activity to track the status of site connections over time. By building this project, we gained practical experience in web development with Flask, handling HTTP requests, error management, and logging, all of which are essential skills for creating robust web applications. 🌐🔍🚀
* Day 38: Heart Attack Analysis & Prediction Dataset [Kaggle](https://www.kaggle.com/datasets/rashikrahmanpritom/heart-attack-analysis-prediction-dataset/data)
  * We explored the Heart Attack Analysis & Prediction Dataset available on Kaggle. This dataset provides valuable insights into factors contributing to heart attacks and includes various health parameters such as age, sex, cholesterol levels, blood pressure, and more. By analyzing this dataset, we aim to gain a deeper understanding of the relationships between different risk factors and the likelihood of a heart attack occurrence. Leveraging statistical analysis and machine learning techniques, we strive to develop predictive models that can assist in early detection and prevention efforts for cardiovascular diseases. This project underscores the importance of data-driven approaches in healthcare and reinforces our skills in data analysis, predictive modeling, and domain knowledge application. ❤️📊🔬
* Day 39: [TensorFlow](https://www.tensorflow.org/tutorials/keras/classification) Guide Basic text Classification (Beginner ~ ML Basics with Keras)
  * Continuing from Day 30, delve deeper into machine learning with TensorFlow and Keras by exploring basic text classification. In this guide, you'll learn how to apply machine learning concepts to classify text data using TensorFlow and Keras. By following step-by-step tutorials and practical examples, you'll understand the fundamentals of text classification, including preprocessing text data, building neural network models, and evaluating model performance. Whether you're new to machine learning or looking to expand your knowledge, this guide provides valuable insights and hands-on experience to enhance your skills in natural language processing and text classification tasks. 🤖📚🔍
* Day 40: Technical Test "Minimum Height Trees" and "Zigzag Conversion" [LeetCode](https://leetcode.com/problems/)
  * Minimum Height Trees: Today, we encountered the "Minimum Height Trees" problem on LeetCode. This problem revolves around identifying the roots of minimum height trees in an undirected graph, given the number of nodes and an array of edges representing connections between nodes. We crafted a Python solution employing graph traversal and manipulation techniques to determine the roots with minimum height efficiently. This challenge enhances our ability to work with graphs, analyze graph structures, and devise optimal algorithms for graph-related problems. [Problem Description](https://leetcode.com/problems/minimum-height-trees/description/)
  * Zigzag Conversion: In addition, we tackled the "Zigzag Conversion" problem on LeetCode. This problem involves converting a given string into a zigzag pattern with a specified number of rows and then reading the string line by line. We devised a Python solution that constructs the zigzag pattern by iteratively placing characters in the appropriate rows, simulating the pattern formation and reading process. Solving this problem reinforces our understanding of string manipulation techniques and enhances our problem-solving skills in handling complex pattern-based challenges. [Problem Description](https://leetcode.com/problems/zigzag-conversion/description/)
* Day 41: Tkinter - Map View
  * Explore Tkinter's capabilities in displaying interactive maps with the Tkinter MapView project. This Tkinter-based application allows users to visualize maps, search for addresses, and adjust zoom levels seamlessly within a GUI interface. By integrating functionalities such as address lookup, zoom control, and map display, this project showcases the potential of Tkinter for creating dynamic and user-friendly applications. Dive into the world of Tkinter and enhance your skills in GUI development with the MapView project. 🗺️🖥️🔍
* Day 42: Tkinter - Digital Clock
  * Explore the world of GUI development with Tkinter by creating a digital clock application. In this project, I utilized Tkinter's functionalities to design an attractive and functional digital clock interface. By leveraging Python's time module and Tkinter's Label widget, I implemented a dynamic clock display that updates in real-time. Join me as I continue to delve into Tkinter and expand my skills in creating intuitive and visually appealing graphical user interfaces. ⏰🖥️🔧
* Day 43: PySpark (Quickstart: DataFrame)[https://spark.apache.org/docs/3.3.1/api/python/getting_started/quickstart_df.html]
  * Dive into the world of big data processing with PySpark as we explore the Quickstart guide for DataFrames. PySpark is a powerful tool for processing large-scale datasets using the Apache Spark framework. In this project, we'll delve into the basics of working with DataFrames, a distributed collection of data organized into named columns. By following the Quickstart guide, we'll learn how to create, manipulate, and analyze DataFrames efficiently. Join me on this journey as we harness the power of PySpark to tackle big data challenges with ease and scalability. 🚀💻🔍
* Day 44: Daily Routine with Desktop Notifications
  * In this project, I crafted a personalized daily routine assistant utilizing desktop notifications. Leveraging Python libraries such as `win10toast` and `schedule`, I created a system that sends timely notifications for various activities throughout the day. Whether it's studying English, working on Python projects, taking short breaks, or even enjoying a joke break, this routine keeps me organized and on track. By scheduling notifications at specific times using the schedule module, I ensure I stay productive and maintain a healthy balance between work and relaxation. Join me as I automate my daily routine and optimize my productivity with desktop notifications! 📅⏰🖥️
* Day 45: Language Detection
  * Enhancing my text processing capabilities, I delved into language detection. Leveraging the langdetect and langcodes libraries in Python, I developed a program capable of identifying the language of input text. By utilizing the powerful language detection algorithms provided by these libraries, I crafted a user-friendly interface using Tkinter. This project allows users to input text and receive instant feedback on the detected language, aiding in various applications such as multilingual text analysis, translation services, and content filtering. Join me as I explore the fascinating world of language detection and broaden the scope of text processing possibilities! 🌐🔍📝
* Day 46: Technical Test "MedianSortedArrays" and "lengthOfLongestSubstring" [LeetCode](https://leetcode.com/problems/)
  * MedianSortedArrays: Today, we encountered the "Median of Two Sorted Arrays" problem on LeetCode. This problem involves finding the median of two sorted arrays, which are of different sizes, m and n. The challenge is to achieve a time complexity of O(log(m+n)). We tackled this problem by employing the binary search approach. By partitioning the arrays and comparing elements at partition points, we efficiently determine the median. Solving this problem enhances our understanding of algorithmic complexity and binary search techniques, crucial for tackling similar problems efficiently. [Problem Description](https://leetcode.com/problems/median-of-two-sorted-arrays/)

  * lengthOfLongestSubstring: In addition, we tackled the "Longest Substring Without Repeating Characters" problem on LeetCode. This problem requires finding the length of the longest substring within a given string that does not contain any repeating characters. We approached this problem using a sliding window technique, which allows us to efficiently traverse the string while keeping track of the characters encountered. By updating the window's boundaries based on repeating characters, we determine the longest substring without repetition. Solving this problem enhances our understanding of string manipulation and sliding window algorithms, essential for solving various string-related challenges. [Problem Description](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)
* Day 47: Currency Converter
  * Today, I embarked on a journey to create a currency converter application using Python. Leveraging the tkinter library for graphical user interface (GUI) development and the forex_python library for currency conversion functionality, I crafted a simple yet effective tool for converting between different currencies. This project involved setting up dropdown menus for selecting the source and target currencies, implementing an entry widget for inputting the amount to convert, and integrating a button to trigger the conversion process. By handling exceptions and displaying conversion results dynamically, I ensured a smooth user experience. Join me as I explore the world of currency conversion and develop a handy tool for everyday use! 💱💼🔀
* Day 48: Perceptron
  * In today's project, I delved into the world of artificial neural networks by implementing a perceptron from scratch. The perceptron, a fundamental building block of neural networks, is a simple algorithm capable of learning binary classifiers. Leveraging the NumPy library for numerical operations, I crafted a perceptron class capable of training on labeled datasets and making predictions. By defining the perceptron's architecture, including input features, weights, and activation functions, I gained insight into the inner workings of neural networks. Through iterative training and weight updates based on prediction errors, the perceptron learns to separate linearly separable classes in feature space. This project serves as a foundational step towards understanding more complex neural network architectures and their applications in machine learning and artificial intelligence. Join me as I explore the basic principles of neural networks and implement a perceptron algorithm from scratch! 🧠💻🤖
* Day 49: Technical Test "Reverse Integer" and "Longest Palindromic Substring" [LeetCode](https://leetcode.com/problems/)
  * Today's technical challenge involves the "Reverse Integer" problem on LeetCode. This problem requires reversing the digits of a signed 32-bit integer. If the reversed integer overflows, the function should return 0. We'll tackle this problem by implementing a solution that handles both positive and negative integers, considering overflow conditions carefully. Solving this problem enhances our skills in handling numerical operations and edge cases effectively. [Problem Description](https://leetcode.com/problems/reverse-integer/description/)
  * "Longest Palindromic Substring": Additionally, we'll tackle the "Longest Palindromic Substring" problem on LeetCode. This problem involves finding the longest palindromic substring within a given string. We'll devise an algorithm to efficiently determine the longest palindrome, leveraging techniques such as dynamic programming or expanding around centers. By addressing this challenge, we deepen our understanding of string manipulation and algorithmic problem-solving strategies. [Problem Description](https://leetcode.com/problems/longest-palindromic-substring/description/)
* Day 50: Students Performance in Exams [Kaggle](https://www.kaggle.com/datasets/whenamancodes/students-performance-in-exams/data)
  * Today, we delve into the realm of educational data analysis by exploring a student performance dataset from Kaggle. This dataset offers valuable insights into factors that may influence student achievement in exams. By delving into this data, we can uncover patterns, trends, and relationships that can inform educational practices and improve student learning outcomes.
* Day 51: Interactive Menu for YouTube and Web Searches
  * Today's focus is on creating a music player application. Building a music player involves integrating functionalities to play, pause, skip, and control the playback of audio files. Additionally, we'll explore features such as creating playlists, displaying metadata, and providing a user-friendly interface for an immersive music listening experience. By developing a music player, we deepen our understanding of GUI frameworks, multimedia handling, and software design principles.
* Day 52: Task Manager Performance
  * Today's task revolves around analyzing the performance of a task manager application. Task managers play a crucial role in monitoring system resources, managing processes, and optimizing performance. Through this analysis, we aim to evaluate the efficiency, responsiveness, and resource utilization of the task manager under various conditions. By examining performance metrics such as CPU usage, memory consumption, and task responsiveness, we can identify areas for improvement and enhance the overall functionality of the task manager application.
* Day 53: Technical Test "Integer to Roman" and "Container With Most Water" [LeetCode](https://leetcode.com/problems/)
  * Integer to Roman:
    Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M. Implement a function to convert an integer into its corresponding Roman numeral representation.
    Given an integer, convert it to a Roman numeral. [Problem Description](https://leetcode.com/problems/integer-to-roman/)
  * Container With Most Water: You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store. [Problem Description](https://leetcode.com/problems/container-with-most-water/description/)
* Day 54: Background Remove Flask
  * Today's focus is on implementing a background removal functionality within a Flask web application. Background removal is a crucial task in image processing and computer vision, allowing users to isolate subjects from their backgrounds. By integrating this functionality into a web application using Flask, we aim to provide users with a convenient and accessible tool for background removal tasks. Throughout this process, we'll explore techniques for image manipulation, integration of third-party libraries, and web development with Flask. By building a background removal tool, we enhance our understanding of image processing algorithms, web application development, and practical applications of computer vision technology.
* Day 55: Multiple Files Renamer
  * Today's focus is on developing a multiple files renamer application. Renaming multiple files in bulk is a common task, especially when organizing files or preparing them for specific purposes. This application will provide users with the ability to select a folder containing files, specify renaming criteria, and execute the renaming process efficiently. By creating this utility, we aim to streamline file management tasks and enhance productivity for users dealing with large numbers of files. Throughout the development process, we'll explore file handling techniques, user interface design, and implementation of renaming algorithms to ensure a robust and user-friendly application.
* Day 56: Technical Test "threeSum" and "threeSumClosest" [LeetCode](https://leetcode.com/problems/)
  Today's focus is on solving technical problems related to array manipulation and algorithmic thinking. We'll tackle two problems from LeetCode:
  * threeSum: Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j, i != k`, and `j != k, and nums[i] + nums[j] + nums[k] == 0`. The solution set must not contain duplicate triplets. [Problem Description](https://leetcode.com/problems/3sum/description/)
  * threeSumClosest: Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. [Problem Description](https://leetcode.com/problems/3sum-closest/description/)
* Day 57: KeyLogger 
  * Today's focus is on developing a KeyLogger application. A KeyLogger is a program that records the keystrokes made by a user on their computer. It's commonly used for various purposes such as monitoring employee activity, parental control, or debugging software. Our KeyLogger application will capture keystrokes and store them in a log file, providing users with the ability to monitor keyboard activity. Through this project, we'll delve into event handling, file I/O operations, and potentially explore additional features such as email notifications for logged keystrokes, enhancing the utility and versatility of the KeyLogger.
* Day 58: Matrix Effect
  * Today's focus is on creating a Matrix Effect, inspired by the iconic "Matrix" movie. This project involves generating a cascading effect of characters resembling the falling code seen in the film. Through this project, we'll explore concepts such as terminal manipulation, randomization, and animation. By implementing this Matrix Effect, we aim to recreate the visually stunning display seen in the movie, offering a fun and engaging coding exercise.
* Day 59: Dice-Rolling [realpython.com](https://realpython.com/python-dice-roll/#step-1-code-the-tui-of-your-python-dice-rolling-app)
  * Today's focus is on implementing a Dice-Rolling application. This project involves creating a Python program to simulate rolling dice. We'll explore concepts such as random number generation, user input validation, and ASCII art for visual representation of dice faces. Additionally, we'll delve into creating a text-based user interface (TUI) for the application. By developing this Dice-Rolling application, we aim to provide users with a fun and interactive way to simulate rolling dice, suitable for various gaming and recreational purposes.
* Day 60: Technical Test "letterCombinations" and "4Sum" [LeetCode](https://leetcode.com/problems/)
  * **Letter Combinations of a Phone Number**: Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. [Problem Description](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)
  * **4Sum**: Given an array `nums` of n integers, return an array of all the unique quadruplets `[nums[a], nums[b], nums[c], nums[d]]` such that:
     - `0 <= a, b, c, d < n`
     - `a, b, c, and d` are distinct.
     - `nums[a] + nums[b] + nums[c] + nums[d] == target`
  You may return the answer in any order. [Problem Description](https://leetcode.com/problems/4sum/)
* Day 61: Anemia Types Classification [Kaggle](https://www.kaggle.com/datasets/ehababoelnaga/anemia-types-classification/data)
  * Today, we focus on anemia types classification using a dataset from Kaggle. This dataset contains CBC (Complete Blood Count) data labeled with the diagnosis of anemia type, collected from several CBCs and diagnosed manually. By analyzing this dataset, we aim to understand the relationships between CBC parameters and different types of anemia. This analysis can provide valuable insights for medical diagnosis and treatment strategies.
* Day 62: Cinema Management System using OOP
  * Today, we delve into a cinema project focusing on Object-Oriented Programming (OOP). The project involves designing classes to simulate various aspects of a cinema system, including movies, rooms, reservations, and the cinema itself. Through this project, we aim to implement key OOP principles such as encapsulation, inheritance, and polymorphism. By structuring the code in an object-oriented manner, we can create a modular and scalable system that effectively models the functionalities of a real-world cinema. This project provides an excellent opportunity to practice OOP concepts while developing a practical application.
* Day 63: Technical Test "removeNthFromEnd" and "isMatch" [LeetCode](https://leetcode.com/problems/).
  * Today's technical test on LeetCode involves two problems:
  * removeNthFromEnd: Given the head of a linked list, remove the nth node from the end of the list and return its head. This problem challenges your ability to manipulate linked lists efficiently. [Problem Description](https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/)
  * isMatch: Implement regular expression matching with support for '.' and '*', where '.' matches any single character and '*' matches zero or more of the preceding element. The matching should cover the entire input string (not partial). [Problem Description](https://leetcode.com/problems/regular-expression-matching/description/).
  
  These problems test your proficiency in data structures and algorithms, particularly in linked list manipulation and dynamic programming. Working on them will enhance your problem-solving skills and algorithmic thinking.
* Day 64: Contour Plots in Matplotlib - Visualize 3D Functions in 2D [NeuralNine](https://www.youtube.com/watch?v=DYn9HdTmt0E)
  * In today's session, we explore how to create contour plots in Matplotlib, a powerful visualization tool in Python. Contour plots allow us to represent 3D functions in 2D, providing a clear view of the function's behavior over a plane. We will generate 2D grids using `numpy.meshgrid` and define various 3D functions to visualize. The session includes creating both surface plots and filled contour plots using Matplotlib's `plot_surface` and `contourf` functions, respectively. This exercise will help you understand how to effectively visualize complex functions, enhancing your data presentation skills and making your plots more informative and visually appealing.
* Day 65: Technical Test "isValidParentheses" and "MergeTwoSortedLists" [LeetCode](https://leetcode.com/problems/).
  * isValidParentheses: Given a string `s` containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if:
      * Open brackets must be closed by the same type of brackets.
      * Open brackets must be closed in the correct order.
      * Every close bracket has a corresponding open bracket of the same type. 
      [Problem Description](https://leetcode.com/problems/valid-parentheses/description/)
  * MergeTwoSortedLists: Given the heads of two sorted linked lists `list1` and `list2`, merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. [Problem Description](https://leetcode.com/problems/merge-two-sorted-lists/description/)
* Day 66: Web Scraping Job Listings with Python
  * In today's session, we delve into the world of web scraping using Python. Our goal is to extract job listings from the Python.org jobs page and save the data into a CSV file. We will use the `requests` library to fetch the HTML content of the webpage and `BeautifulSoup` for parsing the HTML and extracting the job details. The details we will extract include the job title, company name, location, posting date, and job type. After extracting the data, we will write it into a CSV file using Python's `csv` module. This exercise will enhance your skills in web scraping, data extraction, and handling CSV files, providing a practical approach to gather and organize data from web sources.
* Day 67: [TensorFlow](https://www.tensorflow.org/tutorials/keras/regression) Regression (Beginner ~ ML Basics with Keras)
  * Today, we embark on a journey into the basics of regression analysis using TensorFlow and Keras. This tutorial covers the essential steps to build, train, and evaluate regression models. We will start by loading and cleaning the Auto MPG dataset, which includes features like 'Horsepower', 'Weight', and 'Acceleration'. After preprocessing the data, we'll split it into training and testing sets, and normalize it to improve model performance. You'll learn how to construct simple linear regression models, first with a single input and then with multiple inputs. Furthermore, we'll explore more complex models using deep neural networks (DNNs). This hands-on guide will help you understand the fundamentals of regression analysis, model training, evaluation, and making predictions, providing a strong foundation in machine learning with TensorFlow and Keras. 🚗📈🤖
* Day 68: Recursion "SierpinskiTriangle" and "FractalTree".
  * On day 68, we explore the concept of recursion through the creation of two classic fractals: the Sierpinski Triangle and the Fractal Tree. Both examples utilize Python's turtle graphics library to visualize the recursive processes.
    * Sierpinski Triangle: This fractal is formed by recursively subdividing an equilateral triangle into smaller triangles. Each subdivision step reduces the size of the triangles and changes their color based on the recursion depth. This exercise helps in understanding how recursion can break down complex problems into simpler, repeatable tasks.
    * Fractal Tree: This fractal simulates the natural growth patterns of a tree. Starting with a trunk, the tree branches into smaller sub-branches, each at a specific angle and length decrement. By adjusting the recursion depth, angle, and length decrement, different tree shapes and complexities can be generated. This project emphasizes the power of recursion in modeling natural phenomena and visualizing algorithmic patterns.
* Day 69: Ticket management GUI
  * On day 69, we delve into building a web-based Ticket Management System using Flask. This project includes two primary interfaces: one for clients to generate tickets for order claims, and another for providers to manage and track the tickets. The client-side allows users to enter their name, generate a ticket with a unique number, and record the time of generation. The provider-side interface displays the next ticket in the queue along with the current ticket being attended to and which counter is handling it. This system demonstrates the basics of web development with Flask, including form handling, data storage, and dynamic content rendering. By completing this project, you will gain practical experience in creating web applications, managing state, and ensuring smooth interactions between different user roles. 🧾🖥️✨
* Day 70: Scientific GUI Calculator
  * On day 70, we constructed a Graphical User Interface (GUI) for a scientific calculator using the tkinter library in Python. This calculator provides a wide range of mathematical functions, including basic arithmetic operations, trigonometric functions, logarithmic functions, and more. Users can input numerical values, perform calculations, and view results conveniently through the intuitive interface. The calculator's design incorporates various buttons for different mathematical operations, making it easy to use and navigate. By creating this project, you will enhance your skills in GUI development, event handling, and integrating complex mathematical operations into user-friendly applications. 🧮💻🔍
* Day 71: Technical Test "generateParenthesis" and "mergeKLists" [LeetCode](https://leetcode.com/problems/).
  * generateParenthesis: Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
  [Problem Description](https://leetcode.com/problems/generate-parentheses/description/)
  * mergeKLists: You are given an array of `k` linked-lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.[Problem Description](https://leetcode.com/problems/merge-k-sorted-lists/description/)
* Day 72: Knight's Tour Problem Solver
  * On day 72, we explore the classic Knight's Tour problem using Python. This project involves developing an algorithm to find a sequence of moves that allows a knight to visit every square on an N x N chessboard exactly once. The solution employs backtracking to systematically search for a valid tour, ensuring that all board positions are covered without repetition. The implementation includes functions to validate moves, print the board, and recursively attempt to solve the tour from a given starting position. By tackling this problem, you will gain a deeper understanding of recursion, backtracking, and algorithmic problem-solving. This project is an excellent exercise in enhancing your skills in algorithm development and Python programming. ♞📐💡
* Day 73: Tic-Tac-Toe Multiplayer [NeuralNine](https://youtu.be/s6HOPw_5XuY?si=ZlnrpRTxmJiYtGv8)
  * On day 73, we developed a multiplayer Tic-Tac-Toe game using Python. This project allows two players to connect over a network and play Tic-Tac-Toe in real-time. One player hosts the game, while the other player connects to it. The implementation includes setting up a server-client architecture using the socket library and managing game state and turns through a combination of functions for move validation, board updates, and win condition checks. The game uses threading to handle simultaneous communication between players. By completing this project, you will enhance your understanding of network programming, client-server communication, and basic game development in Python. 🎮🕹️💻
* Day 74: Technical Test "twoSum" and "myAtoi" [LeetCode](https://leetcode.com/problems/).
  * twoSum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.
  [Problem Description](https://leetcode.com/problems/two-sum/description/)
  * myAtoi: Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer. The function follows a specific algorithm to ignore leading whitespace, determine the sign, read digits, and handle integer overflow by clamping the result within the 32-bit signed integer range.
  [Problem Description](https://leetcode.com/problems/string-to-integer-atoi/description/)
* Day 75: Spotify Songs Album [Kaggle](https://www.kaggle.com/datasets/zeesolver/spotfy/data)
  * Today, we embark on a journey into the realm of music data analysis with a dataset sourced from Kaggle, focusing on Spotify songs albums. This dataset provides a comprehensive collection of information about various songs, including attributes such as danceability, energy, and acousticness. By delving into this dataset, we aim to uncover intriguing insights into the characteristics of popular songs, trends in music streaming, and the impact of different attributes on song popularity. Through exploratory data analysis and visualization techniques, we will unravel patterns, correlations, and unique features within the dataset, shedding light on the dynamic landscape of the music industry. Join us as we dissect this rich dataset to discover the rhythms and melodies that shape our musical experiences.
* Day 76: Bank Queue Management System
  * Today, we delve into the development of a robust bank queue management system designed for "Su ahorrito". This system aims to streamline the process of managing customer service operations, focusing on assigning and managing customer turns efficiently. Our system encompasses several key functionalities:
    - User Management: Create and manage user profiles, including user ID, name, and client type (General, Preferential1, Preferential2).
    - Turn Assignment: Automatically assign turns to users, categorizing each turn with a specific transaction type (Deposit, Withdrawal, Bill Payment).
    - Customer Service: Facilitate the process of attending to customers, ensuring that completed transactions are recorded and stored systematically.
    - Transaction Analysis: Calculate and display the percentage distribution of different transaction types, providing insights into customer needs and service trends.
    - Turn Management: Enable the removal of specific turns and display the number of turns assigned to each user.
    - Transaction History: Maintain and showcase a history of all completed transactions, ensuring transparency and record-keeping.
Through this project, we aim to enhance the efficiency of customer service in a banking environment by leveraging Python to build an intuitive and effective queue management system. Join us as we implement and explore this essential application, ensuring a smoother experience for both bank staff and customers.
* Day 77: Inventory Management GUI
Today, we embarked on the development of a Graphical User Interface (GUI) for an Inventory Management System. Leveraging the Flask web framework in Python, we crafted an intuitive interface that enables users to efficiently manage their inventory of products. The system offers a range of features to enhance inventory control and streamline operations, including:
  - **Product Management:** Users can easily add, edit, and delete products from the inventory, facilitating seamless product catalog management.
  - **Real-time Inventory Monitoring:** The application provides a comprehensive view of the current inventory status, allowing users to track product quantities and make informed decisions.
  - **Report Generation:** With built-in reporting capabilities, users can generate detailed reports on inventory status, product performance, and more, empowering data-driven decision-making.
  - **Low Stock Alerts:** The system automatically alerts users to products with low stock levels, helping prevent stockouts and optimize inventory replenishment.
  - **Data Export:** Users can export inventory data to CSV or Excel formats for further analysis or integration with external systems.

  By developing this Inventory Management GUI, we aimed to provide businesses with a powerful tool to effectively manage their inventory, improve efficiency, and optimize resource utilization. Join us as we continue to explore the intersection of technology and business operations, empowering organizations to thrive in today's dynamic marketplace. 📦💻📊
* Day 78: Technical Test "swapPairs" and "reverseKGroup" [LeetCode](https://leetcode.com/problems/).
  * swapPairs: Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed) [Problem Description](https://leetcode.com/problems/swap-nodes-in-pairs/description/)
  * reverseKGroup: Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k, then the left-out nodes at the end should remain as they are. You may not alter the values in the list's nodes, only nodes themselves may be changed. [Problem Description](https://leetcode.com/problems/reverse-nodes-in-k-group/description/)
* Day 79: Minesweeper GUI Pygame
  * Today, we're diving into the development of a Minesweeper game with a Graphical User Interface (GUI) using Pygame. This classic game challenges players to uncover hidden mines on a grid-based board without detonating any of them. Our implementation leverages Pygame's intuitive interface to provide an engaging and immersive gaming experience. Players can reveal tiles, flag potential mines, and navigate through various difficulty levels or customize their game settings. Join us as we explore the world of game development with Python and Pygame, bringing the timeless excitement of Minesweeper to life in a modern and visually appealing format. 🕹️💣🎮
* Day 80: Student Practice Management System
  * Today, we developed a Python-based system to manage student internships. This system features:
    - **Practice Registration**: Capture student details, company name, and practice duration.
    - **Internship Tracking**: Monitor ongoing practices with detailed views.
    - **Average Duration Calculation**: Display the average length of internships.
    - **Company-Specific Intern Count**: Determine the number of interns per company.
    - **Company Update for Practices**: Modify the company associated with a student's practice.
    - **User-Friendly Menu Interface**: Easily navigate and interact with the system.

  This system aims to streamline the management of student internships, benefiting both students and administrators. 🎓🏢📊
* Day 81: Random Roulette
  * Today, we're building a Random Roulette web application using Flask. This app allows users to add and modify options for the roulette, and then spin to select a random option. With Flask's lightweight and flexible framework, we'll create an interactive and dynamic web interface where users can easily manage their options. The application features a simple design with an intuitive navigation system, ensuring a seamless user experience. Join us as we delve into web development with Flask, creating a fun and functional tool for making random selections. 🎡🔄✨
* Day 82: Test Projects "celsius_to_fahrenheit"
  * Today, we're focusing on writing unit tests for a simple function that converts temperatures from Celsius to Fahrenheit. Testing is a crucial part of software development, ensuring that our code works as expected and helps prevent bugs from creeping into our projects. We'll use Python's unittest module to create and run our tests. This exercise will help you understand the basics of writing tests and how to use them to verify the correctness of your code.
* Day 83: Technical Test "removeDuplicates" and "removeElement" [LeetCode](https://leetcode.com/problems/).
  * removeDuplicates: Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums. [Problem Description](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)
  * removeElement: Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val. [Problem Description](https://leetcode.com/problems/remove-element/description/)
* Day 84: Complaint Management System
  * Today, we developed a Python-based system to manage complaints for the General Prosecutor's Office. This system features:
    - **Complaint Creation**: Record details such as complainant, accused, date, type, and unique code.
    - **Complaint Deletion**: Remove complaints using a unique code.
    - **Sublist Creation**: Generate a sublist of complaints involving a specific person.
    - **Type-Based Percentage Calculation**: Calculate the percentage of each type of complaint.
    - **Complaint Display**: Show all registered complaints.
    - **Date Modification**: Update the date of a specific complaint.
    - **User-Friendly Menu Interface**: Easily navigate and interact with the system.

  This system is designed to streamline the management of complaints, making it easier for the General Prosecutor's Office to handle and organize them effectively. 📅📝🔍
* Day 85: Convert Word Files To PDF [NeuralNine](https://www.youtube.com/watch?v=i57uYpW5Ng8)
  * Today, we worked on a project to convert Word files (.docx) to PDF format. This project was inspired by a video tutorial from NeuralNine. While the tutorial provided the basic functionality for converting a single DOCX file to PDF, we expanded the project by adding several new features:
    - **Graphical User Interface (GUI)**: Using `tkinter`, we created an intuitive interface that allows users to easily select files and specify output options.
    - **Single File Conversion**: Users can convert a single DOCX file to PDF by selecting the file and choosing a destination.
    - **Multiple File Conversion**: Users can select multiple DOCX files and convert them all to PDF at once, saving the converted files in a specified directory.
    - **Error Handling**: The application includes robust error handling to inform users of any issues during the conversion process.
    - **User Notifications**: After a successful conversion, the application provides a notification to the user.
    
  These enhancements make the tool more user-friendly and versatile, offering a complete solution for converting Word documents to PDF efficiently.

* Day 86: Goldner-Harary Graph in 3D
  * Today, we explored the fascinating world of graph theory by creating and visualizing the Goldner-Harary graph in 3D. This project helped us understand the properties of planar graphs and verify Euler's formula. Here are the key features and steps we implemented:
    - **Graph Construction**: We created the Goldner-Harary graph, which consists of 11 vertices and 27 edges.
    - **3D Visualization**: Using `matplotlib` and `networkx`, we plotted the graph in a 3D space, providing a comprehensive visual representation of its structure.
    - **Planarity Check**: We verified the graph's planarity, confirming that it can be drawn on a plane without any edges crossing.
    - **Euler's Formula Verification**: We checked Euler's formula (v - e + f = 2) for the graph, ensuring it holds true for planar graphs.
    - **Graph Information**: We displayed essential information about the graph, including the number of vertices, edges, and faces.
    
  This project not only enhanced our understanding of graph theory but also provided practical experience with 3D data visualization techniques. The Goldner-Harary graph, with its complex structure, served as an excellent example for studying planar graphs and their properties. 🌐📊🔍
* Day 87: Building Management System
  * Today, we developed a Python-based Building Management System. This system offers functionalities such as generating invoices, making payments, and tracking property ownership. Key features include:
    - **Invoice Generation**: Automatically generate monthly invoices for property owners.
    - **Payment Processing**: Record and manage payments made by proprietors.
    - **Account Statements**: Generate account statements for proprietors, detailing payments and dues.
    - **Delinquency Monitoring**: Identify delinquent apartments based on overdue balances.
    
  This system streamlines property management tasks, enhancing efficiency and organization. 🏢💼💰
* Day 88: Technical Test "strStr" and "divide" [LeetCode](https://leetcode.com/problems/).
  * strStr: Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. This classic problem tests your ability to efficiently search substrings within a larger string. [Problem Description](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)
  * divide: Given two integers, dividend and divisor, divide them without using multiplication, division, and mod operator. Ensure the result is truncated toward zero. This problem challenges you to implement efficient division using basic arithmetic operations. [Problem Description](https://leetcode.com/problems/divide-two-integers/description/)
* Day 89: Dragon Ball Radar Animation with DBSCAN Clustering
  * Today, we crafted an animated Dragon Ball radar using Python, leveraging DBSCAN clustering to detect clusters of Dragon Balls. Here's a breakdown of what we accomplished:
    - **Radar Animation**: We animated a radar line sweeping through 360 degrees, simulating the iconic Dragon Ball radar from the anime series.
    - **DBSCAN Clustering**: Utilizing the DBSCAN algorithm, we clustered randomly generated Dragon Ball positions, mimicking their distribution across the radar's range.
    - **Cluster Visualization**: Each cluster of Dragon Balls was represented by a yellow point on the radar, with the number of Dragon Balls in each cluster displayed alongside.
    - **Interactive Animation**: The animation included blinking points and text to add dynamism and visual appeal to the radar display.

  This project blends entertainment with data science, offering a playful yet educational exploration of clustering algorithms and animated visualizations. 🐉🔍✨
* Day 90: Pong Game Development in Python
  * Today, we developed a classic Pong game using Python and the Pygame library. Here's a summary of our progress:
    - **Game Mechanics**: We implemented the basic mechanics of Pong, including ball movement, paddle control, and collision detection.
    - **Scoring System**: A scoring system was added, with the game ending when a player reaches 5 points. The score is displayed on the screen, and a winning message is shown at the end.
    - **Paddle Customization**: The paddles were given distinct colors (red for the left paddle and blue for the right paddle) to enhance the visual appeal.
    - **Smooth Animation**: The game runs smoothly at 60 frames per second, providing a responsive and enjoyable gaming experience.

  This project demonstrates the fundamentals of game development in Python, showcasing the power and flexibility of Pygame for creating interactive applications. 🎮🚀✨
* Day 91: Flask-based Online Survey Application
  Today, we created a Flask-based Online Survey Application. This project allows users to create surveys and participate in them. Key functionalities include:

    - **Survey Creation**: Users can create new surveys with customizable options.
    - **Survey Participation**: Other users can vote in existing surveys.
    - **Results Display**: The application displays results for each survey, showing the distribution of votes.
    
  This project aims to provide a straightforward platform for conducting surveys online, enhancing user engagement and feedback collection. 📊🖥️✅
* Day 92: Tower of Hanoi and N Queens Problem Solutions
  * Today, we implemented solutions to the classic Tower of Hanoi and N Queens problems in Python. Here's a summary of our progress:
    - **Tower of Hanoi**: We developed a recursive function to solve the Tower of Hanoi problem, which involves moving disks from one peg to another according to specific rules. The function efficiently moves disks from the source peg to the target peg using an auxiliary peg.
    - **N Queens Problem**: We implemented a backtracking algorithm to solve the N Queens problem, which involves placing N queens on an NxN chessboard such that no queen attacks another. The algorithm ensures that each queen is placed safely by checking for conflicts with other queens in the same row, column, or diagonal.

  These projects demonstrate the power of Python for solving complex problems and the importance of recursion and backtracking in solving these types of problems. 🎯👑

* Day 93: Word Search Puzzle GUI
  * Today, we created a graphical user interface (GUI) for a word search puzzle using Python's Tkinter library. Here's an overview of what we accomplished:
    - **Word Entry**: We added an input field for users to enter words (comma-separated) which will be hidden in the word search grid.
    - **Grid Generation**: We implemented a function to generate a grid filled with random letters, ensuring that the words are placed in random directions (horizontal, vertical, diagonal).
    - **Word Selection**: We enabled cell selection in the grid. Selected cells highlight in yellow until a word is completely formed. If the word is valid, the cells change to green, indicating that the word has been found. If not, the cells revert to their original state.
    - **Word List Display**: The words are displayed on the right side of the interface. Found words are struck through.
    - **Timer**: We added a configurable timer (5 to 10 minutes) that counts down. If the user doesn't find all the words within the time limit, a message prompts them to try again.
    - **Solve Button**: A centrally placed "Solve" button highlights all the words in the grid, assisting the user in finding the words.
    - **Completion and Reset**: Upon finding all the words or the timer running out, the user is prompted to play again, allowing the game to reset.

  This project demonstrates the integration of Python with Tkinter to create interactive applications, enhancing user experience and interface design. 🧩🕹️

* Day 94: Technical Test "findSubstring" and "nextPermutation" [LeetCode](https://leetcode.com/problems/).
  * findSubstring: Given a string `s` and an array of strings `words`, find all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once and without any intervening characters. [Problem Description](https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/)
  * nextPermutation: Implement the next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order). The replacement must be in place and use only constant extra memory. [Problem Description](https://leetcode.com/problems/next-permutation/description/)
* Day 95: PhishGuard - Anti-Phishing Email and Website Filter
  * Today, we developed a phishing protection filter called **PhishGuard** using Python. Here's an overview of what we accomplished:
    - **Keyword Detection**: Implemented a function to identify phishing keywords in email content.
    - **URL Analysis**: Extracted and analyzed URLs from emails, checking them against a list of known phishing domains.
    - **Email Filtering**: Created a filter to process a list of emails, blocking those identified as phishing attempts.
    - **Hotmail Example**: Tested the filter with example Hotmail emails to demonstrate its effectiveness.
      
  This project highlights how Python can be used to enhance email security by detecting and blocking potential phishing attacks. 🛡️📧
* Day 96: World Clock GUI
  * Today, we developed a **World Clock GUI** using Python and Tkinter. Here's an overview of what we accomplished:
    - **Time Zone Updates**: Implemented a function to update and display the current time for multiple time zones including Colombia, New York, China, Germany, and Norway.
    - **GUI Design**: Created a user-friendly graphical interface with labeled clocks for each time zone, enhancing the visual appeal and usability.
    - **Icon and Flags**: Added an application icon and country flags to represent each time zone, providing a clear and engaging visual representation.
    - **Dynamic Updates**: Ensured the clock times are updated dynamically every second, keeping the displayed times accurate.

  This project showcases how Python can be used to create a functional and visually appealing world clock application. 🕒🌍
* Day 97: Pipelines for inference [🤗 Transformers](https://huggingface.co/docs/transformers/pipeline_tutorial)
  * Today, I explored the powerful pipeline feature from the Hugging Face Transformers library to perform automatic speech recognition (ASR) and text generation tasks. Here's a summary of what I accomplished:
    - **Automatic Speech Recognition**: Utilized the `pipeline()` function for ASR to transcribe audio files into text. Implemented and tested the OpenAI Whisper model for improved accuracy.
    - **Batch Processing**: Leveraged batch processing to handle multiple audio files efficiently, enhancing the pipeline's performance on a GPU.
    - **Task-Specific Parameters**: Experimented with parameters such as `return_timestamps` for subtitling and `chunk_length_s` for processing long audio files, demonstrating the flexibility of the pipeline.
    - **Device Management**: Configured the pipeline to run on the appropriate device (CPU or GPU) based on availability, optimizing computational resources.
    - **Dataset Integration**: Integrated the pipeline with datasets to perform inference on large datasets, showing the capability of the pipeline to handle extensive data inputs seamlessly.

  This project highlights the versatility and ease of using Hugging Face's pipeline feature for various NLP and ASR tasks, showcasing the practical applications of machine learning models in real-world scenarios.
* Day 98: Vehicle Management System
  * Today, I developed a Vehicle Management System to help the Universidad de Envigado manage the vehicles that enter and exit the campus. The system identifies each vehicle by its license plate and entry date. Here's a summary of what I accomplished:
    - **Vehicle Entry**: Implemented functionality to add a vehicle to the active vehicles list and log its entry time.
    - **Vehicle Exit**: Created a method to remove a vehicle from the active list and log its exit in the history.
    - **Date-Specific Entry Count**: Added a feature to determine the number of vehicles that entered the campus on a specific date.
    - **Entry Count by Vehicle**: Developed a function to list the number of times a specific vehicle has entered the campus.
    - **User-Friendly Menu**: Designed an interactive menu for users to manage vehicle entries and exits, check vehicle counts, and handle inputs gracefully, including validation for empty inputs.

  This project showcases the application of object-oriented programming principles to solve real-world problems, providing an efficient solution for managing campus vehicle traffic. The user-friendly interface ensures ease of use, while robust input validation enhances reliability.
* Day 99: 🌬️ Asthma Disease Dataset 🌬️ [Kaggle](https://www.kaggle.com/datasets/rabieelkharoua/asthma-disease-dataset/data)
  * Today, I worked with the Asthma Disease Dataset from Kaggle, aiming to analyze and model the factors contributing to asthma diagnosis. Here's a summary of what I accomplished:
    - **Data Exploration and Cleaning**: Conducted an initial exploration of the dataset to understand its structure and identify missing values. Cleaned the data by handling missing values and irrelevant columns.
    - **Feature Analysis**: Performed an exploratory data analysis (EDA) to visualize distributions of numerical features, correlations, and demographic insights. Created plots to understand the relationships between various factors and asthma diagnosis.
    - **Descriptive Statistics**: Calculated and interpreted key statistics for age distribution, gender, ethnicity, and education level among diagnosed and non-diagnosed patients.
    - **Pie Charts and Histograms**: Generated pie charts for categorical variables like ethnicity, gender, and education level. Plotted histograms for age distribution of diagnosed patients to identify trends.
    - **Correlation Heatmap**: Created a heatmap to visualize correlations between numerical features, helping to identify significant relationships.
    - **Model Training and Evaluation**: Developed and evaluated several machine learning models, including Logistic Regression, Random Forest, Gradient Boosting, Support Vector Machine, XGBoost, and K-Nearest Neighbors. Assessed model performance using accuracy and ROC AUC scores.
    - **Scaling and Splitting Data**: Preprocessed the data by scaling features and splitting it into training and testing sets to ensure robust model evaluation.

  This project highlights the importance of data preprocessing, exploratory analysis, and model evaluation in the context of medical data. The insights and models developed can help in understanding the factors influencing asthma diagnosis and potentially aid in early detection and prevention strategies.
* Day 100: 🎮 2048 Game with Flask 🎮

  * Today, I created a web-based 2048 game using Flask. The project involved building the game logic, setting up a server, and creating a responsive user interface. Here's a summary of what I accomplished:
    - **Flask Application Setup**: Initialized a Flask application to handle game logic and API endpoints. Defined routes for starting a new game, making moves, and autoplay functionality.
    - **Game Logic Implementation**: Developed functions to initialize the game board, add new tiles, and perform moves in all directions (left, right, up, down). Ensured that the game logic correctly merges tiles and adds new ones after each move.
    - **Autoplay Feature**: Implemented an autoplay feature that simulates moves automatically until the game ends. This feature helps demonstrate the game mechanics and provides a way to observe strategies for achieving higher scores.
    - **Game Over Check**: Added functionality to detect when the game is over, offering the option to restart the game and encouraging continuous play.
    - **User Interface Design**: Created a responsive UI using HTML and CSS, ensuring the game board is centered and visually appealing. Applied a dark background for better visibility and user experience.
    - **Styling with CSS**: Separated CSS into an external file, focusing on clean design and readability. Styled the board and cells to clearly display game states and centered numbers within their cells.
    - **JavaScript Integration**: Moved JavaScript code to an external file for better organization. Handled user input for moves, board rendering, and autoplay functionality.
    - **Restart Option**: Added a restart button to allow users to start a new game when the current game ends.
    - **Enhanced User Experience**: Improved the overall user experience by ensuring smooth interactions, clear game states, and responsive design elements.

  This project demonstrates the integration of front-end and back-end technologies to create an interactive web application. It highlights the importance of clean code organization, user-centric design, and robust game logic implementation. The 2048 game serves as a fun and engaging way to explore web development with Flask.

* Day 101: Technical Test "longestValidParentheses" and "search" [LeetCode](https://leetcode.com/problems/).
  * longestValidParentheses: Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. [Problem Description](https://leetcode.com/problems/longest-valid-parentheses/description/)
  * search: Given an array of integers `nums` sorted in ascending order, which is possibly rotated at an unknown pivot, and an integer `target`, find the index of `target` in `nums` or return -1 if it is not in `nums`. The algorithm must run in O(log n) time complexity. [Problem Description](https://leetcode.com/problems/search-in-rotated-sorted-array/description/)

* Day 102: 🍦 Object-Oriented Programming in Python with Ice Cream Example 🍦

  * Today, I explored the fundamentals of Object-Oriented Programming (OOP) in Python using a fun and relatable example: an ice cream shop. This project highlights the six basic principles of OOP—inheritance, cohesion, abstraction, polymorphism, coupling, and encapsulation. Here's a summary of what I accomplished:

    - **Abstraction and Encapsulation**: Created an abstract base class `IceCream` to represent the common attributes and behaviors of all ice creams. Encapsulated the flavor and price attributes to protect them from direct modification.
    - **Inheritance**: Developed two subclasses, `ScoopIceCream` and `Sundae`, inheriting from the `IceCream` class. These subclasses extend the base class by adding specific attributes like the number of scoops and toppings.
    - **Polymorphism**: Implemented a function `print_ice_cream_details` that takes any `IceCream` object and prints its details. This demonstrates how different ice cream objects can be handled through a single interface.
    - **Cohesion**: Ensured each class has a single, well-defined responsibility. For example, `ScoopIceCream` handles the specifics of scoop-based ice cream, while `Sundae` manages sundae-specific attributes.
    - **Coupling**: Maintained loose coupling between classes to ensure that changes in one class minimally affect others. This was achieved through well-defined interfaces and clear separation of responsibilities.
    - **Encapsulation**: Used private attributes to encapsulate the internal state of the objects, providing getter methods to access the values.
* Day 103: [TensorFlow](https://www.tensorflow.org/tutorials/keras/text_classification_with_hub) Text classification with TF Hub

  * Today, I explored text classification using TensorFlow Hub and TensorFlow Datasets. This project focused on building a neural network model to classify movie reviews as positive or negative. Here's a summary of what I accomplished:

    - **Data Loading and Preparation**: Utilized TensorFlow Datasets to download and prepare the IMDB dataset, splitting it into training, validation, and test sets.
    - **Exploration**: Examined the dataset to understand its structure and content. Each example in the dataset consists of a movie review (text) and a corresponding label (0 for negative, 1 for positive).
    - **Text Embedding**: Leveraged a pre-trained text embedding from TensorFlow Hub to convert sentences into embedding vectors. This approach simplifies text preprocessing, benefits from transfer learning, and provides a fixed-size output.
    - **Model Building**: Constructed a neural network model using Keras Sequential API. The model includes:
      - A TensorFlow Hub layer for text embedding.
      - A Dense layer with 16 hidden units and ReLU activation.
      - A Dense output layer with a single unit for binary classification.
    - **Loss Function and Optimizer**: Configured the model with the `binary_crossentropy` loss function and the Adam optimizer. This setup is suitable for binary classification tasks.
    - **Model Training**: Trained the model for 10 epochs using mini-batches of 512 samples, monitoring the loss and accuracy on the validation set.
    - **Model Evaluation**: Evaluated the model on the test set to measure its performance, reporting both loss and accuracy.

  This project demonstrates the application of TensorFlow and TensorFlow Hub for natural language processing tasks. It highlights the importance of using pre-trained models for efficient text embedding and the benefits of a well-structured neural network for text classification.
* Day 104: Battleship Game with Flask
  * Today, I developed a Battleship game using Flask, a micro web framework for Python. This project involved creating a web-based version of the classic Battleship game, where users can guess the locations of ships on a grid. Here's a summary of what I accomplished:

    - **Setting Up Flask Application**: Initialized a Flask project, set up routes, and managed sessions to maintain game state between requests.
    - **Game Logic Implementation**: Implemented the core game logic in Python, including functions for creating ships, processing user guesses, and checking for game over conditions.
    - **Session Management**: Utilized Flask sessions to store the hidden and guess boards, ensuring the game state is preserved between user interactions.
    - **User Interface**: Developed HTML templates using Jinja2 to render the game board and provide a user-friendly interface. Included labels for rows and columns to guide the user.
    - **Game Mechanics**: Added functionality to handle user guesses, update the game board, and provide feedback on hits and misses. Also implemented logic to reveal ship locations if the user runs out of turns.

  This project showcases how to build a simple yet interactive web application with Flask. It emphasizes the importance of session management in web applications and demonstrates how to create a dynamic user interface with Jinja2 templates. Additionally, it illustrates the implementation of classic game mechanics in a web-based environment.

* Day 105: Technical Test "searchRange" and "searchInsert" [LeetCode](https://leetcode.com/problems/).

  - **searchRange**: Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given target value. If the target is not found in the array, return [-1, -1]. The algorithm must run in O(log n) time complexity.
  [Problem Description](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/)
    
  - **searchInsert**: Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. The algorithm must run in O(log n) time complexity. [Problem Description](https://leetcode.com/problems/search-insert-position/description/)
* Day 106: Create a Multipage App with Streamlit [Streamlit Tutorial](https://docs.streamlit.io/get-started/tutorials/create-a-multipage-app)
  * Today, I focused on building a multipage web application using Streamlit, a popular open-source app framework for Machine Learning and Data Science projects. This project involved creating a web application that can navigate between different pages, each displaying unique content or functionality. Here's a summary of what I accomplished:

    - **Setting Up Streamlit Environment**: Installed Streamlit and set up the development environment.
    - **Creating Pages**: Developed multiple pages for the application, each serving a distinct purpose. For example, a home page, a data visualization page, and a user input page.
    - **Navigation Implementation**: Implemented a navigation system to switch between different pages. Used Streamlit’s built-in components to create a user-friendly interface for navigation.
    - **Dynamic Content**: Ensured each page displays dynamic content based on user interactions. For instance, visualizations that update based on user input or data selections.
    - **User Interface Design**: Designed the layout and style of the application to make it intuitive and visually appealing. Leveraged Streamlit’s layout options and widgets to enhance the user experience.

  This project showcases the versatility of Streamlit in creating interactive and multipage web applications. It emphasizes the ease of setting up a multi-page structure and the ability to integrate dynamic content seamlessly. This was an excellent exercise in web development and user interface design, demonstrating how to build comprehensive applications using Streamlit.
* Day 107: Twenty One Card Game GUI
  * Today, I developed a Twenty-One card game (similar to Blackjack) in Python. This project involved creating the core game logic, displaying cards, handling user interactions, and implementing the rules of the game. Here's a summary of what I accomplished:

    - **Card Display Function**: Created a function to display cards in a visually appealing format using ASCII art. This function helps players see their cards and the dealer's cards clearly.
    - **Random Card Generation**: Implemented a function to generate random cards, ensuring a mix of suits and values for each game.
    - **Card Value Calculation**: Developed a function to calculate the value of each card, considering the special case for Aces, which can be worth either 1 or 11 points.
    - **Game Logic**: Implemented the main game loop, handling the player's turn and the dealer's turn, including decision-making processes and win/lose conditions.
    - **User Interaction**: Added functionality for user input to decide whether to continue playing or stop, and to determine if the player wants to try again after a game ends.

  This project demonstrates the implementation of a classic card game using Python, focusing on interactive gameplay and dynamic card management. It emphasizes the importance of user-friendly design and accurate game mechanics.
* Day 108: Character-Level Language Model with RNN
  * Today, I developed a simple character-level language model using Recurrent Neural Networks (RNN) with TensorFlow and Keras. This project involved creating a model to predict the next character in a sequence of text. Here's a summary of what I accomplished:

    - **Text Preparation**: Prepared the input text by creating mappings from characters to indices and vice versa. Split the text into sequences for training.
    - **Dataset Creation**: Generated training data by creating overlapping sequences of characters and the corresponding next character to predict.
    - **Model Building**: Constructed an RNN model using Keras. The model includes:
      - An Embedding layer to learn character embeddings.
      - A SimpleRNN layer to capture sequential dependencies.
      - A Dense output layer with softmax activation to predict the next character.
    - **Model Compilation**: Compiled the model using categorical cross-entropy loss and the Adam optimizer.
    - **Model Training**: Trained the model on the prepared dataset, using a batch size of 2 and running for 100 epochs.
    - **Prediction Function**: Implemented a function to predict the next character given a sequence of characters. This function uses the trained model to generate predictions.

  This project showcases the process of building a character-level language model using RNNs. It emphasizes the importance of text preprocessing, sequence generation, and model training for sequential data tasks. The model is capable of predicting the next character in a sequence, demonstrating the potential of RNNs in natural language processing.
* Day 109: PolarsVSPandas (Polars Is The Faster Pandas) [NeuralNine](https://www.youtube.com/watch?v=zthI91ASV58)
  * Today, I explored the performance differences between Pandas and Polars for data manipulation tasks. This project was inspired by NeuralNine's video on Polars being faster than Pandas. Here's a summary of what I accomplished:

    - **Data Preparation**: Created a dataset with 120,000 rows of random data using NumPy.
    - **DataFrame Creation**: Generated DataFrames using both Pandas and Polars to compare their performance.
    - **Reading Data**: Measured the time taken to read the data into Pandas and Polars DataFrames.
    - **Aggregation**: Performed aggregation operations to calculate the mean of column 'B' and the sum of column 'C' grouped by column 'A'.
    - **Filtering**: Filtered the data to include only rows where column 'A' is greater than 50.
    - **Joining**: Conducted join operations to merge two DataFrames on column 'A'.
    - **Conditional Column Addition**: Added a new column to a DataFrame based on a condition using both Pandas and Polars.

  This project demonstrates the significant performance improvements that Polars offers over Pandas for certain data manipulation tasks. It highlights the importance of choosing the right tools for data processing to achieve efficient and scalable solutions. Special thanks to NeuralNine for the step-by-step guide provided in his video.

* Day 110: Technical Test "isValidSudoku" and "solveSudoku" [LeetCode](https://leetcode.com/problems/).

  - **isValidSudoku**: Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
    - Each row must contain the digits 1-9 without repetition.
    - Each column must contain the digits 1-9 without repetition.
    - Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
    Note:
    - A Sudoku board (partially filled) could be valid but is not necessarily solvable.
    - Only the filled cells need to be validated according to the mentioned rules.
    [Problem Description](https://leetcode.com/problems/valid-sudoku/description/)
    
  - **solveSudoku**: Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules:
    - Each of the digits 1-9 must occur exactly once in each row.
    - Each of the digits 1-9 must occur exactly once in each column.
    - Each of the digits 1-9 must occur exactly once in each of the nine 3x3 sub-boxes of the grid.
    The '.' character indicates empty cells.
    [Problem Description](https://leetcode.com/problems/sudoku-solver/description/)
* Day 111: Library Management System

  - Today, I developed a Flask-based system for managing books, members, loans, and returns in a library setting. Data storage is handled using JSON files.
    - **Features**:
      - **Books Management**: Add, view, and list books.
      - **Members Management**: Add and list members.
      - **Loans Management**: Loan and return books with member associations.
    - **Technologies**: Flask, JSON, HTML/CSS.
    - **Project Structure**:
      - **app.py**: Flask application handling routes and data operations.
      - **templates/**: HTML templates for rendering pages.
      - **static/**: CSS styles for frontend.
    - **Future Enhancements**: Implement editing and deletion functionalities for books and members, search functionality, and user authentication.
* Day 112: Maze Generator and Solver
  - **Maze Generator**: Implemented a recursive maze generator using the turtle graphics library in Python. The maze is generated by moving the turtle to adjacent cells based on the least visited neighbors.
  - **Maze Solver**: Developed a recursive solver to find the path from the start to the end of the maze. The path is drawn using a different color to indicate the solution.

  This project showcases the use of recursive algorithms for generating and solving mazes, highlighting the power of Python's turtle graphics library for visualizing the process.
* Day 113: Basketball Scoreboard in Flask

  - **Basketball Scoreboard**: Created a web application using Flask to simulate a basketball scoreboard. The scoreboard allows users to input the names of the home and away teams, track scores (1-point, 2-point, and 3-point baskets), fouls, and display the current quarter or overtime. The game progresses through regular quarters, halftime, and overtime periods as needed, with a final winner determined based on scores.

  This project demonstrates the use of Flask for web development and real-time updating of game states, showcasing interactive elements like score tracking, foul recording, and game progression logic.
* Day 114: Internet Speed Test Application

  - **Internet Speed Test Application**: Developed a desktop application using Tkinter to measure internet speed. The application tests the download and upload speed as well as the ping of the user's internet connection. Results are displayed in the application window in real-time.

    - **Speed Test**: Utilized the Speedtest library to measure download and upload speeds in Mbps, and ping in milliseconds. The results are displayed in a user-friendly format.
    - **User Interface**: Designed a simple and intuitive GUI using Tkinter, with buttons to start the speed test, display information about the application, and exit the program.
    - **Information Dialog**: Added an information dialog box to provide users with details about the application's functionality.

  This project demonstrates the use of Tkinter for building desktop applications and integrating third-party libraries to perform real-time internet speed tests.
* Day 115: Steganography Application using Flask

  - **Steganography Application**: Developed a web application using Flask to hide and reveal secret messages within images using the Stegano library. This project involved creating a user-friendly interface for uploading images and entering messages to hide or reveal.

    - **Hide Message**: Implemented functionality to allow users to upload an image and input a message, which is then hidden within the image using the LSB (Least Significant Bit) method provided by the Stegano library. The resulting image is saved and displayed to the user.
    - **Reveal Message**: Added functionality to upload an image and extract any hidden message from it. The extracted message, if any, is displayed to the user along with the image.
    - **User Interface**: Designed a clean and intuitive web interface with routes for hiding and revealing messages, ensuring ease of use and smooth user experience.

    This project demonstrates the use of Flask for building web applications, integrating third-party libraries for steganography, and handling file uploads and processing.
* Day 116: Technical Test "countAndSay" and "combinationSum" [LeetCode](https://leetcode.com/problems/).

  - **countAndSay**: Generate the nth term in the count-and-say sequence. The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
    - countAndSay(1) = "1"
    - countAndSay(n) is the run-length encoding of countAndSay(n - 1).
    
    For example, to compress the string "3322251" using run-length encoding, replace "33" with "23", replace "222" with "32", replace "5" with "15" and replace "1" with "11". Thus the compressed string becomes "23321511".
    [Problem Description](https://leetcode.com/problems/count-and-say/description/)

  - **combinationSum**: Return a list of all unique combinations of candidates where the chosen numbers sum to a given target. Each number in candidates may be used an unlimited number of times in the combination. Two combinations are unique if the frequency of at least one of the chosen numbers is different.

    Given an array of distinct integers `candidates` and a target integer `target`, this problem finds all unique combinations of candidates that sum to the target. The test cases are generated such that the number of unique combinations that sum up to the target is less than 150 combinations for the given input.
    [Problem Description](https://leetcode.com/problems/combination-sum/description/)
* Day 117: Recursion "BinaryTreeExpressionEvaluator"
  * This project defines a binary tree where each node can be a numeric value or an operator. It evaluates the expression represented by the binary tree using recursion. The supported operations are addition, subtraction, multiplication, division, and exponentiation.
  
  - **TreeNode Class**: A class that represents a node in the binary tree.
    - `value`: The value of the node, which can be an integer (leaf node) or an operator (internal node).
    - `left`: The left child node.
    - `right`: The right child node.
  
  - **evaluate_tree Function**: A function that evaluates the binary tree to compute the result of the expression it represents.
    - It takes the root node of the binary tree as an argument.
    - It returns the result of the expression as an integer or float.
    - It raises a `ValueError` if there is an attempt to divide by zero.
  
  - **Example Usage**: The project includes an example usage of creating a binary tree for the expression `((3 + 2) * (4 - 1)) ^ 2` and evaluating it to get the result.

  This project showcases the power of recursion in evaluating complex expressions represented by binary trees, highlighting the versatility of binary trees in computational problems.
* Day 118: Shirt Store
  * Implemented a Python application for managing a shirt store using object-oriented programming concepts. The application allows users to add shirts to the store's inventory, manage customer interactions including adding to cart and purchasing, and view store and customer details.
* Day 119: Household Basket
  - **Household Basket Application**: Developed a desktop application using Tkinter to manage household items in a basket, including fruits, vegetables, meat, dairy, and other categories. The application connects to an SQLite database to store and manage the items.

    - **Add Item**: Implemented functionality to add items to the household basket. Users can select a category, enter the name and quantity of the item, and add it to the database. Validation ensures proper input for name and quantity fields.
    - **View Items**: Added a treeview to display all items in the household basket. Users can see the item ID, category, name, and quantity.
    - **Delete Item**: Included functionality to delete selected items from the basket. Users can select an item from the treeview and remove it from the database with a single click.
    - **Database Management**: Utilized SQLite to create a persistent storage solution for the household basket items. Functions were developed to create the table, insert items, retrieve items, and delete items from the database.
    - **User Interface**: Designed a user-friendly and responsive interface with Tkinter, ensuring a smooth user experience. The interface includes input fields, buttons, and a treeview to manage and display items effectively.
* Day 120: Copa America 2024 Groups [Dataset](https://en.wikipedia.org/wiki/2024_Copa_Am%C3%A9rica)
  - **Copa America 2024 Groups**: Developed a Python script to scrape and process data from the Wikipedia page for the 2024 Copa América, extracting the group stage tables and organizing them into a dictionary for easy access and manipulation.
    - **Data Scraping**: Used the `pandas` library to read all tables from the Wikipedia page, focusing on the relevant indices to extract the tables for Groups A to D.
    - **Data Processing**: Renamed the second column of each table to "Team" and removed the "Qualification" column for cleaner data representation.
    - **Data Organization**: Stored the processed tables in a dictionary, with group letters as keys for easy retrieval and display.
    - **Data Persistence**: Saved the dictionary to a file using the `pickle` library for persistent storage and later use.
* Day 121: Technical Test "combinationSum2" and "firstMissingPositive" [LeetCode](https://leetcode.com/problems/).
  - **combinationSum2**: Find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination, and the solution set must not contain duplicate combinations. This problem involves using a backtracking approach to explore all possible combinations, ensuring that no duplicates are included in the result set. [Problem Description](https://leetcode.com/problems/combination-sum-ii/description/)

  - **firstMissingPositive**: Return the smallest positive integer that is not present in an unsorted integer array `nums`. The algorithm must run in O(n) time and use O(1) auxiliary space. The solution involves rearranging the array so that each positive integer `n` is placed at index `n-1`. Then, the first index that does not contain the correct integer indicates the missing positive integer. [Problem Description](https://leetcode.com/problems/first-missing-positive/description/)
* Day 122: Recursion "Knapsack"

  * This project tackles the Knapsack problem using both recursive and dynamic programming approaches. The Knapsack problem is a classic algorithmic problem that involves selecting items with given weights and values to maximize the total value without exceeding the weight capacity.

  - **knapsack_recursive Function**: A recursive function to solve the Knapsack problem.
    - `weights`: A list of weights of the items.
    - `values`: A list of values of the items.
    - `W`: The maximum weight capacity of the knapsack.
    - `n`: The number of items.
    - This function returns the maximum value that can be obtained by including or excluding the nth item.
    - Base cases include no items left or a knapsack capacity of 0. The function chooses the maximum value between including and not including the nth item.

  - **knapsack_dynamic Function**: A dynamic programming function to solve the Knapsack problem.
    - `weights`: A list of weights of the items.
    - `values`: A list of values of the items.
    - `W`: The maximum weight capacity of the knapsack.
    - This function returns the maximum value that can be obtained using a bottom-up approach to build a table `dp` where `dp[i][w]` represents the maximum value that can be obtained with the first `i` items and a knapsack capacity of `w`.
    - The function iterates over the items and capacities, filling the table based on whether the item is included or not.

  - **Example Usage**: The project includes an example with weights `[1, 2, 3, 4]`, values `[10, 20, 30, 40]`, and a knapsack capacity `W = 5`. It demonstrates the maximum value calculation using both recursive and dynamic programming approaches.
* Day 123: [TLC Trip Record Data](https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page)
  - **NYC Taxi Data Analysis**: Developed a data analysis project using PySpark and Pandas to process and visualize the NYC Yellow Taxi Trip data. This project involved extensive data cleaning, transformation, and visualization to uncover patterns and insights from the dataset.

    - **Data Cleaning and Transformation**: Utilized PySpark for efficient handling of large datasets. Performed data cleaning steps such as filtering out invalid data, handling missing values, and creating new columns for analysis.
      - **Trip Duration Calculation**: Calculated trip duration from pickup and dropoff timestamps and added it as a new column.
      - **Sampling**: Extracted a sample of the data to facilitate visualization and analysis in Pandas.

    - **Data Visualization**: Converted the cleaned data to a Pandas DataFrame for visualization using Seaborn and Matplotlib.
      - **Distribution of Trip Durations**: Plotted a histogram to show the distribution of trip durations.
      - **Trips per Hour**: Visualized the number of trips per hour to identify peak times for taxi rides.
      - **Trip Distance vs Fare Amount**: Created scatter plots to explore the relationship between trip distance and fare amount.
      - **Heatmaps of Pickup and Dropoff Locations**: Generated heatmaps to show the frequency of pickups and dropoffs by location ID.
      - **Passenger Count Distribution**: Displayed the distribution of the number of passengers per trip.
      - **Payment Type Distribution**: Visualized the distribution of different payment types used in the trips.
      - **Total Amount vs Tip Amount**: Plotted the relationship between the total fare amount and the tip amount.

  This project demonstrates the use of PySpark for big data processing and Pandas/Seaborn for detailed data visualization, providing insights into the NYC taxi operations and passenger behaviors.
* Day 124: 🏫 Object-Oriented Programming in Python with University Enrollment System 🏫

  * Today, I worked on a university enrollment system project to reinforce the principles of Object-Oriented Programming (OOP) in Python. This project incorporates key OOP concepts such as inheritance, encapsulation, and abstraction. Here's a summary of what I accomplished:

    - **Abstraction and Encapsulation**: Created an abstract base class `Person` to represent common attributes and behaviors for both students and teachers. Encapsulated the name and ID number attributes to protect them from direct modification. Implemented abstract methods to enforce a consistent interface for subclasses.
    - **Inheritance**: Developed two subclasses, `Student` and `Teacher`, inheriting from the `Person` class. These subclasses extend the base class by adding specific attributes and methods like enrolling in courses and assigning courses.
    - **Course Management**: Created a `Course` class to represent a university course, including attributes for course name, credits, teacher, and maximum number of students. Added methods to handle student enrollment, calculate total students, and determine the cost per student.
    - **User Interaction**: Implemented a menu-driven interface to allow users to enroll students in courses, display student details, and show course information. This interactive component showcases how OOP can be used to structure complex, real-world applications.
    - **Data Storage**: Used dictionaries to manage and store student instances, demonstrating the practical use of data structures in conjunction with OOP to handle multiple objects efficiently.

  This project provided a comprehensive exercise in applying OOP principles to a realistic scenario, reinforcing the importance of well-structured, maintainable, and scalable code.
* Day 125: Technical Test "trap" and "multiply" [LeetCode](https://leetcode.com/problems/).
  - **trap**: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. This problem involves using a two-pointer approach to traverse the elevation map and calculate the trapped water by comparing the heights of bars. It requires understanding how to efficiently track the maximum heights from both ends of the array to determine the water level at each position. [Problem Description](https://leetcode.com/problems/trapping-rain-water/description/)

  - **multiply**: Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string. The solution must not use any built-in BigInteger library or convert the inputs to integers directly. This problem requires implementing a manual multiplication algorithm similar to the one learned in school, handling digit-by-digit multiplication, and managing carry-over between digits. [Problem Description](https://leetcode.com/problems/multiply-strings/description/)
* Day 126: Basketball Ground Using Turtle
  * Created a visual representation of a basketball court using the Turtle graphics library in Python. This project involves drawing a complete basketball court with various elements like the court boundaries, center circle, and basket areas.

  - **Drawing the Court**: Utilized Turtle graphics to draw the court boundaries, including the outer lines and the rectangular playing area.
  - **Center Circle and Baskets**: Implemented functions to draw the center circle and the areas around the baskets, including the semi-circles and rectangles that represent the key areas on the court.
  - **Colors and Aesthetics**: Used different colors and fill patterns to differentiate various parts of the court, enhancing the visual appeal and clarity of the representation.

  This project showcases the capabilities of the Turtle graphics library for creating detailed and visually appealing graphics. It also emphasizes the importance of geometric calculations and the use of loops and functions to create complex shapes and patterns.

  The code for this project was adapted from an example on GeekforGeeks: [Create a Basketball Ground Using Turtle Library in Python](https://www.geeksforgeeks.org/create-a-basketball-ground-using-turtle-library-in-python/).
* Day 127: Employee Hours
  - **Employee Hours Management System**: Developed a web application using Flask and SQLite to manage and track employee working hours. This project includes functionalities for user authentication, logging working hours, editing logged hours, and visualizing the weekly work schedule.

    - **User Authentication**: Implemented login and registration features to ensure secure access to the application.
      - **Login**: Users can log in with their username and password. If credentials are invalid, an error message is displayed.
      - **Registration**: New users can register by providing a username and password. The registration page is linked from the login page.

    - **Logging Working Hours**: Provided functionality to log working hours with task details.
      - **Form Validation**: Ensured that logged hours are within weekdays (Monday to Friday) and between 06:00 and 23:00. If the user tries to log hours outside these constraints, an error message is displayed.

    - **Editing Logged Hours**: Allowed users to edit previously logged hours.
      - **Task and Start Time Modification**: Users can update the task description and the start time of logged hours, with the same validation constraints as logging new hours.

    - **Data Visualization**: Displayed the logged hours in a tabular format showing the weekly schedule.
      - **Weekly Schedule Table**: Organized logged hours by day and time, highlighting the tasks performed.
      - **Total Hours Calculation**: Summed up the total hours worked in a week and displayed it. If total hours exceed 42, the overtime hours are also shown.

    - **Database Management**: Used SQLite to store user credentials and logged hours.
      - **Database Initialization**: Created tables for users and logged hours if they do not exist.

    - **Additional Features**:
      - **Clear Hours**: Added a button to clear all logged hours for the next week, ensuring a fresh start.
      - **Responsive Design**: Implemented a professional CSS for a better user experience and user interface.

    This project demonstrates the use of Flask for web development, SQLite for database management, and JavaScript for client-side validation. It provides a comprehensive solution for managing and tracking employee working hours, ensuring data integrity and user-friendliness.
* Day 128: Recursion "Letter Combinations"

  * This project focuses on solving the "Letter Combinations of a Phone Number" problem using recursion. Given a string containing digits from 2-9 inclusive, the goal is to return all possible letter combinations that the number could represent. The mapping of digits to letters is based on the traditional telephone keypad.

  - **letter_combinations Function**: A recursive function to find all possible letter combinations for a given phone number.
    - `digits`: A string containing the digits from 2-9.
    - This function returns a list of all possible letter combinations.
    - The function uses a helper function `backtrack` to perform backtracking and explore all possible combinations.
    - The `phone_map` dictionary maps each digit to its corresponding letters.
    - The `backtrack` function iterates over all letters that map to the next available digit, appending the current letter to the combination and proceeding with the next digit until all digits are processed.
* Day 129: Pneumonia Detection Using Deep Learning

  - **Pneumonia Detection System**: Developed a deep learning model to detect pneumonia from chest X-ray images. This project includes data wrangling, model training, and evaluation using TensorFlow.

    - **Data Collection and Preparation**: 
      - **Dataset**: Utilized a dataset from Kaggle containing chest X-ray images categorized as "NORMAL" or "PNEUMONIA".
      - **Pathlib for File Handling**: Separated the dataset into training, validation, and test sets using Pathlib.
      - **Data Wrangling**: Generated labels for the images based on their directory names.

    - **Model Development**: 
      - **Data Preprocessing**: Implemented functions to load, transform, and create TensorFlow datasets from the image paths and labels.
      - **Model Architecture**: Used ResNet50V2 as the backbone for the CNN model, followed by GlobalAveragePooling2D and Dense layers with a sigmoid activation function.
      - **Regularization Techniques**: Added dropout and L2 regularization to improve model generalization and prevent overfitting.

    - **Model Training**: 
      - **Compilation**: Compiled the model with the Adam optimizer and binary cross-entropy loss, tracking accuracy, precision, and recall metrics.
      - **Callbacks**: Implemented ModelCheckpoint and EarlyStopping to save the best model and stop training early if no improvement was observed.
      - **Training Process**: Trained the model on the training dataset, validating it with the validation dataset over multiple epochs.

    - **Evaluation and Interpretation**: 
      - **Model Evaluation**: Evaluated the model on the test dataset to calculate accuracy, precision, and recall.
      - **Visualizations**: Plotted the training and validation metrics over epochs to interpret the model's performance.

    - **Complete Model and Deployment**: 
      - **Saving the Model**: Saved the best model weights and the complete trained model for future use.
      - **Loading and Testing**: Loaded the saved model and tested it on new images to ensure it works as expected.

    This project demonstrates the use of deep learning for medical image classification, involving data preprocessing, model building, training, and evaluation with TensorFlow. It provides a comprehensive solution for detecting pneumonia from chest X-rays, showcasing the potential of AI in healthcare.
* Day 130: Technical Test "WildcardisMatch" and "jump" [LeetCode](https://leetcode.com/problems/)
  - **WildcardisMatch**: Given an input string `s` and a pattern `p`, implement wildcard pattern matching with support for `?` and `*`. The `?` matches any single character, while the `*` matches any sequence of characters (including the empty sequence). The solution should cover the entire input string, not just a partial match. This problem involves using dynamic programming to efficiently manage the different matching scenarios and ensure the pattern matches the entire string. [Problem Description](https://leetcode.com/problems/wildcard-matching/description/)
  - **jump**: Given a 0-indexed array of integers `nums` of length `n`, where each element `nums[i]` represents the maximum length of a forward jump from index `i`, return the minimum number of jumps to reach `nums[n - 1]`. The solution should use a greedy algorithm to track the farthest point that can be reached and count the jumps needed to reach the last index. The test cases guarantee that you can reach the last index. [Problem Description](https://leetcode.com/problems/jump-game-ii/description/)
* Day 131: 🐕 Dogs vs Cats 🐈 [Kaggle](https://www.kaggle.com/datasets/salader/dogs-vs-cats)

  * Today, I worked with the Dogs vs Cats dataset from Kaggle, focusing on developing a Convolutional Neural Network (CNN) to classify images of dogs and cats. Here's a summary of what I accomplished:
    - **Data Preparation**: Downloaded and extracted the dataset, and created training and validation datasets using TensorFlow’s `image_dataset_from_directory` function. The images were normalized for better model performance.
    - **Model Architecture**: Built a CNN using Keras, consisting of multiple Conv2D layers with Batch Normalization and MaxPooling. The model included three Conv2D layers with increasing filter sizes (32, 64, 128) to extract features from the images.
    - **Fully Connected Layers**: Added fully connected Dense layers to the model, with Dropout for regularization, to perform the final classification.
    - **Model Compilation**: Compiled the model with Adam optimizer and binary cross-entropy loss function, suitable for binary classification tasks.
    - **Training**: Trained the model on the prepared dataset for 9 epochs, validating its performance on the validation dataset. Visualized the training and validation accuracy and loss over epochs using Matplotlib.
    - **Testing**: Tested the model with sample images of dogs and cats to verify its predictions.

  This project highlights the importance of proper data preprocessing, designing a robust neural network architecture, and evaluating the model's performance to achieve accurate image classification. The insights and models developed can be further refined and used for various image classification tasks.
* Day 132: 🎬 Object-Oriented Programming in Python with Movie Subscription System 🎬

  * Today, I worked on a movie subscription system project to reinforce the principles of Object-Oriented Programming (OOP) in Python. This project incorporates key OOP concepts such as inheritance, encapsulation, and abstraction. Here's a summary of what I accomplished:

    - **Abstraction and Encapsulation**: Created an abstract base class `Person` to represent common attributes and behaviors for both viewers and directors. Encapsulated the name and ID number attributes to protect them from direct modification. Implemented abstract methods to enforce a consistent interface for subclasses.
    - **Inheritance**: Developed two subclasses, `Viewer` and `Director`, inheriting from the `Person` class. These subclasses extend the base class by adding specific attributes and methods like subscribing to genres and adding movies to the director's filmography.
    - **Movie Management**: Created a `Movie` class to represent a movie, including attributes for the movie title, genre, director, rating, and duration. Added methods to handle movie details and categorize movies by genre.
    - **User Interaction**: Implemented a menu-driven interface to allow users to subscribe viewers to genres, display viewer details, and show movie information. This interactive component showcases how OOP can be used to structure complex, real-world applications.
    - **Data Storage**: Used dictionaries to manage and store viewer instances, demonstrating the practical use of data structures in conjunction with OOP to handle multiple objects efficiently.

  This project provided a comprehensive exercise in applying OOP principles to a realistic scenario, reinforcing the importance of well-structured, maintainable, and scalable code.
* Day 133: 🤖 Implementing a Simple Neural Network in Python with Backpropagation 🤖

  * Today, I worked on a project to build a simple neural network from scratch in Python, focusing on the fundamental concepts of neural networks and backpropagation. Here's a summary of what I accomplished:

    - **Activation Function**: Implemented the sigmoid function and its derivative, which are essential for the forward and backward passes in the neural network.
    - **Loss Function**: Used the mean squared error (MSE) as the loss function to measure the performance of the neural network.
    - **Network Initialization**: Created a `NeuralNetwork` class with two hidden layers. Randomly initialized the weights for connections between the input layer, hidden layers, and output layer.
    - **Forward Propagation**: Developed a method to pass input data through the network, compute the activations of the hidden layers and the final output.
    - **Backward Propagation**: Implemented the backpropagation algorithm to update the weights based on the error between predicted and actual outputs. This involved calculating deltas for each layer and adjusting the weights using the learning rate.
    - **Training the Network**: Trained the neural network using a small dataset, splitting it into training and validation sets. Monitored the training and validation loss to ensure the network was learning correctly.
    - **Prediction**: Added a function to test the trained network with new input data, demonstrating its ability to make predictions.

  This project provided a hands-on exercise in understanding and implementing the core components of a neural network, from initialization to training and prediction. It reinforced key concepts in machine learning, such as forward and backward propagation, weight updates, and performance evaluation.
* Day 134: ♟️ Building a Chess Game in Python with Object-Oriented Programming ♟️

  * Today, I worked on a project to create a chess game in Python, focusing on the principles of Object-Oriented Programming (OOP). This project involved designing classes for different chess pieces and implementing their movements on the board. Here's a summary of what I accomplished:

    - **ChessPiece Base Class**: Developed an abstract `ChessPiece` class to represent a generic chess piece. This class includes a `color` attribute and an abstract method `get_legal_moves` which must be implemented by subclasses.
    
    - **King Class**: Created a `King` class that inherits from `ChessPiece` and implements the `get_legal_moves` method to return all possible legal moves for the king, considering its unique movement rules.

    - **Queen Class**: Developed a `Queen` class that combines straight and diagonal moves, mimicking the behavior of both a rook and a bishop. This class uses helper methods `get_straight_moves` and `get_diagonal_moves` to calculate all legal moves.

    - **Rook Class**: Created a `Rook` class that inherits from `ChessPiece` and reuses the `get_straight_moves` method from the `Queen` class to determine its legal moves.

    - **Bishop Class**: Implemented a `Bishop` class that inherits from `ChessPiece` and reuses the `get_diagonal_moves` method from the `Queen` class to calculate its legal moves.

    - **Knight Class**: Designed a `Knight` class with a unique movement pattern, implementing its own `get_legal_moves` method to return all possible L-shaped moves.

    - **Pawn Class**: Developed a `Pawn` class that includes specific movement rules such as moving forward one or two squares from the starting position and capturing diagonally.

    - **ChessBoard Class**: Created a `ChessBoard` class to initialize the board with all pieces in their starting positions. This class includes methods to display the board, move pieces, check for valid moves, and evaluate the position.

    - **Move Validation**: Implemented logic in the `move_piece` method to ensure moves are legal according to each piece's movement rules. This method also switches the current turn between white and black players.

    - **Evaluation and Legal Moves Generation**: Added methods to evaluate the board's position and generate all legal moves for a given color, providing a foundation for future enhancements like check and checkmate detection.

  This project provided a comprehensive exercise in applying OOP principles to a classic game, reinforcing the importance of creating maintainable and scalable code. It also offered a practical way to implement and test various chess piece movements and game mechanics.
* Day 135: ☕ Analyzing Worldwide Coffee Consumption Trends with Python ☕

  Today, I focused on a data analysis project that examines coffee consumption patterns across various countries using a dataset that spans from 2000 to 2023. This project provided valuable insights into how coffee is enjoyed around the world. Here's a summary of what I accomplished:

  - **Loading the Data**: Imported the dataset containing information on coffee consumption, prices, types of coffee consumed, and population for different countries.

  - **Data Exploration**: Explored the dataset to understand its structure, including the number of records, data types, and basic statistics.
    - **Fields and Data Types**:
      - `Country`: The name of the country where the data was collected.
      - `Year`: The year of the record, spanning from 2000 to 2023.
      - `Coffee Consumption (kg per capita per year)`: The amount of coffee consumed per person annually.
      - `Average Coffee Price (USD per kg)`: The average price of coffee per kilogram in US dollars.
      - `Type of Coffee Consumed`: The most popular types of coffee enjoyed in each country.
      - `Population (millions)`: The estimated population of each country.

  - **Data Cleaning**: Renamed columns to remove spaces and make them more code-friendly.

  - **Handling Missing Data**: Checked for and handled any missing data to ensure the dataset was complete and accurate for analysis.

  - **Exploratory Data Analysis (EDA)**: Conducted various analyses to gain insights into the data:
    - **Distributions**: Plotted histograms for numerical features to understand their distributions.
    - **Trends Over Time**: Analyzed the number of records per year for different types of coffee.
    - **Correlation Analysis**: Created a heatmap to visualize the correlations between numerical features.
    - **Pie Charts**: Visualized the distribution of different types of coffee consumed.
    - **Stacked Bar Chart**: Showed the trends of coffee types consumed over the years.
    - **Box Plot**: Compared coffee prices across different countries.
    - **Top Countries Analysis**: Identified and analyzed the top 10 countries by average coffee consumption.
    - **Heatmap**: Displayed the distribution of different types of coffee consumed across countries.

  This project provided a comprehensive exercise in data analysis, helping to reinforce key concepts in data cleaning, exploration, visualization, and interpretation.
* Day 136: Technical Test "permute" and "permuteUnique" [LeetCode](https://leetcode.com/problems/)
  - **permute**: Given an array `nums` of distinct integers, return all possible permutations. The solution involves using backtracking to generate permutations by swapping elements and recursively building each permutation until the entire array is permuted. [Problem Description: Permutations](https://leetcode.com/problems/permutations/description/)
  - **permuteUnique**: Given a collection of numbers that might contain duplicates, return all possible unique permutations. The solution sorts the input array and uses backtracking with a set to skip over duplicate elements during the permutation process. [Problem Description: Permutations II](https://leetcode.com/problems/permutations-ii/description/)
* Day 137: Test Projects "NotesManager"
  * Today, we're focusing on writing unit tests for a simple Note Manager application. Testing is a crucial part of software development, ensuring that our code works as expected and helps prevent bugs from creeping into our projects. We'll use Python's unittest module to create and run our tests. This exercise will help you understand the basics of writing tests and how to use them to verify the correctness of your code.
* Day 138: 🐾 Developing a Pet Store Management System in Python with Unit Testing 🐾

  * Today, I worked on a project to create a Pet Store Management System in Python, emphasizing the principles of Object-Oriented Programming (OOP) and unit testing. This project involved designing classes for customers, staff, and pets, and implementing a menu-driven interface for interactions. Here's a summary of what I accomplished:

    - **Person Base Class**: Developed an abstract `Person` class to represent a generic person in the system, including attributes for name and ID number. This class also includes an abstract method `get_description` which must be implemented by subclasses.

    - **Customer Class**: Created a `Customer` class that inherits from `Person` and includes methods to adopt pets and retrieve a list of adopted pets. The class also implements the `get_description` method to return customer details.

    - **Staff Class**: Developed a `Staff` class that inherits from `Person` and includes methods to assign pets to staff and retrieve a list of assigned pets. This class also implements the `get_description` method to return staff details.

    - **Pet Class**: Designed a `Pet` class with attributes for name, breed, age, and price. This class includes a method `get_description` to return pet details.

    - **Menu Interface**: Implemented a menu-driven interface that allows users to adopt a pet, display customer details, and display pet details. The interface interacts with the `Customer`, `Staff`, and `Pet` classes to manage the store's operations.

    - **Unit Testing**: Wrote comprehensive unit tests using Python's `unittest` module to verify the functionality of the application. The tests cover:
      - Adding pets to customers and ensuring they are correctly added to the list.
      - Assigning pets to staff and verifying the assignment.
      - Retrieving and verifying descriptions of customers, staff, and pets.

  This project provided an in-depth exercise in applying OOP principles and writing effective unit tests to maintain code quality. It reinforced the importance of encapsulation, inheritance, and abstraction in creating maintainable and scalable code.
* Day 139: Top 20 Play Store App Reviews [Kaggle](https://www.kaggle.com/datasets/odins0n/top-20-play-store-app-reviews-daily-update/data)

  * Today, I worked with the Top 20 Play Store App Reviews dataset from Kaggle, focusing on analyzing review sentiments using the DistilBERT model. Here's a summary of what I accomplished:
    - **Data Loading**: Loaded the dataset using Pandas to get a comprehensive view of the reviews and their scores.
    - **Review Analysis**: 
      - Visualized the distribution of review scores to understand the general sentiment of the reviews.
      - Sampled 200 reviews from the dataset for detailed analysis.
    - **Sentiment Analysis with DistilBERT**:
      - Utilized the DistilBERT model for sentiment analysis. The model was fine-tuned on the SST-2 dataset for sentiment classification.
      - Created a sentiment analysis pipeline using the model and tokenizer.
      - Performed sentiment analysis on the reviews and added the results to the dataset.
    - **Visualization**:
      - Plotted the distribution of sentiments (Positive vs. Negative) to get an overview of the sentiment spread.
    - **Model Evaluation**:
      - Evaluated the model's performance using a confusion matrix and classification report.
      - Compared the sentiment analysis results with the actual review scores to assess the model's accuracy.
    - **Key Insights**:
      - The model achieved an overall accuracy of 85% in predicting sentiments.
      - Highlighted the balance between precision and recall, showing effective performance in classifying both positive and negative reviews.

  This project demonstrates the practical application of pre-trained transformer models in sentiment analysis, emphasizing the importance of data preprocessing, model evaluation, and visualization in deriving meaningful insights from textual data.
* Day 140: 🎮 Memory Game 🎮
  * Today, I created a memory game using Pygame, focusing on building a fun and interactive application that challenges players to find matching pairs of colored cards. Here's a summary of what I accomplished:
    - **Game Setup**: Initialized Pygame and set up the display with a grid of cards.
    - **Card Generation**: 
      - Defined a set of colors and created pairs for the memory game.
      - Shuffled the colors and assigned them to the cards in a grid layout.
    - **Game Logic**: 
      - Implemented the logic for flipping cards and checking for matches.
      - Handled user input to select and flip cards, and checked for matched pairs.
      - Included a mechanism to hide unmatched cards after a short delay.
    - **Graphics and Display**:
      - Drew the cards on the screen, showing either the card back or the front color based on their state.
      - Added text to display a winning message when all pairs are found.
    - **Game Loop**: 
      - Managed the main game loop to handle events, update the game state, and redraw the screen.
      - Ensured the game runs smoothly and responds to user actions.

  This project highlights the use of Pygame for game development, emphasizing the importance of game logic, user interaction, and visual display to create an engaging user experience. The memory game is a great way to practice Pygame and develop skills in interactive application design.
* Day 141: 🧮 EMI Calculator with Tkinter and Matplotlib 📊
  * Today, I developed an EMI (Equated Monthly Installment) Calculator using Tkinter for the GUI and Matplotlib for visualizing the EMI breakdown. This project involved creating a user-friendly interface and implementing the logic for EMI calculation and graphical representation. Here's a summary of what I accomplished:

    - **GUI Setup**:
      - Created the main window using Tkinter and set the title and background color.
      - Registered validation commands to ensure the user inputs are valid.

    - **Input Fields**:
      - Added input fields for total loan amount, loan period (years and months), and interest rate.
      - Used Tkinter's Entry widget for text inputs and Spinbox for selecting years and months.

    - **Calculation Logic**:
      - Implemented the EMI calculation formula to compute the monthly payment.
      - Calculated the total payment, interest amount, and the breakdown of payments over time.

    - **Result Display**:
      - Formatted and displayed the calculation results in a message box.
      - Showed the monthly payment, total EMI period, total amount, interest amount, and total payment.

    - **Graphical Visualization**:
      - Utilized Matplotlib to plot the EMI breakdown over time.
      - Displayed the balance, interest, and principal components month-wise in a line graph.
      - Added titles, labels, legends, and grid to the plot for better readability.

    - **Clear Functionality**:
      - Implemented a clear function to reset all input fields and prepare the form for new input.

    This project demonstrates the integration of Tkinter for building interactive GUI applications and Matplotlib for data visualization. The EMI Calculator is a practical tool for understanding loan repayment schedules and visualizing the impact of different loan parameters.
* Day 142: Technical Test "rotate" and "groupAnagrams" [LeetCode](https://leetcode.com/problems/)
  - **rotate**: This function rotates an `n x n` 2D matrix by 90 degrees clockwise. The solution involves first transposing the matrix (swapping rows and columns) and then reversing each row. [Problem Description: Rotate Image](https://leetcode.com/problems/rotate-image/description/)
  - **groupAnagrams**: This function groups anagrams together from a list of strings. The solution uses a dictionary where the key is the sorted version of the word and the value is the list of words that, when sorted, match the key. [Problem Description: Group Anagrams](https://leetcode.com/problems/group-anagrams/description/)
* Day 143: 🎵 Object-Oriented Programming in Python with Music Subscription System 🎵
  * Today, I worked on a music subscription system project to reinforce the principles of Object-Oriented Programming (OOP) in Python. This project incorporates key OOP concepts such as inheritance, encapsulation, and abstraction. Here's a summary of what I accomplished:
    - **Abstraction and Encapsulation**: Created an abstract base class `Person` to represent common attributes and behaviors for both listeners and artists. Encapsulated the name and ID number attributes to protect them from direct modification. Implemented abstract methods to enforce a consistent interface for subclasses.
    - **Inheritance**: Developed two subclasses, `Listener` and `Artist`, inheriting from the `Person` class. These subclasses extend the base class by adding specific attributes and methods like subscribing to genres and adding songs to the artist's discography.
    - **Song Management**: Created a `Song` class to represent a song, including attributes for the song title, genre, artist, rating, and duration. Added methods to handle song details and categorize songs by genre.
    - **User Interaction**: Implemented a menu-driven interface to allow users to register listeners and artists, subscribe listeners to genres, register songs, display listener details, display song information, and show artist details. This interactive component showcases how OOP can be used to structure complex, real-world applications.
    - **Data Storage**: Used dictionaries to manage and store listener, artist, and song instances, demonstrating the practical use of data structures in conjunction with OOP to handle multiple objects efficiently.

  This project provided a comprehensive exercise in applying OOP principles to a realistic scenario, reinforcing the importance of well-structured, maintainable, and scalable code.
* Day 144: 🌀 Mandelbrot Set Visualization 🌀
  * Today, I delved into the fascinating world of fractals by visualizing the Mandelbrot set using Python. This project involved implementing the mathematical principles behind the Mandelbrot set and generating a beautiful visual representation. Here's a summary of what I accomplished:

    - **Mathematical Foundations**: Implemented the Mandelbrot sequence using a function that iterates a complex number to determine if it belongs to the Mandelbrot set. The function returns the iteration count, which is used to determine the color of each point in the visualization.
    - **Grid Creation**: Generated a grid of complex numbers representing the real and imaginary parts of the Mandelbrot set. Used `numpy` to create linear spaces for the real and imaginary components, and iterated over this grid to compute the Mandelbrot values.
    - **Visualization**: Utilized `matplotlib` to plot the computed Mandelbrot set. Applied a color map to visually represent the iteration count, creating a vivid and intricate fractal image. Added labels and a color bar for better readability.
    - **Code Organization**: Structured the code into functions to improve readability and maintainability. This modular approach ensures that each part of the computation and visualization process is clearly defined and easy to understand.
    - **Inspiration**: Based this project on a tutorial by NeuralNine. You can watch the video here: [NeuralNine YouTube Tutorial](https://www.youtube.com/watch?v=xjjmkg9J7Gg).

  This project provided a deep dive into both mathematical computation and data visualization, reinforcing the importance of combining theoretical concepts with practical implementation.
* Day 145: 🌳 Recursive Tree Animation 🌳
  * Today, I explored the world of recursive graphics by creating an animated visualization of a fractal tree using Python. This project combined recursion with animation to produce a dynamic and captivating visual representation. Here's a summary of what I accomplished:

    - **Recursive Tree Drawing**: Implemented a recursive function to draw a tree. The function calculates the end points of each branch using trigonometric functions and recursively draws smaller branches at specified angles. This method creates the characteristic fractal structure of a tree.
    - **Animation Setup**: Used `matplotlib` and `numpy` to set up the initial figure and axis for the animation. Defined the limits and aspect ratio to ensure the tree is displayed correctly.
    - **Frame Updates**: Created an animation function that updates the tree's depth with each frame, gradually increasing the depth of recursion to animate the growth of the tree. This function clears the previous frame, sets the axis limits, and draws the tree with the current depth.
    - **Creating the Animation**: Utilized `matplotlib.animation.FuncAnimation` to create the animation. Defined the initial and maximum depth, and set the interval between frames to control the animation speed.
    - **Displaying the Animation**: Configured `matplotlib` to display the animation, showcasing the growth of the fractal tree in real-time.

  This project provided an exciting opportunity to delve into recursive algorithms and animation techniques, demonstrating the power of combining mathematical concepts with visual art.
* Day 146: 🏦 ATM Machine Simulation 🏦
  * Today, I ventured into the realm of GUI programming by creating an ATM machine simulation using Python and Tkinter. This project involved developing a user-friendly interface that mimics the functionalities of a real ATM, providing an interactive experience for users. Here's a summary of what I accomplished:

    - **GUI Design**: Designed the main application window with Tkinter, setting up the initial balance and PIN. Configured the window to be non-resizable and applied a consistent color scheme for a professional look.
    - **PIN Validation**: Implemented a PIN entry system to authenticate users. The application verifies the entered PIN and provides appropriate feedback using message boxes.
    - **ATM Menu**: Created a menu with options to check balance, deposit money, withdraw money, and exit. Each menu option is linked to its corresponding function, ensuring smooth navigation.
    - **Balance Check**: Developed a function to display the current balance in a message box.
    - **Deposit Money**: Added functionality to allow users to deposit money into their account. Implemented input validation to ensure the deposited amount is a positive number.
    - **Withdraw Money**: Enabled users to withdraw money, with validation to check for sufficient balance and ensure the withdrawn amount is positive.
    - **Code Organization**: Structured the code into functions and classes to enhance readability and maintainability. This modular approach ensures that each part of the application is clearly defined and easy to understand.

  This project provided valuable insights into GUI development and user interaction, demonstrating the importance of creating intuitive and functional interfaces.
* Day 147: Technical Test "myPow" and "NQueens" [LeetCode](https://leetcode.com/problems/)
  - **myPow**: Implemented a function that calculates \( x^n \) (x raised to the power n) efficiently. This problem involves optimizing the power calculation by leveraging recursion and handling edge cases such as negative powers. [Problem Description: myPow](https://leetcode.com/problems/powx-n/description/)
  - **NQueens**: Solved the N-Queens problem, which involves placing n queens on an n x n chessboard so that no two queens attack each other. The solution uses backtracking to explore all possible placements and returns all distinct configurations. [Problem Description: NQueens](https://leetcode.com/problems/n-queens/description/)
* Day 148: 🎮 Video Game Subscription System in Python 🎮

  * Today, I expanded my understanding of Object-Oriented Programming (OOP) by developing a Video Game Subscription System using Python. This project leverages fundamental OOP principles such as inheritance, encapsulation, and abstraction. Here’s a summary of the key elements:

    - **Abstraction and Encapsulation**: Defined an abstract base class `Person` representing common features for both `Player` and `Developer`. Encapsulated attributes like name and ID number to ensure data integrity. The abstract method `get_description` enforces a consistent interface for subclasses.
    - **Inheritance**: Created two subclasses, `Player` and `Developer`, that inherit from `Person`. These subclasses add specific attributes and methods, such as subscribing to game genres for `Player` and adding games to a portfolio for `Developer`.
    - **Game Management**: Introduced a `Game` class to represent individual games, including details such as title, genre, developer, rating, and release year. Methods within this class manage game-related information and allow interaction with player and developer objects.
    - **User Interaction**: Built a menu-driven interface allowing users to register players and developers, add new games, subscribe players to game genres, and display details for players, games, and developers. This interactive component illustrates the practical application of OOP in creating user-friendly software systems.
    - **Data Organization**: Employed dictionaries to efficiently manage and store instances of players, developers, and games. This approach highlights the integration of OOP and data structures to handle complex, real-world data scenarios.

  This project provided an engaging and insightful exercise in implementing OOP principles to simulate a real-world application, reinforcing the importance of design patterns and code maintainability.
* Day 149: 🧩 Wordle Game with Flask and CSS 🖥️

  * Today, I worked on developing a Wordle-inspired game using Flask for the backend and custom CSS for styling. This project integrates web development skills with game logic to create an interactive user experience. Here’s a summary of the key components:

    - **Flask Application**: Implemented a Flask application to handle game logic, including word selection, guess validation, and feedback management. Used session variables to track game state, including the target word, attempts, and game status.
    - **Word Management**: Loaded a list of possible words from a text file and used it to randomly select a word for each game session. Validated player guesses against this word and provided feedback on correctness, presence, or absence of letters.
    - **User Interface**: Designed a user-friendly interface using HTML and CSS, featuring forms for guess input, feedback display, and game status updates. The interface also includes a responsive design to ensure compatibility across different devices.
    - **Feedback System**: Incorporated a feedback mechanism to visually represent the correctness of each guessed letter, including color-coded indicators for correct, present, and absent letters.
    - **Game Flow Control**: Managed game flow with options to restart the game or handle game-over scenarios, providing an engaging experience with clear instructions and error handling.

  This project allowed me to apply web development and design skills in a practical context, creating an enjoyable and visually appealing game experience.

* Day 150: 🧠 Brain Tumor Dataset 🧠 Analysis [Kaggle](https://www.kaggle.com/datasets/odins0n/brain-tumor-dataset)

  * Today, I worked with the Brain Tumor dataset from Kaggle, focusing on exploring various aspects of the data and performing detailed analyses. Here's a summary of what I accomplished:
    - **Data Loading**: Loaded the dataset using Pandas, and explored the initial structure of the data.
    - **Data Cleaning**:
      - Renamed columns for consistency and easier access.
      - Checked for and handled missing data, ensuring the dataset was ready for analysis.
    - **Exploratory Data Analysis (EDA)**:
      - **Categorical Features**: 
        - Created count plots for features like Tumor Type, Location, and Gender to visualize their distributions.
        - Analyzed the correlation between Tumor Location and Grade using a heatmap.
      - **Numerical Features**:
        - Generated correlation heatmaps to understand relationships between numeric features like Age and Tumor Size.
        - Visualized the distribution of Tumor Grade by Age and Gender, and Tumor Size by Type and Grade.
      - **Outlier Detection**:
        - Used boxplots to detect outliers in Age and Tumor Size, identifying specific data points for further investigation.
    - **Principal Component Analysis (PCA)**:
      - Applied PCA to reduce dimensionality, focusing on numeric features like Age and Size.
      - Visualized the resulting principal components to explore potential clustering by Tumor Type.
    - **Feature Engineering**:
      - Grouped Age into categories to simplify analysis.
      - Created a binary feature indicating whether a tumor was in a critical location.
    - **Automated Report**:
      - Developed functions to generate a statistical summary, distribution graphs, and correlation analysis for both numerical and categorical variables.
      - Automated the generation of visual and textual insights from the dataset.

  * This work provided valuable insights into the distribution and relationships within the dataset, which could be crucial for understanding and predicting outcomes related to brain tumors. The automated report functions developed can also be reused for similar datasets in future projects.
* Day 151: 🏗️ Tower of Babel - Recursive Algorithm 🏗️

  * Today, I implemented and explored the Tower of Babel problem, a variation of the classic Tower of Hanoi, using a recursive algorithm. This project focused on moving blocks from one position to another following specific rules. Here's a summary of what I accomplished:
    - **Recursive Function Design**:
      - Developed a recursive function `build_tower` that moves blocks between positions to simulate the construction of a tower.
      - The base case handles the movement of a single block, while the recursive case manages the movement of multiple blocks.
    - **Block Movement Logic**:
      - Implemented the `move_block` function to transfer blocks between positions, ensuring that each move is printed to the console for clarity.
    - **Initial and Final Tower States**:
      - Initialized the tower with a specific number of blocks in one position.
      - The recursive process successfully moved all blocks to the target position, maintaining the rules of the problem.
    - **Visualization and Debugging**:
      - Provided clear output of the tower's state before and after the recursive process, aiding in debugging and understanding the algorithm's flow.
      - Used print statements to trace each block movement, making it easier to follow the recursive calls.

  * This exercise was a great opportunity to reinforce my understanding of recursion, particularly in solving problems that involve multiple recursive calls and complex state management. The Tower of Babel problem also highlights the importance of clear base cases and recursive steps in algorithm design.
* Day 152: Technical Test "totalNQueens" and "maxSubArray" [LeetCode](https://leetcode.com/problems/)
  - **totalNQueens**: Implemented a solution to the N-Queens II problem, which involves counting the number of distinct solutions for placing n queens on an n x n chessboard so that no two queens attack each other. The solution uses backtracking to explore all valid placements and utilizes arrays to track columns and diagonals that are under attack. The efficient marking and unmarking of attacked positions allow the algorithm to explore all configurations systematically. [Problem Description: totalNQueens](https://leetcode.com/problems/n-queens-ii/description/)

  - **maxSubArray**: Solved the Maximum Subarray problem, where the goal is to find the contiguous subarray within a one-dimensional numeric array that has the largest sum. The solution employs a dynamic programming approach, where the maximum sum is updated as the algorithm iterates through the array, considering each element either as a standalone subarray or as an extension of the previous subarray. This approach ensures an optimal solution with a time complexity of O(n). [Problem Description: maxSubArray](https://leetcode.com/problems/maximum-subarray/description/)
* Day 153: 🎮 Rock Paper Scissor Game with Tkinter 🎮

  * Today, I developed a Rock Paper Scissor game using Python's Tkinter library. The game allows the player to select between Rock, Paper, or Scissors, while the computer randomly selects its move. Here’s a summary of the key components of this project:
    - **Graphical User Interface (GUI) Design**:
      - Created an intuitive and user-friendly interface with buttons for the player's choices, as well as labels for displaying the results.
      - Utilized Tkinter widgets such as `Label`, `Button`, and `Frame` to organize the layout and display game elements.
    - **Game Logic Implementation**:
      - Implemented the game logic for Rock, Paper, Scissors, where the player’s choice is compared with the computer’s random selection.
      - Handled different outcomes such as "Player Wins", "Computer Wins", or "Match Draw" based on the rules of the game.
    - **Reset and State Management**:
      - Added a reset button to allow players to restart the game without closing the application.
      - Disabled buttons after each round to prevent multiple choices in a single game, ensuring a fair gameplay experience.
    - **Random Computer Selection**:
      - Used Python's `random` library to simulate the computer's choice, making the game unpredictable and engaging.

  * This project was a great way to practice my skills in building GUI applications with Tkinter, as well as implementing simple game mechanics in Python. It reinforced concepts such as event handling, state management, and the importance of a well-structured user interface.
* Day 154: 🏥 Medical Appointment System in Python 🩺

  * Today, I developed a Medical Appointment System using Python, implementing Object-Oriented Programming (OOP) principles such as inheritance, encapsulation, and abstraction. This project focuses on managing patients, doctors, and appointments in an organized and scalable manner. Here's a summary of the key features:

    - **Abstraction and Encapsulation**: Defined an abstract base class `Person` to represent common attributes for both `Patient` and `Doctor`, ensuring a consistent interface through the abstract method `get_description`. Encapsulated sensitive data like name and ID number to protect the integrity of the information.
    - **Inheritance**: Created two subclasses, `Patient` and `Doctor`, that extend the functionality of the `Person` class. The `Patient` class manages patient-specific data like age and appointments, while the `Doctor` class tracks the doctor's specialty and assigned patients.
    - **Appointment Scheduling**: Introduced an `Appointment` class to manage the scheduling of appointments between patients and doctors, storing details like date, time, and reason for the visit. This class ties together both patient and doctor information, ensuring smooth coordination.
    - **Menu-Driven Interaction**: Built a user-friendly interface that allows the registration of new patients and doctors, scheduling of appointments, and viewing detailed information about patients and doctors. This menu system showcases the integration of OOP with real-world applications.
    - **Data Management**: Used dictionaries to organize and store instances of patients and doctors efficiently. This approach facilitates quick access and updates to patient and doctor records, demonstrating the importance of effective data structures in software systems.

  This project was a great opportunity to practice implementing OOP concepts in a practical scenario, creating a robust system for managing medical appointments. It deepened my understanding of how OOP principles can streamline the organization of complex data and processes.
* Day 155: 🎬 Movie Ratings Analysis with PySpark and Seaborn 🎥 [Dataset](https://grouplens.org/datasets/rating-disposition-2023/)

  * Today, I worked on a data analysis project focused on movie ratings using PySpark for distributed data processing and Seaborn for visualizations. The project involved cleaning, processing, and analyzing a dataset of movie ratings to uncover trends and insights. Here's a breakdown of the key features:

    - **Data Processing with PySpark**: Utilized PySpark to handle a large dataset of movie ratings, allowing efficient computation on big data. I loaded the data into a DataFrame, filtered, and aggregated it using PySpark’s powerful functions like `groupBy`, `agg`, and `filter` to analyze ratings per movie and user.
    - **Average Rating Calculation**: Calculated the average rating for each movie and determined the number of ratings each movie received. This information was crucial for identifying popular movies and trends in user preferences.
    - **User Activity Analysis**: Analyzed user behavior by calculating the average rating given by each user and identifying the most active users, showcasing how PySpark can be used to extract valuable insights from large datasets.
    - **Visualization with Seaborn**: Converted the PySpark DataFrame to a pandas DataFrame and used Seaborn to create a bar chart representing the distribution of ratings across movies. This visual representation helped highlight the most common rating values and their occurrences.
    - **Interactive Data Exploration**: Implemented a menu-driven interface allowing exploration of the data, including displaying top-rated movies, most active users, and the distribution of ratings. This approach ties together both data processing and visualization in a cohesive project.

  This project was a great opportunity to dive deeper into big data processing with PySpark, as well as exploring data visualization techniques with Seaborn. It enhanced my ability to work with large datasets and transform them into meaningful insights, while reinforcing the importance of visualizations in data analysis.
* Day 156: 🗒️ To-Do List Application with Flet 📝

  * Today, I created a To-Do List application using Flet, a modern framework for building interactive web applications in Python. This project was a fantastic exercise in using Flet to manage user input, display dynamic content, and handle interactive events. Here's a summary of the key features:

    - **User Interface Design**: Designed a clean and user-friendly interface with a centered layout. The application features a title, input field, and button for adding tasks, along with a dynamically updated list of tasks.
    - **Task Management**: Implemented functionality to add new tasks to the list and display them with checkboxes. Tasks are displayed in a list view, allowing users to see and manage their to-dos easily.
    - **Interactive Elements**: Incorporated interactive elements such as a `TextField` for task input and a `FilledButton` to add tasks. Added checkboxes next to each task to allow users to mark tasks as completed.
    - **Dynamic Updates**: Created functions to update the task list and display selected tasks based on user interactions. The list updates in real-time to reflect new tasks and changes in task selection.
    - **Data Handling**: Used a list to manage and store tasks, and updated the displayed list dynamically. The application tracks which tasks are selected and updates the display accordingly.

  This project was an excellent opportunity to explore Flet's capabilities in building interactive web applications and to apply concepts of UI design and event handling in a practical context.
* Day 157: Technical Test "spiralOrder" and "canJump" [LeetCode](https://leetcode.com/problems/)

  - **spiralOrder**: Solved the Spiral Matrix problem, where the task is to traverse a 2D matrix in spiral order and return the elements in the order they are visited. The algorithm follows a structured approach by traversing the matrix in four directions (right, down, left, up) while adjusting the boundaries (top, bottom, left, right) as the spiral tightens. This method ensures that each element is visited exactly once. The solution has a time complexity of O(m * n), where m and n are the dimensions of the matrix. [Problem Description: Spiral Order](https://leetcode.com/problems/spiral-matrix/description/)

  - **canJump**: Implemented a solution for the Jump Game problem, which asks whether it is possible to reach the last index of an array given that each element represents the maximum jump length from that position. The algorithm utilizes a greedy approach to track the farthest reachable index as it iterates through the array. If at any point the current index is beyond the farthest reachable index, the function returns `False`. Otherwise, it returns `True` if the last index is reachable. This solution operates in linear time with a time complexity of O(n). [Problem Description: Can Jump](https://leetcode.com/problems/jump-game/description/)
* Day 158: 🖌️ Floodfill Image Color Changer with Tkinter 🖌️

  * Today, I created a graphical application in Python using Tkinter that allows users to apply a floodfill operation to an image. The application provides a simple interface for loading an image, selecting a color, and applying the floodfill to change the color of a specific region. Here’s a summary of the key components of this project:
    - **Image Loading and Display**:
      - Implemented a file dialog to allow users to select an image from their system. The selected image is then displayed on a Tkinter canvas.
      - Utilized the PIL (Python Imaging Library) to handle image loading and conversion to the RGB format, ensuring compatibility with various image types.
    - **Floodfill Operation**:
      - Added a floodfill feature where the user can choose a color using a color chooser dialog, and apply it to a specific pixel on the image.
      - The floodfill algorithm fills all connected pixels with the chosen color, making it easy to change the appearance of large areas within the image.
    - **Saving the Modified Image**:
      - Integrated a save dialog that allows users to save the modified image in their desired format (PNG, JPEG, etc.).
      - Ensured that the application handles any errors during the save process, providing user feedback through message boxes.
    - **User Interface**:
      - Designed a clean and intuitive user interface with buttons for loading, applying floodfill, and saving the image. The interface is styled with colors and fonts to enhance the user experience.
    - **Error Handling**:
      - Included comprehensive error handling to manage issues like unsupported image formats, out-of-bound pixel selections, and file save errors, ensuring a robust application.

  * This project was an excellent exercise in working with images and enhancing my skills in Tkinter and PIL. It allowed me to delve deeper into image processing techniques and GUI development in Python.
* Day 159: 🏠 Real Estate Data Visualization with Folium 🗺️

  * Today, I worked on a project that visualizes real estate data using Folium, a powerful Python library for creating interactive maps. The project was inspired by a [NeuralNine](https://www.youtube.com/watch?v=5UQyxgiQAzk) video, which provided a great foundation for this type of data visualization. Here’s a summary of the key components of this project:
  
    - **Data Handling**:
      - Utilized the California Housing dataset provided by Scikit-Learn to analyze various features such as median house value, average number of rooms, and population.
      - Converted the dataset into a Pandas DataFrame for easy manipulation and analysis.

    - **Map Initialization**:
      - Created an interactive map centered on the average latitude and longitude of the data points.
      - Used Folium to set up the base map with a zoom level appropriate for visualizing the entire California region.

    - **Marker Creation**:
      - Iterated through each row of the dataset to add circle markers on the map, with each marker representing a location in the dataset.
      - Adjusted the size of the markers based on the normalized average number of rooms, providing a visual indication of housing density.
      - Applied a color gradient to the markers based on the median house value, allowing for quick visual identification of high-value areas.

    - **Popup Information**:
      - Added detailed popups to each marker, displaying information such as median house value, average rooms, population, and median income.
      - Ensured the popups are clear and informative, making the map not only visually appealing but also data-rich.

    - **Additional Features**:
      - Integrated a minimap plugin for better navigation and spatial context, enhancing the user’s ability to explore different regions.
      - Saved the final interactive map as an HTML file, making it easy to share and view on any web browser.

  * This project was a great exercise in combining data science with geographic visualization. It allowed me to deepen my understanding of how to represent complex datasets in a user-friendly manner using Python and Folium. Special thanks to NeuralNine for the inspiration!
* Day 160: Top 1000 Global Tech Companies Dataset (2024) [Kaggle](https://www.kaggle.com/datasets/muhammadehsan000/top-1000-global-tech-companies-dataset-2024/code)

  * Today, I explored the Top 1000 Global Tech Companies dataset from Kaggle, focusing on data analysis and visualization. Below is a summary of the key activities and findings:
  
    - **Data Loading**: 
      - Loaded the dataset using Pandas and inspected the initial data structure.
  
    - **Data Cleaning**:
      - Renamed the "Market Cap" column to "Market_Cap" for easier access and consistency.
      - Checked for and identified any missing data within the dataset.
  
    - **Exploratory Data Analysis (EDA)**:
      - **Categorical Features**:
        - Created count plots for the "Country," "Sector," and "Industry" features to visualize their distributions.
        - Analyzed the distribution of industries across different countries using a heatmap.
        - Focused on the top 10 industries to further analyze their distribution by country.
      - **Numerical Features**:
        - Visualized the distribution of company rankings within the dataset.
        - Examined the top 10 companies by market capitalization, converting the values to billions for clarity.
      - **Country Distribution**:
        - Analyzed the distribution of companies by country, identifying the top 10 countries by the number of companies.
  
    - **Automated Reporting**:
      - Developed functions to automate the generation of statistical summaries, distribution graphs, and correlation analyses for both numerical and categorical variables.
      - These functions facilitate rapid insights and visualizations for future projects involving similar datasets.

  * This analysis provided a comprehensive understanding of the distribution of tech companies globally, with insights into key industries and market leaders. The automated report generation process developed can be applied to future datasets for efficient and consistent analysis.
* Day 161: 🏨 Hotel Reservation System in Python 🏢

  Today, I developed a Hotel Reservation System using Python, focusing on Object-Oriented Programming (OOP) principles such as inheritance, encapsulation, and abstraction. This project is designed to manage guests, rooms, and reservations in a streamlined and efficient manner. Here's a summary of the key features:

  - **Encapsulation**: The `Person` class encapsulates the attributes `name` and `ID number`, making them private to protect data integrity. Getter methods are provided to access these attributes safely.
    
  - **Inheritance**: The `Guest` class inherits from the abstract base class `Person`, which defines common attributes for all persons in the system. This ensures code reusability and consistency.

  - **Abstraction**: The `Person` class includes an abstract method `get_description`, which is implemented by the `Guest` class to provide a detailed description of the guest. This enforces a consistent interface across different types of persons in the system.

  - **Room Management**: The `Room` class manages the details of each room, such as the number of beds, baths, food service, and entertainment availability. It also tracks the guests assigned to each room.

  - **Reservation System**: The `Reservation` class ties together the guest and room information, storing details such as check-in and check-out dates. Guests can have multiple reservations, and rooms can accommodate multiple guests.

  - **User Interaction**: A menu-driven interface allows users to register new guests and rooms, make reservations, and view detailed information about guests and rooms. This interface demonstrates the practical application of OOP principles in a real-world scenario.

  - **Data Organization**: Dictionaries are used to store and manage instances of guests and rooms, providing efficient access and updates to the data.

  This project was an excellent opportunity to apply OOP concepts in creating a functional and user-friendly hotel reservation system. It reinforced my understanding of how abstraction, inheritance, and encapsulation can be used to build organized and scalable software solutions.
* Day 162: 🌀 Gray Code Generator - Recursive Algorithm 🌀

  * Today, I explored and implemented a Gray Code Generator using a recursive algorithm in Python. Gray codes are binary sequences where two successive values differ in only one bit, making them useful in error correction, digital communications, and other fields. Here's a summary of what I accomplished:
    - **Recursive Generation of Gray Codes**:
      - Developed the function `generateGrayarr(n)` to generate all possible n-bit Gray codes.
      - Utilized recursion to progressively build the Gray code sequences, starting with the base patterns "0" and "1".
    - **Base Case Handling**:
      - Established a base case that handles scenarios where `n` is 0 or negative, ensuring no Gray codes are generated when `n` is invalid.
    - **Efficient Code Generation**:
      - Implemented a loop to iteratively generate 2^n Gray codes by appending previously generated codes in reverse order.
      - Prefixed "0" to the first half and "1" to the second half of the Gray codes during each iteration, effectively doubling the number of codes.
    - **Binary Manipulation**:
      - Utilized bitwise operations (`<<` and `1 << n`) to manage and generate the appropriate number of codes efficiently.
    - **Output Display**:
      - Printed all generated n-bit Gray codes, providing a clear representation of the output for a 5-bit Gray code sequence.

  * This project provided a solid exercise in recursion, bitwise operations, and efficient algorithm design. The Gray Code Generator is a powerful tool in various computational applications, and implementing it was a great way to deepen my understanding of recursive sequences and binary operations.

* Day 163: Technical Test "merge_intervals" and "insert_intervals" [LeetCode](https://leetcode.com/problems/)

  - **merge_intervals**: Developed a solution for the Merge Intervals problem, where the goal is to merge all overlapping intervals in a given list of intervals. The algorithm starts by sorting the intervals based on their starting times. It then iterates through the sorted list, merging intervals that overlap by adjusting the end time of the current interval. If no overlap is found, the current interval is added to the list of merged intervals. This approach ensures that all overlapping intervals are merged efficiently. The solution has a time complexity of O(n log n) due to the initial sorting step, where n is the number of intervals. [Problem Description: Merge Intervals](https://leetcode.com/problems/merge-intervals/description/)

  - **insert_intervals**: Solved the Insert Interval problem, where the task is to insert a new interval into an existing list of non-overlapping intervals and merge if necessary. The solution involves three main steps: adding all intervals that come before the new interval, merging the new interval with any overlapping intervals, and then adding the remaining intervals that come after. This method ensures that the intervals remain sorted and non-overlapping after insertion. The algorithm has a time complexity of O(n), where n is the number of intervals in the list. [Problem Description: Insert Interval](https://leetcode.com/problems/insert-interval/description/)
* Day 164: 🧮 BMI Calculator with Tkinter and Matplotlib 📊

  * Today, I developed a Body Mass Index (BMI) calculator using Python, Tkinter, and Matplotlib. The application not only calculates BMI based on user input but also provides health recommendations and visualizes BMI and weight trends. Here’s a breakdown of the key features of this project:
    - **BMI Calculation**:
      - Implemented a function to calculate BMI from the user's weight and height, converting height from centimeters to meters for accurate results.
      - Displayed the BMI result in the interface along with a personalized health recommendation based on the calculated BMI.
    - **Dynamic Interface**:
      - Enhanced the user experience by changing the background color of the interface based on the BMI category (e.g., underweight, normal weight, overweight, obese).
      - Added the ability to reset input fields and clear the results, making the application user-friendly and intuitive.
    - **Calculation History**:
      - Implemented a history feature that keeps track of the last five BMI calculations, displaying them in a list within the application.
      - Provided options to save and load the calculation history to/from a JSON file, ensuring data persistence and allowing users to track their BMI over time.
    - **Graphical Visualization**:
      - Used Matplotlib to create and display graphs that show the evolution of BMI and weight over time, giving users a clear visual representation of their progress.
      - Incorporated interactive elements in the Tkinter interface to seamlessly integrate the graphs with the rest of the application.
    - **Error Handling**:
      - Included robust error handling to manage invalid inputs, such as non-numeric values, ensuring the application operates smoothly and provides helpful feedback to users.

  * This project was a great way to practice integrating graphical elements with data processing in Python. It allowed me to enhance my skills in both Tkinter and Matplotlib, creating a functional and visually appealing health tool.
* Day 165: 🗂️ File Manager Pro with Python 🖥️

  - Today, I developed a File Manager system in Python that enables users to efficiently manage their files and folders. This application allows for creating, finding, listing, and deleting files or folders while also calculating the total size of all files in a directory. Below are the key features and components of this project:

    - **File and Folder Creation**:
      - Implemented functionality to create new files with specified names, extensions, and sizes. The system also supports the creation of folders within the base directory.
      - Ensured that the necessary directories are created automatically if they don't exist before a file is generated.

    - **Search Functionality**:
      - Developed a search feature to locate the path of a specific file or folder within the base directory. The system recursively searches through all subdirectories to find the desired item.

    - **Listing Contents**:
      - Created a method to list all files and folders within a given directory, providing an easy overview of the contents.

    - **Size Calculation**:
      - Added the ability to calculate the total size of all files within the base directory, summing up the sizes of individual files to give an accurate total.

    - **File Deletion by Extension**:
      - Included a feature to delete all files with a specified extension across the entire directory structure, helping in bulk file management.

    - **Interactive Command-Line Interface**:
      - Built a user-friendly menu that allows users to interact with the system through various options, such as creating files, listing contents, and deleting files.

    This project provided an excellent opportunity to delve into file management operations using Python’s `os` library. It helped me strengthen my understanding of directory traversal, file handling, and creating user-friendly command-line interfaces.
* Day 166: 🥤 Soda Combinations Generator - Recursive Algorithm 🥤

  * Today, I developed a Python program to generate all possible combinations of a list of sodas using recursion. This project focused on understanding and implementing recursive algorithms to explore all subsets of a given set. Here’s what I achieved:
  
    - **Recursive Generation of Combinations**:
      - Created the function `soda_combinations(sodas, current_combo=[], index=0)` to recursively generate and print all possible combinations of sodas.
      - Implemented two recursive cases: one to include the current soda in the combination and another to exclude it, ensuring all subsets are covered.
    
    - **Base Case Handling**:
      - The base case handles scenarios where all sodas have been considered (`index == len(sodas)`). When this condition is met, the current combination is printed, representing one possible subset.
    
    - **Exploring All Possibilities**:
      - The algorithm explores every combination, from no sodas to the full list, by either including or excluding each soda in the list. This approach ensures that all possible combinations are generated and displayed.
    
    - **Output Display**:
      - Each combination is printed as it is generated, providing a clear and immediate representation of all subsets of the soda list.

  * This project was a great exercise in recursive thinking and subset generation. The ability to systematically explore all possible combinations is a fundamental technique in combinatorial problems, and this implementation deepened my understanding of recursive algorithms in Python.
* Day 167: Technical Test "lengthOfLastWord" and "generateMatrix" [LeetCode](https://leetcode.com/problems/)

  - **lengthOfLastWord**: Implemented a solution for the "Length of Last Word" problem, where the goal is to find the length of the last word in a given string. The algorithm trims any trailing spaces from the string and then finds the index of the last space to determine the length of the last word. The solution efficiently handles different cases, including strings with multiple spaces and empty strings. This method has a time complexity of O(n), where n is the length of the string. [Problem Description: length Of Last Word](https://leetcode.com/problems/length-of-last-word/description/)

  - **generateMatrix**: Solved the "Spiral Matrix II" problem, which involves generating an n x n matrix filled with elements from 1 to n² in a spiral order. The solution uses a systematic approach to fill the matrix by defining boundaries (left, right, top, bottom) and progressively moving inward while filling the matrix. This ensures that the matrix is filled correctly in spiral order. The algorithm has a time complexity of O(n²), where n is the dimension of the matrix. [Problem Description: generate Matrix](https://leetcode.com/problems/spiral-matrix-ii/description/)
* Day 168: Compound Interest Calculator in Python by [NeuralNine](https://www.youtube.com/watch?v=OqCqFfLfFsk)

  * Today, I worked on a project that implements a Compound Interest Calculator using Python and Flask, inspired by a [NeuralNine](https://www.youtube.com/watch?v=OqCqFfLfFsk) tutorial. Here's a breakdown of the key components and features of the project:

    - **User Interface**:
      - Built a simple and user-friendly web interface using HTML and Flask, allowing users to input initial deposit, interest rate, contribution amount, compounding type, and time period in years.
      - Integrated form handling in Flask to process the user input and display the calculated results.

    - **Compound Interest Calculation**:
      - Implemented the compound interest formula to calculate the final amount, considering both the initial deposit and regular contributions over time.
      - Allowed users to choose between monthly and annual compounding, affecting the frequency of interest application.

    - **Visualization**:
      - Used Matplotlib to generate a line graph comparing the growth of the investment with and without interest over the specified time period.
      - Embedded the graph directly in the web page, providing a visual representation of the investment’s growth.

    - **Results Display**:
      - Displayed the final amount with interest and the difference compared to the total contributions without interest.
      - Provided a clear comparison of how much the investment grows due to compound interest.

    - **Technical Implementation**:
      - Utilized Python for back-end calculations and Matplotlib for data visualization.
      - Designed the front-end using HTML, with integration into the Flask framework for dynamic content rendering.

  * This project was a fantastic opportunity to apply mathematical concepts to a real-world financial application, and to further my skills in web development using Flask. The ability to visualize the results added an extra layer of insight into the power of compound interest, making the project both educational and practical.
* Day 169: 🌱 Plant Management System for "La Planta Feliz" Nursery 🌿

  Today, I developed a Plant Management System using Python to help "La Planta Feliz" nursery efficiently manage their inventory of plants. This project focused on leveraging Object-Oriented Programming (OOP) principles to create a flexible and user-friendly system. Here’s a breakdown of the key features:

  - **Plant Creation**: The `Plant` class was designed to represent each plant in the nursery, encapsulating details such as the plant’s code, name, size, species, and price. This structured approach makes it easy to manage and manipulate plant data.

  - **Handling Tall Plants**: I implemented a method in the `Nursery` class to generate a sublist of plants taller than 2 meters. This feature allows the nursery to quickly identify and manage plants that may require special care or different pricing due to their size.

  - **Removing Plants by Name**: The system includes functionality to remove all plants with a specified name. This is particularly useful for managing inventory when certain plants are discontinued or need to be cleared from stock.

  - **Species Counting**: Another key feature is the ability to count the number of plants of a specific species. This helps in understanding the diversity of the nursery’s inventory and making informed decisions about species-specific care or sales strategies.

  - **User Interaction**: The system is designed with a simple interface that allows users to add new plants, filter plants by size, remove plants by name, and count plants by species. This demonstrates the practical application of OOP principles in managing real-world data.

  - **Data Management**: All plant data is managed using lists and list comprehensions, ensuring efficient storage and retrieval of information. This approach facilitates scalability as the nursery's inventory grows.

  This project was an insightful experience in applying OOP concepts to create a functional and efficient system for managing plant inventory. It reinforced my understanding of how encapsulation and data handling can be effectively used in software development to meet specific business needs.
* Day 170: 🍕🍽️ Pizza Restaurant Sales [Kaggle](https://www.kaggle.com/datasets/shilongzhuang/pizza-sales/data)

  * Today, I delved into the Pizza Restaurant Sales dataset from Kaggle, focusing on data analysis and visualization. Below is a summary of the key activities and findings:

    - **Data Loading**:
      - Loaded the dataset using Pandas and examined the initial data structure to understand its composition.
  
    - **Data Cleaning**:
      - Checked for missing values and verified the integrity of the data.
      - Converted `order_time` to a string type and extracted hour, minute, and second for further analysis.
  
    - **Exploratory Data Analysis (EDA)**:
      - **Categorical Features**:
        - Created count plots for the `pizza_size`, `pizza_category`, and `pizza_name` features to visualize their distributions.
        - Analyzed the distribution of pizza sizes and categories using pie charts.
        - Examined the frequency of orders by hour and day of the week, along with monthly trends.
      - **Numerical Features**:
        - Analyzed total price distributions by pizza name and size using box plots and sunburst charts.
        - Visualized the median prices by pizza size and category using a treemap.
      - **Time Series Analysis**:
        - Investigated order frequencies across different hours of the day and days of the week.
        - Created visualizations to show how order distributions vary by date and hour.
  
    - **Advanced Visualizations**:
      - Generated interactive plots using Plotly, including bar charts for order distributions and sunburst plots for price distributions.
      - Used seaborn and Matplotlib for detailed count plots and box plots, enhancing visual insights.
  
  * This analysis provided a detailed view of the pizza sales data, including insights into order trends, pizza categories, and pricing. The generated visualizations offer a comprehensive understanding of the sales dynamics, aiding in decision-making and strategy formulation for the restaurant.
* Day 171: 🔍 Partitioning a List into Two Equal Subsets - Recursive Algorithm 🔍

  * Today, I developed a Python program to determine if a given list of integers can be partitioned into two subsets with equal sum using recursion. This project focused on implementing recursive techniques to explore the possibility of such a partition. Below is a summary of the key tasks and insights:

    - **Understanding the Problem**:
      - The goal was to check if a list can be split into two subsets with an equal sum, a common problem in dynamic programming and recursion.

    - **Recursive Approach**:
      - Implemented the `can_partition_recursive(nums, target_sum, index, subset)` function, which uses recursion to explore whether a subset with a target sum can be found within the list.
      - The function considers two main scenarios: excluding the current number from the subset and including it, then recursively checks the remaining elements.

    - **Base Case Handling**:
      - The base cases include situations where the target sum becomes zero (indicating a successful partition) or when all elements are considered, and the target sum remains unmet.

    - **Exploring Subsets**:
      - By exploring all possible combinations of the list’s elements, the algorithm identifies whether a valid subset exists that equals half the total sum, thus confirming if the list can be partitioned into two equal subsets.

    - **Output and Visualization**:
      - If a valid partition is found, the program outputs the subsets, providing a clear visual representation of the solution.

  * This project reinforced key concepts in recursive problem-solving and subset exploration, offering a deeper understanding of how to approach partitioning problems with Python. The recursive approach not only highlights the power of recursion in combinatorial problems but also emphasizes the importance of base case management and backtracking in algorithm design.
* Day 172: 🏀 Basketball Player Statistics Generator with Python 📊

  * Today, I developed a Python program that allows users to input basic basketball statistics for a player (points, rebounds, assists) and calculates key metrics such as averages per game, shooting percentages, and more. This project provided an excellent opportunity to work with object-oriented programming and data visualization. Below is a summary of the key tasks and insights:

    - **Understanding the Problem**:
      - The goal was to create a system where users can input game statistics for basketball players and easily calculate and visualize key metrics, such as points per game, rebounds per game, assists per game, and shooting percentages.

    - **Class-Based Approach**:
      - Implemented the `BasketballPlayer` class, which tracks a player's game statistics, calculates averages, and computes shooting percentages. The class structure allowed for a clean and modular design, making it easy to manage and update player stats.

    - **Data Input and Handling**:
      - The program features a menu-driven interface that allows users to create players, select existing players, and input game statistics. This interactive approach ensures that the program is user-friendly and can handle multiple players seamlessly.

    - **Statistics Calculation**:
      - The `calculate_averages` method computes the player's averages per game for points, rebounds, and assists, while the `calculate_shooting_percentage` method determines the shooting accuracy based on the shots made and attempted. These calculations are crucial for analyzing player performance.

    - **Data Visualization**:
      - The `plot_stats` method uses Matplotlib to generate bar charts that visually represent the player's statistics. This feature enhances the program by providing a graphical interpretation of the data, making it easier to identify trends and performance levels.

  * This project reinforced my understanding of object-oriented programming, particularly in the context of sports statistics. The integration of data visualization added an extra layer of insight, demonstrating the value of combining algorithmic calculations with graphical outputs. I'm excited to explore further enhancements, such as incorporating advanced metrics and player comparisons.
* Day 173: 🎵 Discord Music Bot with Python and discord.py 🎶

  * Today, I developed a Discord music bot using Python, `discord.py`, and `yt-dlp`. This bot allows users to play and manage music in a voice channel, providing functionalities such as queuing songs, playing the next track, and skipping the current song. Here’s a summary of the key tasks and insights:

    - **Understanding the Problem**:
      - The goal was to create a Discord bot that can play audio from YouTube in a voice channel. The bot should handle commands for adding songs to a queue, playing them, and managing playback.

    - **Bot Setup and Intents**:
      - Configured the bot with necessary intents to read message content and handle voice state updates. This setup ensures the bot can interact with users and manage voice connections effectively.

    - **Music Playback**:
      - Implemented the `play` command to search for a song on YouTube, retrieve its URL, and add it to a queue. The bot connects to the user's voice channel if it is not already connected.

    - **Queue Management**:
      - Developed a queue system to manage song playback. The `play_next` method handles playing the next song in the queue and automatically continues playback when a song ends.

    - **Error Handling**:
      - Incorporated error handling to manage issues that may arise during the search and playback process, providing users with clear feedback if something goes wrong.

    - **Skipping Songs**:
      - Added a `skip` command to stop the currently playing song and move to the next one, enhancing the bot's usability.

  * This project provided valuable experience in integrating Discord's API with audio streaming, handling asynchronous tasks, and implementing user commands. The bot's functionality showcases the practical application of Python in creating interactive and useful tools for Discord communities.
* Day 174: Technical Test "getPermutation" and "rotateRight" [LeetCode](https://leetcode.com/problems/)

  - **getPermutation**: Implemented a solution for the "Permutation Sequence" problem, where the task is to return the k-th permutation sequence of numbers from 1 to n. The approach involves calculating the factorial of n to determine the number of permutations for each block of numbers. The solution uses this factorial to pick the correct digit for each position in the permutation and progressively builds the k-th sequence by updating k for the next position. The algorithm efficiently finds the desired permutation by reducing the search space with each step. The time complexity is O(n²) due to the factorial computations and list manipulations.  
    [Problem Description: getPermutation](https://leetcode.com/problems/permutation-sequence/description/)

  - **rotateRight**: Solved the "Rotate List" problem, where the objective is to rotate a linked list to the right by k places. The algorithm first calculates the length of the list and makes it circular by connecting the last node to the head. Afterward, it determines the new tail and head by traversing the list based on the modulo of k with the list length. The final step involves breaking the circular connection to form the rotated list. This method has a time complexity of O(n), where n is the length of the list.  
    [Problem Description: rotateRight](https://leetcode.com/problems/rotate-list/description/)
* Day 175: Build Your Own News Hub in Python - RSS Feed Aggregator by [NeuralNine](https://www.youtube.com/watch?v=5mEmE7pBI1A)

  * Today, I worked on a project to create an RSS Feed Aggregator using Python and Flask, inspired by a [NeuralNine](https://www.youtube.com/watch?v=5mEmE7pBI1A) tutorial. This project fetches and displays news articles from multiple sources in a user-friendly interface. Here's a breakdown of the key components and features:

    - **User Interface**:
      - Developed a simple web interface with HTML templates and Flask, allowing users to browse the latest news articles from different sources.
      - Implemented a search functionality that enables users to look for specific keywords across the fetched news articles.

    - **RSS Feed Parsing**:
      - Used the `feedparser` library to fetch and parse RSS feeds from various news sources such as Yahoo Finance, Hacker News, Wall Street Journal, and CNBC.
      - Dynamically displayed the fetched articles in a paginated format, allowing for better user experience when browsing through large sets of articles.

    - **Search Functionality**:
      - Added a search form to the header of the website, enabling users to input a keyword and retrieve relevant articles containing that term.
      - Filtered the RSS feed entries to match the search query, displaying the results in a dedicated search results page.

    - **Pagination**:
      - Implemented a pagination system that divides articles into pages, showing 10 articles per page. Users can navigate between pages using the “Next” and “Previous” buttons.

    - **Technical Implementation**:
      - The back-end logic was implemented in Python using the Flask framework, while HTML was used for the front-end.
      - The project makes use of RSS feeds and dynamically updates the content based on the fetched data.
      - Designed reusable HTML templates with `base.html` providing a consistent layout, and specific pages like `index.html` and `search_results.html` handling different types of content.

  * This project was an excellent exercise in integrating multiple technologies, including Flask for web development, RSS feeds for content aggregation, and HTML for building dynamic and responsive web pages. It provided a great opportunity to work on creating a functional news hub with real-time data.
* Day 176: 🔺 Maximum Sum Path in a Triangle - Recursive Algorithm 🔺

  * Today, I worked on a Python program that finds the maximum sum path from the top to the bottom of a triangle using recursion. The project focused on applying recursive techniques to explore different paths and choose the one with the maximum sum. Below is an overview of the key components and insights:

    - **Understanding the Problem**:
      - The goal was to navigate a triangle from the top to the bottom, selecting adjacent numbers in each row, and calculating the maximum possible sum along the way.

    - **Recursive Approach**:
      - Implemented the `max_sum_path(triangle, row, col, n)` function to recursively calculate the maximum sum path by exploring two possible moves: directly below or diagonally to the right.
      - At each step, the function returns the maximum sum path by comparing the two possible paths (left and right).

    - **Base Case Handling**:
      - The base case occurs when the recursion reaches the last row of the triangle, where the function simply returns the value of the current element.
      - This ensures the recursion terminates when all rows are processed.

    - **Initiating the Recursion**:
      - The `find_max_sum(triangle)` function initiates the recursive process from the top of the triangle, passing the necessary parameters to the recursive function to explore all paths.

    - **Output and Visualization**:
      - The program prints the maximum sum path from the top to the base of the triangle, providing a clear indication of the optimal path for maximizing the sum.

  * This project was a great way to apply recursive problem-solving to a real-world mathematical challenge. It also reinforced the importance of recursion in exploring all possible combinations and selecting the optimal solution, offering valuable insights into dynamic programming techniques as well.
* Day 177: 📂 File System Management in Python 🖥️

  Today, I worked on a File System Management project using Python, which focused on applying Object-Oriented Programming (OOP) principles like inheritance, encapsulation, and abstraction to manage files and folders. Here are the key highlights of the project:

  - **Encapsulation**: The `FileSystemItem` class encapsulates the attributes `name` and `path`, making them private to ensure data protection. Getter methods provide controlled access to these attributes.

  - **Inheritance**: The `File` and `Folder` classes inherit from the abstract base class `FileSystemItem`. This ensures that both files and folders have common attributes and behaviors, promoting code reusability.

  - **Abstraction**: The `FileSystemItem` class includes an abstract method `get_description`, which is implemented differently by `File` and `Folder` classes to return specific details about each item. This maintains a consistent interface while allowing customized behavior for different types of items.

  - **File and Folder Operations**: Users can register new files and folders, check their details, and perform operations on files (such as reading or writing). A menu-driven interface makes interaction with the system user-friendly and practical.

  - **File System Interaction**: The project interacts with the actual file system, checking if the paths provided for files and folders exist and retrieving file sizes. This adds a layer of real-world utility by directly integrating with the operating system.

  - **File Operations**: The `FileOperation` class logs operations performed on files (such as read, write, or execute), along with the date of the operation, providing a history of interactions with each file.

  This project provided a practical implementation of OOP concepts and demonstrated how they can be used to build scalable and structured systems. It was a great opportunity to reinforce my understanding of how inheritance, encapsulation, and abstraction contribute to clean, maintainable code in real-world applications.

* Day 178: 🛒📊 Customer Purchasing Behaviors [Kaggle](https://www.kaggle.com/datasets/hanaksoy/customer-purchasing-behaviors/data)

  * Today, I worked with the Customer Purchasing Behaviors dataset from Kaggle, focusing on data analysis and visualization. Below is a summary of the key activities and insights obtained:

    - **Data Loading**:
      - Imported the dataset using Pandas and conducted an initial examination to understand the data structure and key features.

    - **Data Cleaning**:
      - Checked for missing values and ensured the data's integrity.
      - Performed data type conversions, particularly for dates and categorical variables, to facilitate analysis.
    
    - **Exploratory Data Analysis (EDA)**:
      - **Categorical Features**:
        - Created count plots for various features like product categories, customer segments, and purchase channels.
        - Analyzed the distribution of customer segments and product categories using pie charts.
        - Investigated the frequency of purchases across different days, months, and customer segments to identify trends.
      - **Numerical Features**:
        - Analyzed the distribution of total spending by customer and product category using box plots and bar charts.
        - Visualized the average and median purchase amounts across different customer segments and product types.
      - **Time Series Analysis**:
        - Explored how purchasing behaviors varied by time of day, day of the week, and month.
        - Created visualizations showing the distribution of purchases over time, including monthly and daily trends.

    - **Advanced Visualizations**:
      - Utilized Plotly to create interactive visualizations such as heatmaps for purchase frequency across different days and customer segments.
      - Generated detailed bar charts and sunburst plots to explore customer purchase patterns by product category and segment.
      - Used seaborn and Matplotlib to produce enhanced count plots, box plots, and time series graphs for deeper insights.

  * This analysis provided valuable insights into customer purchasing behaviors, including trends across product categories, spending patterns, and customer segments. The visualizations helped uncover key patterns that can guide marketing and sales strategies for businesses looking to optimize their offerings based on customer data.
* Day 179: Movie Recommendation App with Streamlit  
  * Today, I focused on building a **Movie Recommendation App** using Streamlit, a powerful open-source framework designed for creating web applications. The app allows users to select a movie genre and receive recommendations based on a dataset of movies. Here's a breakdown of what I accomplished:

    - **Setting Up the Environment**: Installed Streamlit and other necessary libraries like Pandas for data manipulation.
    - **Dataset**: Used a dataset from [Kaggle](https://www.kaggle.com/datasets/akshaypawar7/millions-of-movies) that contains information about millions of movies, including genres, ratings, release dates, and more.
    - **Loading Data Efficiently**: Implemented data caching using `st.cache_data` to improve performance when loading the movie dataset.
    - **User Interface**: Built an intuitive UI where users can:
      - Preview the movie dataset, showing details like title, genres, release date, rating, and vote count.
      - Select a movie genre from a dropdown menu and receive a list of recommended movies from that genre.
    - **Movie Filtering and Display**: Filtered the movies by genre and displayed each recommendation with details such as the title, release year, rating, vote count, and a brief overview. Additionally, the app displays the movie poster fetched from an external source.
    - **Sidebar with Additional Information**: Created a sidebar that provides information about the app and some statistics about the dataset, including the total number of movies and the top 5 highest-rated films.
  
  This project highlights the ease of using Streamlit to build interactive applications with dynamic content based on user input. The recommendation feature provides a practical use case for filtering and displaying data, making it a helpful tool for exploring movie options by genre. 

  This was an excellent exercise in building a recommendation system, working with movie datasets, and creating a user-friendly interface.
* Day 180: Technical Test "uniquePaths" and "uniquePathsWithObstacles" [LeetCode](https://leetcode.com/problems/)
  
  - **uniquePaths**: Implemented a solution for the "Unique Paths" problem, where the task is to determine the number of unique paths a robot can take to reach the bottom-right corner of an m x n grid, starting from the top-left corner. The robot can only move either right or down at any point. The approach uses dynamic programming to compute the number of ways to reach each cell in the grid by adding the number of ways to reach the top and left cells. The solution has a time complexity of O(m * n) as we fill up the grid iteratively.
    [Problem Description: uniquePaths](https://leetcode.com/problems/unique-paths/description/)

  - **uniquePathsWithObstacles**: Solved the "Unique Paths II" problem, which is an extension of the "Unique Paths" problem but introduces obstacles in the grid, marked as 1. The robot must avoid these obstacles when moving to the bottom-right corner. The algorithm uses a modified dynamic programming approach to track valid paths, ensuring that any cell marked with an obstacle is not considered in the path calculation. The time complexity remains O(m * n), as the grid is processed similarly to the first problem but with obstacle checks.
    [Problem Description: uniquePathsWithObstacles](https://leetcode.com/problems/unique-paths-ii/description/)

* Day 181: 🏀 Basketball Team Generator and Visualizer with Python 📊

  * Today, I developed a Python program that generates a team of random basketball players and visualizes their statistics using various charts. This project allowed me to explore data generation, visualization, and file handling in Python. Here’s a summary of the key tasks and insights:

    - **Understanding the Problem**:
      - The objective was to create a system that generates random basketball player statistics and provides visualizations for analysis. The program includes functionalities to generate player data, display it in graphical formats, and optionally save the generated data to a file.

    - **Player Generation**:
      - Implemented the `generate_player` function to create random player profiles, including attributes such as name, height, position, and performance metrics like points per game, rebounds, assists, and field goal percentage. This function uses the `random` library to ensure that each player’s statistics are unique and realistic.

    - **Data Visualization**:
      - The `plot_player_stats` function creates a polar bar chart using Matplotlib to visualize rebounds, assists, and field goal percentage. This chart helps in comparing these metrics in a circular format, making it easier to see the distribution of stats.
      - The `plot_points` function generates a separate bar chart to display the points scored per game by each player. This visualization highlights the player's scoring ability in a straightforward bar format.

    - **Team Creation and Saving**:
      - The `create_team` function generates a list of random players based on user input for the number of players. This feature allows for flexible team sizes.
      - The `save_team` function saves the generated team data to a text file, making it easy to store and review the player information later. The data is written in a human-readable format, providing a comprehensive view of each player’s attributes.

    - **Interactive User Experience**:
      - The main program includes user prompts to determine the number of players to generate and whether to save the team data. This interactive approach ensures that the program can be used effectively based on user preferences.

  * This project provided valuable experience in combining data generation with visualization techniques. By integrating polar and bar charts, the program offers a comprehensive view of player statistics. The file-saving feature also enhances the program’s usability by allowing users to store and manage player data efficiently. Moving forward, I plan to explore additional enhancements, such as advanced statistical analyses and more sophisticated visualizations.
* Day 182: 🍽️ Restaurant Management System in Python 🍴

  Today, I worked on a Restaurant Management System using Python, with a focus on Object-Oriented Programming (OOP) principles such as inheritance, encapsulation, and abstraction. The project allows customers to place orders, manage food and drinks, calculate tips, and keep track of the server responsible for each order. Below are the key highlights:

  - **Encapsulation**: The `Person` class encapsulates attributes like `name` and `id_number`, ensuring that personal information is protected by making them private. Controlled access is provided through getter methods.

  - **Inheritance**: The system uses inheritance for customer and server classes, both derived from the `Person` abstract class. This allows reusability of common attributes (like `name` and `id_number`) while providing specialized functionality for each subclass.

  - **Abstraction**: The `Person` class contains an abstract method `get_description`, which is implemented by both `Customer` and `Server` classes. This ensures that each type of person in the system has a tailored description, maintaining a consistent interface.

  - **Order Management**: Customers can place orders that include food, drinks, and optional tips. The `Order` class captures details like order number, total price, and the server assigned to the order. This makes the system easy to extend with new features in the future.

  - **Billing and Tips**: The system calculates the total bill based on the items ordered, with an option to add a tip. The final payment amount is clearly displayed, offering both customer satisfaction and ease of tracking for the restaurant.

  - **Menu Options**: A menu-driven interface allows for interaction with the system, where users can place orders, check order details, and calculate the final bill. This makes the program user-friendly and practical for a real restaurant scenario.

  This project was an excellent exercise in applying OOP principles to create a well-structured and maintainable system. I had the opportunity to refine my understanding of how abstraction, encapsulation, and inheritance work together to create clean and reusable code, all while building a practical restaurant management tool.


* Day 183: 🌊 Crossing the River Problem - Recursive Solution 🌊

  * Today, I developed a Python program that solves the classic **Crossing the River Problem** using a recursive approach. This problem involves moving a farmer, a wolf, a goat, and a cabbage across a river with specific constraints, ensuring no dangerous combinations are left unsupervised. Here's an overview of the key components and insights from this project:

    - **Understanding the Problem**:
      - The goal is to transport the farmer, the wolf, the goat, and the cabbage from the left bank of the river to the right bank using a boat. However, there are restrictions:
        - The wolf cannot be left alone with the goat.
        - The goat cannot be left alone with the cabbage.
        - Only two items (the farmer and one other) can cross the river at a time.

    - **Recursive Approach**:
      - Implemented the `solve(state, path=[])` function to recursively explore possible moves while ensuring the state remains valid after each crossing.
      - The program explores all possible combinations of moves, considering the constraints and checking if the goal state (all items on the right bank) is achieved.

    - **State Validation**:
      - A helper function `is_valid_state(state)` ensures that no illegal combinations occur on either bank when the farmer is absent. This prevents situations where the goat is eaten by the wolf or the cabbage is eaten by the goat.

    - **Recursive Movement**:
      - The `move_item(state, item)` function moves the farmer and an optional item between the banks. The recursion avoids revisiting the same state to ensure efficiency.

    - **Goal Achievement**:
      - The base case occurs when all objects are successfully transported to the right bank, and the recursion terminates with the correct solution path.

    - **Output and Visualization**:
      - The program prints each step of the solution, showing the left and right bank configurations after each crossing, leading to the final state where all items have crossed safely.
* Day 184: Technical Test "minPathSum" and "isNumber" [LeetCode](https://leetcode.com/problems/) 

  - **minPathSum**: Implemented a solution for the "Minimum Path Sum" problem, where the task is to find the path from the top-left corner to the bottom-right corner of a grid that minimizes the sum of all numbers along the path. The robot can only move either right or down at any point in time. The approach uses dynamic programming to iteratively update the grid by calculating the minimum sum required to reach each cell. The time complexity is O(m * n), where m and n represent the dimensions of the grid.
    [Problem Description: minPathSum](https://leetcode.com/problems/minimum-path-sum/description/)

  - **isNumber**: Solved the "Valid Number" problem, which validates if a given string can be interpreted as a valid number according to specific rules, including handling integers, decimal numbers, and exponents. The solution uses regular expressions to match the structure of valid numbers, ensuring correct handling of edge cases such as signs, decimal points, and scientific notation. The solution processes the string in O(1) time, as regular expressions offer an efficient way to match the pattern.
    [Problem Description: isNumber](https://leetcode.com/problems/valid-number/description/)
* Day 185: Estimating Pi with Monte Carlo Method
  Today, I focused on building a Python program to estimate the value of **Pi** using the **Monte Carlo** method. This method involves generating random points in a unit square and calculating how many fall within a unit circle to estimate the value of Pi. Here's a breakdown of what I accomplished:

  - **Importing Libraries**: Utilized essential Python libraries like `matplotlib` for plotting and `numpy` for generating random points and mathematical calculations.
    
  - **Monte Carlo Method Implementation**:
    - Created a function `pi_montecarlo(n, n_exp)` where:
      - `n` represents the number of random points generated per experiment.
      - `n_exp` represents the number of experiments to perform.
    - For each experiment, the program generates random `(x, y)` points between 0 and 1.
    - It calculates the distance of each point from the origin and checks whether the point lies inside the unit circle.
    - Repeated the experiment `n_exp` times and averaged the results to get a more accurate estimate of Pi.

  - **Visualizing the Results**:
    - Plotted the estimated values of Pi over multiple experiments to observe how the accuracy improves as the number of experiments increases.
    - The final plot includes:
      - Estimated values of Pi for each experiment.
      - Clear labels for the x-axis (Experiment Number) and y-axis (Estimated Pi).
      - A title to make the plot more informative: "Estimated Pi Values over Experiments."
    
  - **Program Execution**:
    - Ran the function with 10,000 points per experiment and 200 experiments.
    - Displayed the average estimated value of Pi and plotted the results for visualization.

  This project provides an excellent example of applying statistical techniques to estimate a mathematical constant. The Monte Carlo method demonstrates how random sampling can be used to approximate complex values with increasing accuracy as more data points are used.
* Day 186: BMI Calculator in Python - Flask Application
  * Today, I worked on building a simple BMI (Body Mass Index) calculator using Python and Flask. This project allows users to input their weight and height, calculate their BMI, and receive a health category based on the result. Below is a breakdown of the key components and features:

    - **User Interface**:
      - Developed a clean and minimalistic web interface using HTML and CSS. The form takes the user’s weight (in kilograms) and height (in meters) as inputs and calculates the BMI upon form submission.
      - Implemented responsive design with a focus on user-friendliness, ensuring the form and results are clearly visible on both desktop and mobile devices.

    - **BMI Calculation**:
      - Used a simple formula to calculate BMI: `BMI = weight / (height^2)` where weight is in kilograms and height is in meters.
      - Displayed the calculated BMI along with a corresponding health category:
        - **Underweight**: BMI less than 18.5
        - **Normal weight**: BMI between 18.5 and 24.9
        - **Overweight**: BMI between 25 and 29.9
        - **Obesity**: BMI of 30 or higher

    - **Result Display**:
      - After submitting the form, the user is shown their calculated BMI and the associated health category (e.g., "Normal weight").
      - Implemented condition-based formatting for better visual feedback. For example, different BMI categories are highlighted with different colors for clarity.

    - **Technical Implementation**:
      - The back-end logic is written in Python using the Flask framework, which processes the input data, calculates the BMI, and renders the result back to the user.
      - A `POST` method was used to handle form submission and calculation. The results are dynamically displayed using Jinja2 templates.
      - The front-end includes a `style.css` file in the `/static/css` directory to ensure the application has a clean, modern look.

    * This project was a great opportunity to further enhance my Flask skills while building a practical health-related application. It provided insights into form handling, dynamic content generation, and simple calculations based on user input.
* Day 187: 🎲 Lottery Simulator in Python 🎯 

  Today, I worked on a Lottery Simulator using Python and Tkinter, creating a graphical interface for users to choose their lottery numbers and check if they match randomly generated lottery results. Below are the key highlights of the project:

  - **User Input**: The program allows users to input six unique numbers between 1 and 49. These numbers are validated to ensure they meet the required conditions, such as being within the range and not repeating.

  - **Random Number Generation**: The program generates six random lottery numbers using Python's `random.sample` function, ensuring that each number is unique. These numbers are then compared with the user's input.

  - **Matching Logic**: The user’s input is compared with the randomly generated lottery numbers, and the number of matches is displayed in a message box. If all six numbers match, a congratulatory message appears, declaring the user as the winner.

  - **Graphical User Interface (GUI)**: The program uses Tkinter to create a simple and clean interface. The layout is organized with entry boxes for user input and a button that triggers the lottery check. The interface includes:
    - **Entry Fields**: Six entry fields for users to input their numbers.
    - **Lottery Check Button**: A button that checks the user's numbers against the generated lottery numbers and displays the result.
    - **Message Box**: A message box to display the outcome, whether it's a win or how many numbers matched.

  - **Error Handling**: The system handles input errors gracefully, ensuring that users input valid numbers and receive informative messages if they don't.
* Day 188: Technical Test "addBinary" and "plusOne" [LeetCode](https://leetcode.com/problems/) 
  - **addBinary**: Implemented a solution for the "Add Binary" problem, which involves adding two binary strings and returning their sum as a binary string. The approach processes the binary strings from right to left, simulating manual addition by summing digits and tracking carry. The solution handles cases where the strings have different lengths and ensures that any remaining carry is accounted for in the final result. The time complexity is O(max(n, m)), where n and m are the lengths of the input strings.
    [Problem Description: addBinary](https://leetcode.com/problems/add-binary/description/)

  - **plusOne**: Solved the "Plus One" problem, where the task is to increment an integer represented by an array of its digits. The algorithm starts from the least significant digit and adds one, adjusting for carries as necessary. If the entire number consists of nines, a new digit is added at the beginning of the array. The time complexity is O(n), where n is the number of digits in the input array.
    [Problem Description: plusOne](https://leetcode.com/problems/plus-one/description/)
* Day 189: 🔍 Longest Common Subsequence (LCS) 

  Today, I worked on the Longest Common Subsequence (LCS) problem using Python, focusing on recursion to solve the problem. This algorithm finds the longest subsequence common between two given strings. Below are the key highlights:

  - **Recursion**: The solution is implemented using a recursive approach. The base case checks if either of the strings is empty, in which case the LCS is zero. Otherwise, the function compares the last characters of both strings.

  - **Character Matching**: If the last characters of the two strings match, the function proceeds by removing the last character from both strings and recursively calling itself. The result is incremented by 1, indicating that the matched character contributes to the LCS.

  - **Character Mismatch**: When the last characters differ, the algorithm explores two options: removing the last character from one of the strings and calling the function recursively on the remaining parts of the strings. The maximum result from these two recursive calls is taken as the LCS length.

  - **Efficiency**: This recursive approach, while intuitive, is not the most efficient for large strings due to its exponential time complexity. However, it serves as a clear demonstration of how recursion can be applied to complex problems like LCS.

  - **Base Cases**: The base cases are crucial to the recursive approach. When either string is reduced to an empty substring, the recursion stops, ensuring that the solution does not continue indefinitely.

  - **Example Case**: For the strings `"AGGTAB"` and `"GXTXAYB"`, the algorithm correctly identifies that the LCS is `"GTAB"` with a length of 4.

  - **Future Enhancements**: This recursive solution can be further optimized using dynamic programming techniques to avoid redundant calculations, making it feasible for larger inputs.

  This project was an excellent opportunity to deepen my understanding of recursion in Python. I explored how breaking down a problem into subproblems can simplify the overall structure, even when the solution is not the most optimal. I look forward to extending this solution with dynamic programming to handle more complex cases efficiently.
* Day 190: 🧠 MNIST Neural Network with Hyperparameter Tuning in Python 🤖
  Today, I worked on building a neural network model using Python and TensorFlow to classify handwritten digits from the MNIST dataset. This project is based on the amazing work and tutorial by **NeuralNine**, which I followed on [YouTube](https://www.youtube.com/watch?v=lKusotIjzwk). I respect and admire the quality of content NeuralNine provides, and this tutorial was a fantastic learning experience. Below are the key highlights:

  - **Model Architecture**: The neural network consists of an input layer, a flattening layer to convert the 2D images into a 1D vector, hidden layers with ReLU activation functions, and a final output layer using softmax activation for multiclass classification. This architecture allows the network to learn complex features of the handwritten digits.

  - **Normalization**: The input data was normalized to ensure that the values fall between 0 and 1, which helps the model converge faster and improves accuracy during training.

  - **Adam Optimizer**: The model is trained using the Adam optimizer, with a learning rate of 0.005. Adam is well-suited for large datasets and adjusts the learning rate dynamically, leading to faster convergence.

  - **GridSearchCV**: I implemented hyperparameter tuning using GridSearchCV from scikit-learn, which allowed me to search for the best combination of hyperparameters such as the number of hidden layers, the number of neurons per layer, and batch normalization/dropout options. This optimization process helps in finding the model with the highest accuracy on the test set.

  - **Dropout and Batch Normalization**: The project includes options to add dropout layers and batch normalization to prevent overfitting and ensure that the model generalizes well to unseen data.

  - **Model Evaluation**: The model was evaluated using the test dataset after training. Accuracy and loss were calculated to assess the model’s performance, ensuring that it classifies the digits with high precision.

  - **Hyperparameter Tuning Results**: After running GridSearchCV, the best model was selected based on the highest accuracy score. The optimal hyperparameters, such as the number of hidden layers and neurons, were determined and applied to improve the model's performance.

  This project was a valuable exercise in neural network construction, model optimization, and hyperparameter tuning using scikit-learn. I learned a lot from NeuralNine's tutorial, and I deeply respect their commitment to delivering high-quality educational content.
* Day 191: 🚗 Vehicle Management System in Python 🚙
  Today, I developed a Vehicle Management System using Python, incorporating Object-Oriented Programming (OOP) principles such as inheritance, encapsulation, and abstraction. The project allows for the registration and management of different types of vehicles, such as Sports Cars, Minivans, and more. Below are the key highlights of the project:

  - **Encapsulation**: The `Vehicle` class encapsulates attributes like `make`, `model`, and `license_plate`, ensuring that sensitive information is protected by making them private. Controlled access is provided through getter methods, allowing secure data handling.

  - **Inheritance**: The system employs inheritance for different vehicle categories, such as `SportsCar` and `Minivan`, both derived from the base `Vehicle` class. This design allows for reusability of common attributes (like `make` and `model`) while providing specialized functionality for each subclass, enhancing flexibility and scalability.

  - **Abstraction**: The `Vehicle` class contains an abstract method `get_description`, which is implemented by each specific vehicle category. This ensures that every type of vehicle in the system has a tailored description, maintaining a consistent interface and making the code easily extensible.

  - **Category Management**: The system allows users to register vehicles in various categories (Sports Car, Minivan, etc.), record details such as mileage, owner information, and maintenance history, and retrieve comprehensive vehicle data. This feature-rich structure provides a realistic scenario for a vehicle management application.

  - **Data Handling**: The system tracks key details such as vehicle types, mileage, and ownership history. It also includes methods to retrieve and display this data in an organized manner, simulating a real-world vehicle management scenario.

  - **Menu Options**: A menu-driven interface facilitates interaction with the system, allowing users to register new vehicles, display vehicle details, and manage various aspects of each vehicle category. This makes the program user-friendly and practical for real-world applications.

  This project was an excellent exercise in applying OOP principles to create a structured and maintainable system. It provided a great opportunity to deepen my understanding of how abstraction, encapsulation, and inheritance can be effectively used to build a versatile and efficient vehicle management tool.


* Day 192: 💤💪 Health and Sleep Statistics [Kaggle](https://www.kaggle.com/datasets/hanaksoy/health-and-sleep-statistics/data) 

  * Today, I worked with the Health and Sleep Statistics dataset from Kaggle, focusing on data analysis and visualization. Below is a summary of the key activities and insights obtained:

    - **Data Loading**:
      - Imported the dataset using Pandas and conducted an initial examination to understand the data structure and key features.

    - **Data Cleaning**:
      - Checked for missing values and ensured the data's integrity.
      - Performed data type conversions, especially for dates and numerical fields, to prepare the data for analysis.

    - **Exploratory Data Analysis (EDA)**:
      - **Sleep and Health Analysis**:
        - Analyzed sleep patterns, including average sleep duration and sleep efficiency.
        - Created visualizations to explore relationships between sleep duration and factors like age, gender, and activity levels.
        - Investigated correlations between health metrics such as BMI, daily steps, and sleep quality.
      - **Physical Activity Insights**:
        - Visualized the distribution of daily steps, calories burned, and active minutes across different age groups and genders.
        - Explored the relationship between physical activity and sleep quality using scatter plots and heatmaps.
      - **General Health Metrics**:
        - Examined the distribution of BMI, resting heart rate, and other health indicators.
        - Generated insights into how these health metrics are influenced by sleep patterns and activity levels.

    - **Advanced Visualizations**:
      - Utilized Plotly to create interactive visualizations, such as:
        - **Heatmaps**: Showing correlations between sleep efficiency, activity levels, and health metrics.
        - **Line Graphs**: Illustrating trends in sleep duration and physical activity over time.
      - Developed sunburst plots and bar charts to provide deeper insights into health statistics across different demographics.

  * This analysis provided valuable insights into how sleep patterns and physical activity are connected to overall health. The visualizations revealed important trends and correlations that can be beneficial for individuals aiming to improve their health and sleep habits.
* Day 193: 🔍 Anagram Finder in Python 🧩 

  Today, I worked on an Anagram Finder project using Python. This program is designed to find all valid anagrams of a given set of letters based on a predefined dictionary, applying concepts of recursion and permutation generation. Below are the key highlights of the project:

  - **Dictionary Loading**: The program uses a text file `dictionary.txt` containing a list of valid words, which is loaded into a set. This enables fast lookup operations and ensures that only valid words are considered as anagrams.

  - **Permutation Generation**: By utilizing Python's `itertools.permutations` module, the program generates all possible permutations of the input letters, efficiently producing every combination without requiring manual iteration. This approach captures all potential anagram candidates in a compact manner.

  - **Anagram Validation**: Each generated permutation is checked against the loaded dictionary to determine if it forms a valid word. This step ensures that only meaningful words are included in the list of anagrams, filtering out nonsensical combinations.

  - **User Input and Output**: The system prompts the user to enter a set of letters and then displays all valid anagrams found in the dictionary. This interactive feature makes the program engaging and easy to use.

  - **Efficiency**: By using sets and efficient permutation generation, the program is optimized to handle larger sets of letters with minimal computational overhead, demonstrating the practical use of data structures and algorithm optimization.
  
  This project was an excellent opportunity to explore permutation generation and apply dictionary lookups efficiently. It provided valuable insights into handling recursive problems, optimizing data handling, and integrating external data into a Python program.
* Day 194: Technical Test "fullJustify" and "mySqrt" [LeetCode](https://leetcode.com/problems/)

  - **fullJustify**: Implemented a solution for the "Text Justification" problem, where the task is to format a list of words such that each line has exactly `maxWidth` characters and is fully justified. The solution packs words into lines using a greedy approach, ensuring that spaces are distributed as evenly as possible between words. For the last line, the text is left-justified, with any remaining spaces added to the end. The implementation efficiently handles the distribution of spaces, achieving the desired justification in O(n) time complexity, where n is the total number of words.
    [Problem Description: fullJustify](https://leetcode.com/problems/text-justification/description/)

  - **mySqrt**: Solved the "Sqrt(x)" problem, which involves finding the square root of a non-negative integer `x` rounded down to the nearest integer. The solution employs a binary search approach to efficiently calculate the integer square root without using built-in exponent functions or operators. The algorithm has a time complexity of O(log x), making it well-suited for handling large values of `x`.
    [Problem Description: mySqrt](https://leetcode.com/problems/sqrtx/description/)
* Day 195: 📊 Final Exam Score Calculator in Python 🎓 

  Today, I worked on a Final Exam Score Calculator using Python and Tkinter, with a strong emphasis on user interactivity, data validation, and GUI design principles. This project helps students calculate the required score for their final exam to pass their course, considering their current grades and weights. Here are the key highlights:

  - **User Interactivity**: The calculator provides an intuitive and dynamic interface for adding multiple scores and percentages. Users can easily input their grades and the corresponding weights, making the experience user-friendly and practical.

  - **Data Validation**: The system includes robust data validation to ensure that scores and percentages are within the allowed ranges (0.0 - 5.0 for scores and 0 - 100 for percentages). This ensures accurate calculations and prevents errors, with clear error messages guiding the user.

  - **Dynamic Entry Management**: The project allows users to add multiple input fields dynamically, making it adaptable for different scenarios. The entries can be reset at any time, allowing for multiple calculations without restarting the application.

  - **Progress Tracking**: A progress bar visually represents the total percentage of completed coursework, providing users with immediate feedback on how much weight they have already accumulated and how much is still required.

  - **Result Display**: The program calculates the score needed on the final exam and provides motivational feedback based on the result. This helps users understand their current standing and what they need to achieve to pass.

  - **Motivational Feedback**: The application offers encouraging messages based on the required final score, helping students stay motivated regardless of their current standing. This feature adds a personalized and supportive touch to the tool.

  This project was a fantastic opportunity to enhance my skills in GUI programming with Tkinter, focusing on data validation, dynamic UI updates, and user experience design. It demonstrates how practical applications can be created using Python to solve everyday problems, such as managing academic goals effectively.
* Day 196: 🧩 Sudoku Solver in Python 🔢 

  Today, I worked on a Sudoku Solver using Python, focusing on recursion and backtracking techniques. This project aimed to solve a 9x9 Sudoku puzzle while respecting the rules of the game. Below are the key highlights:

  - **Recursion**: The solution uses a recursive function to attempt filling the Sudoku grid cell by cell. If a valid number can be placed in a cell, the function proceeds to solve the rest of the grid recursively.

  - **Backtracking**: If a conflict arises or no valid number can be placed in a cell, the algorithm backtracks, resetting the cell and trying the next possible number. This systematic approach ensures that all possibilities are explored until the puzzle is solved.

  - **Sudoku Validation**: The solver includes a validation method that checks if placing a number in a specific row, column, or 3x3 grid adheres to the game's rules. This ensures that no invalid placements are made during the solving process.

  - **Grid Representation**: The Sudoku puzzle is represented as a 9x9 grid, where empty cells are denoted by `0`. The program attempts to fill these cells while respecting the constraints, ultimately arriving at a valid solution.

  - **Efficient Backtracking**: By using efficient backtracking, the solver quickly finds solutions to even the most complex puzzles. This process ensures that the program is both effective and optimized for speed.

  - **User Interface**: The project includes a simple function to display the Sudoku board before and after solving, making it easy to visualize the solution process.

  This project was a great opportunity to practice and apply recursion and backtracking, fundamental techniques for solving constraint satisfaction problems. It demonstrated how powerful these techniques can be when building a solution that explores possibilities efficiently. The project also reinforced the importance of validation checks to maintain the integrity of the solution, making it a valuable learning experience.
* Day 197: 🏀 Three-Point Shot Success Calculator in Flask 🎯 

  Today, I worked on a Three-Point Shot Success Calculator using Flask, focusing on creating a basic web application that calculates the success rate of three-point shots in basketball. This project allowed me to practice essential Flask concepts and build an interactive web-based calculator. Here are the key highlights:

  - **User Input Handling**: The web application allows users to input the number of attempted and successful three-point shots through a simple HTML form. This input is processed securely on the server side, ensuring accurate calculation of the success rate.

  - **Backend Calculation**: The application captures the data and performs a calculation to determine the percentage of successful three-point shots. This demonstrates how Python can be used on the backend to handle logic and return the result to the user.

  - **Session Management**: Implemented session management using `app.secret_key`, which ensures that user data remains secure during interactions with the web application. The secret key was generated using Python's `secrets` library, demonstrating the use of cryptographic methods for secure session handling.

  - **Flask Integration**: The project utilizes Flask's routing capabilities to handle different routes (`/` for the home page and `/calculate` for processing the calculation), showcasing how Flask can manage multiple endpoints in a web application.

  - **Error Handling**: Basic error handling is included to ensure that the program reacts appropriately to invalid or missing inputs, providing a smooth user experience.

  - **Interactive Feedback**: The calculated success rate is displayed back to the user in a user-friendly format, demonstrating how server-side calculations can be rendered on a web page.

  This project was an excellent opportunity to reinforce my understanding of how Flask can be used to build simple yet functional web applications. It helped me practice session management, user input handling, and backend calculations, all while applying them to a fun and practical example in the context of basketball statistics.
* Day 198: 🐾 Cats Dataset [Kaggle](https://www.kaggle.com/datasets/waqi786/cats-dataset/data) 

  Today, I worked on analyzing the Cats Dataset from Kaggle using Python. The focus was on data exploration and visualization using libraries such as Pandas, Seaborn, and Matplotlib. The project includes generating statistical summaries, visualizing distributions of numerical and categorical variables, and analyzing correlations between features. Below are the key highlights:

  - **Statistical Summary**: The project includes a function that generates a statistical summary of numerical variables, providing insights such as mean, median, and standard deviation. This helps in understanding the central tendency and spread of the data.

  - **Categorical Distribution**: I created a function to display the distribution of categorical variables, such as breed, color, and gender of the cats. This gives a clear view of how many instances exist for each category, aiding in categorical analysis.

  - **Numerical Distributions**: The code generates histograms for numerical variables, allowing for visual inspection of their distributions. This helps identify any skewness, outliers, or normality in the data.

  - **Bar Graphs for Categorical Variables**: I implemented bar graphs to visualize the distribution of each categorical variable. This enhances the ability to quickly grasp the frequency of categories visually.

  - **Correlation Analysis**: A correlation matrix is generated to analyze relationships between numerical variables. This provides insights into potential relationships that can be explored further, and is visualized with a heatmap for clarity.

  - **User-Friendly Functions**: The project includes functions for generating the full report, making it easy to run all analyses in one go. This modular approach enhances code readability and maintainability.

  This project was an excellent opportunity to deepen my understanding of data analysis techniques in Python, as well as to explore the Cats Dataset thoroughly. The experience reinforced the importance of visualizing data to extract meaningful insights and understand underlying patterns.


* Day 199: 📚 Book Subscription System in Python 📖

  Today, I developed a Book Subscription System using Python, focusing on the Model-View-Controller (MVC) architectural pattern along with Object-Oriented Programming (OOP) principles. The project allows readers to subscribe to different book genres, view reader details, and check the information of available books. Here are the key highlights of the project:

  - **Encapsulation**: The `Person` class, which serves as a base class for `Reader` and `Author`, encapsulates attributes such as `name` and `id_number`. These attributes are private and accessed via getter methods, ensuring data protection and controlled access.

  - **Inheritance**: The system demonstrates inheritance by having `Reader` and `Author` classes inherit from the `Person` abstract class. This allows for the reuse of common attributes like `name` and `id_number`, while enabling each subclass to extend with unique functionality, such as subscribing to genres or adding books.

  - **Abstraction**: The `Person` class features an abstract method `get_description`, which is implemented by both `Reader` and `Author` classes. This ensures a consistent interface across different types of persons in the system while allowing specific details to be tailored to each subclass.

  - **MVC Pattern**: The system is structured according to the MVC pattern:
    - **Model**: Represents the core data (Person, Reader, Author, and Book) and logic of the application.
    - **View**: Handles the display of information and interaction with the user.
    - **Controller**: Manages the communication between the Model and View, processing user input and updating the Model accordingly.

  - **Book Subscription Management**: Readers can subscribe to genres, and authors can add books to the system. The `Controller` class facilitates the logic to manage these interactions, providing a seamless experience for users to interact with the system.

  - **Book Details and Reader Information**: The project includes functionality to display detailed information about books and readers, helping users keep track of their subscriptions and explore different genres.

  - **User Interaction**: A menu-driven interface allows users to navigate the system, subscribe to genres, view reader details, and access book information, making it user-friendly and practical for real-world use.

  This project was a valuable experience in applying the MVC pattern along with OOP principles to build a well-structured and maintainable application. It provided a great opportunity to strengthen my understanding of encapsulation, inheritance, and abstraction while working with an architectural design that ensures a clean separation of concerns.