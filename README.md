# Daily-Projects
This repository contains my daily projects, challenging me to create something new every day. From small utilities to full-fledged applications, they reflect my growth as a developer. Each project has a brief description of technologies, challenges and lessons. It is a record of my progress and a constantly evolving portfolio.
* Day 01:  Polar Plots in Python with Matplotlib by Neural Nine
  * Today we learn how to work with polar coordinates and how to create polar plots in Python using Matplotlib.
* Day 02: Spotify Oldies Dataset üé∂: A Treasury of Classics [Kaggle](https://www.kaggle.com/datasets/kanchana1990/spotify-oldies-dataset/data)
  * Today I'm going to work with a dataset called Spotify Oldies Dataset: A Treasury of Classics.
* Day 03: Pomodoro Timer GUI
  * In this project, I developed a graphical user interface (GUI) for a Pomodoro Timer using Tkinter in Python. The Pomodoro Technique is a time management method that uses a timer to break down work into intervals, traditionally 25 minutes in length, separated by short breaks. This GUI application allows users to start, reset, and skip timers for Pomodoro sessions, short breaks, and long breaks, providing visual feedback on the remaining time for each interval. It serves as a practical tool for enhancing productivity and focus during work or study sessions.
* Day 04: To Do App
  * Today, I created a To Do application using Flask and SQLAlchemy. This app allows users to add, edit, and delete tasks, as well as mark them as completed or in progress. Users can also search and filter tasks by various criteria such as title, completion status, priority, and due date. Additionally, the app supports sorting tasks by ID, title, or completion status, and offers bulk actions to mark tasks as completed, in progress, or not completed. It's a simple yet practical tool for managing daily tasks efficiently.
* Day 05: ContactManager
  * This project involves creating a contact manager application using Python's Tkinter library. The ContactManager allows users to add, edit, view, and delete contacts. It provides features such as pagination, searching, importing/exporting contacts from/to CSV files, and input validation for contact details. It offers a user-friendly interface for managing contact information effectively.
* Day 06: Income Prediction Adult Income [Kaggle](https://www.kaggle.com/datasets/wenruliu/adult-income-dataset)
  * In today's project, I implemented a machine learning model to predict adult income using the Adult Income dataset. The dataset contains various demographic and employment-related features such as age, education level, occupation, and work hours per week, along with the target variable indicating whether an individual earns more than $50,000 annually. I utilized the Random Forest algorithm to train the model and extracted feature importance scores to identify the key factors influencing income prediction. The model achieved an accuracy of  0.86%, demonstrating its capability to classify individuals into different income groups. This project enhances my understanding of supervised learning techniques and their application in real-world scenarios.
* Day 07: Pokedex GUI Application
  * In this project, I developed a graphical user interface (GUI) application for a Pokedex using Python's Tkinter library. The Pokedex is a digital encyclopedia that catalogues information about different species of Pok√©mon, a popular franchise of fictional creatures.
* Day 08: Flet Chat Application
  * Created a chat application using Flet library in Python. This application allows users to join a chat room, send and receive messages in real-time. It features a graphical user interface (GUI) for displaying chat messages, input field for sending messages, and user authentication. The application utilizes Flet components for UI design and integrates functionalities for sending, receiving, and displaying messages efficiently. It serves as a practical tool for real-time communication and collaboration among users.
* Day 09: Video Game Sales [Kaggle](https://www.kaggle.com/datasets/gregorut/videogamesales/data)
  * Today's project delves into the world of video game sales analysis. Leveraging the Video Game Sales dataset from Kaggle, I explore trends and patterns in the gaming industry. This dataset contains information on video game sales across different platforms, regions, genres, and years, providing valuable insights into consumer preferences and market dynamics. Through data exploration, visualization, and potentially predictive modeling, I aim to uncover hidden gems and understand what makes a successful video game title. Stay tuned for the journey through pixels and polygons! üéÆ‚ú®
* Day 10: Summarize News Articles
  * Worked on a project to summarize news articles using web scraping and natural language processing libraries like newspaper3k and TextBlob.
* Day 11: Sudoku Solver
  * In this project, I've crafted a Sudoku solver leveraging the backtracking algorithm in Python. This application empowers users to input incomplete Sudoku puzzles, generating a valid solution for the board. To enhance user experience, I integrated the Tkinter graphical library to craft an interactive interface. Through this interface, users can input Sudoku numbers and witness the solution unfold step by step. This project not only offers an efficient solution for Sudoku puzzles but also serves as an educational tool to delve into backtracking algorithms and Python-based interactive user interfaces.
* Day 12: Snake Pygame
  * In today's project, I built a classic Snake game using Pygame, a popular Python library for creating 2D games. The Snake game is a timeless arcade classic where the player controls a snake that moves around the screen, eating food to grow longer while avoiding collisions with itself and the boundaries of the game area.
* Day 13: Titanic Dataset üö¢ [Kaggle](https://www.kaggle.com/c/titanic)
  * Today, we delve into the exciting world of data analysis with the famous Titanic dataset. This dataset, available on Kaggle, provides information about the passengers aboard the Titanic, including details such as age, gender, ticket class, fare paid, and more. Our task is to explore this dataset, understand its key features, and possibly develop predictive models to determine the likelihood of a passenger's survival based on various factors. Through this project, we will not only enhance our data analysis skills but also honor the memory of the Titanic passengers by extracting meaningful insights from this historic dataset.
* Day 14: Email Python
  * Today's project involves creating a Python script for sending automated emails. Leveraging libraries such as smtplib, schedule, and dotenv, we develop a script capable of sending daily inspirational emails to a specified email address. The script reads quotes from a file, selects a random quote, and sends it via SMTP protocol. Utilizing environment variables for storing email credentials ensures security and flexibility. By scheduling the script to run periodically using the schedule library, we automate the process of sending daily inspiration to recipients, fostering motivation and positivity. This project not only demonstrates practical use cases of Python for automation but also serves as a reminder of the power of uplifting messages in our daily lives.
* Day 15: Guess the Number
  * Today's project involves creating a number guessing game using Python's Tkinter library for building the graphical user interface (GUI). The game prompts the player to guess a randomly generated number between 1 and 99 within a limited number of attempts. Through input validation and dynamic feedback, the game guides the player to adjust their guesses until they either correctly identify the number or exhaust their attempts. This project not only showcases interactive GUI development with Tkinter but also reinforces concepts of random number generation, user input handling, and game logic implementation. It provides an entertaining and engaging experience for players while honing programming skills in Python. Can you beat the odds and guess the secret number? Let the guessing game begin! üé≤
* Day 16: Virtual Bookshelves
  * In this project, I'll create a virtual bookshelf management system using Python and SQLite. The application will allow users to add, remove, update, and view books in their virtual bookshelves. Each book will have attributes such as title, author, year published, and genre. The system will utilize SQLite for database management and provide a user-friendly interface for interacting with the bookshelves. This project aims to simulate real-world bookshelf management scenarios and provide users with a convenient way to organize their reading materials. Let's embark on the journey of building virtual bookshelves to enhance our reading experiences! üìö‚ú®
* Day 17: RSS Feed Reader
  * In this project, I'll develop an RSS feed reader using Python and BeautifulSoup. The RSS feed reader will be capable of fetching and parsing RSS feeds from various sources. It will extract relevant information such as titles, descriptions, and links from the feeds, presenting them in a user-friendly format. By implementing this RSS feed reader, I aim to enhance my skills in web scraping, XML parsing, and data presentation. Stay tuned for an efficient tool to stay updated with the latest news and content from your favorite websites! üì∞üöÄ
* Day 18: Customer Manager JSON
  * In this project, I've developed a customer management system using Python and JSON. The system allows users to store and manage information about customers, including names, email addresses, cities, etc. It implements functionalities such as searching for customers by name, updating contact information, deleting customers, and adding new customers. Leveraging JSON as the data storage format ensures portability and simplicity in data management. This project enhances my skills in file handling, data manipulation, and user interface design. It serves as a practical tool for organizing customer data efficiently and facilitating effective communication and interaction with clients. Let's embark on the journey of customer management and streamline the process of customer engagement! üìäüë•
* Day 19: Expense Tracking App
  * Created an expense tracking application using Python's Tkinter library. This app allows users to record their expenses, including item name, price, and purchase date. Users can add, edit, delete, and view expense records, providing a convenient way to manage their finances. Additionally, the app calculates the total expense and remaining balance, offering insights into spending habits. It serves as a practical tool for budgeting and financial management. üìäüí∞
* Day 20: Hangman
  * Implemented the classic Hangman game using Python and Flask. Players can guess letters to reveal a hidden word within a limited number of attempts. The game features a user-friendly interface and supports error handling for invalid inputs. Test your vocabulary and strategic thinking in this timeless word-guessing challenge! üé©üî§
* Day 21: Image Editor
  * In this project, I developed an image editor using Python and Tkinter. The Image Editor allows users to open image files, apply filters such as black and white, blur, sharpen, and more, flip and rotate images, draw lines over the images, change pen color, erase drawn lines, and save edited images. It provides a user-friendly interface for basic image editing tasks and serves as a practical tool for enhancing and modifying images. Let your creativity flow with the Image Editor! üé®üñºÔ∏è
* Day 22: Faker User
  * In this project, I utilized the Faker library in Python to generate synthetic user data. From names and email addresses to phone numbers and job titles, Faker User creates realistic user profiles effortlessly. Whether for testing, prototyping, or data augmentation, Faker User streamlines the process of generating diverse and customizable datasets.
* Day 23: Simple Stock Price (Steamlit)
  * Today's project revolves around creating a Simple Stock Price application using Streamlit. This application enables users to visualize stock price data, including closing prices, volume, and candlestick charts, for various companies. Leveraging the yfinance library, the app fetches historical stock data and presents it in an interactive and user-friendly manner. Users can select a company from a dropdown menu, view different metrics, and analyze performance metrics such as returns, volatility, and Sharpe ratio. With its intuitive interface and insightful visualizations, this project serves as a valuable tool for investors and enthusiasts alike to track and analyze stock market trends.
* Day 24: Quality Of Wine [Kaggle](https://www.kaggle.com/datasets/uciml/red-wine-quality-cortez-et-al-2009)
  * Exploring the quality of wine dataset from Kaggle, I aim to analyze factors influencing the quality of red wine. Leveraging data analysis and visualization techniques, I seek to uncover patterns and relationships among various chemical properties and wine quality ratings. By applying machine learning algorithms, I intend to develop predictive models to classify wine quality based on its attributes. This project provides insights into the intricate world of wine quality assessment and demonstrates the application of data science in the domain of viticulture. Cheers to discovering the essence of fine wine! üç∑üìä
* Day 25: Extract Dominant Colors
  * In this project, I'll delve into the fascinating realm of image processing to extract the dominant colors from images. Utilizing Python libraries such as ColorThief and Matplotlib, I'll develop a script capable of identifying the primary colors present in an image. By analyzing color palettes and visualizing dominant hues, this endeavor aims to provide insights into the aesthetic composition of images. Join me as I explore the vibrant spectrum of colors and uncover the beauty hidden within digital imagery. üé®üñºÔ∏è
* Day 26: Tree Node
  * On day 26, I focused on the implementation of a fundamental data structure, the tree node. Through Python, I constructed a TreeNode class capable of representing nodes within a binary search tree. With the aid of methods like insertion and various traversal techniques (preorder, inorder, and postorder), I delved into the intricacies of managing and navigating through binary trees. This exploration lays the groundwork for comprehending more complex tree-based algorithms and data structures, providing a solid foundation for further study in computer science and programming. üå≥üîç
* Day 27: ML with FastAPI
  * Today we learn how to easily turn machine learning models into usable APIs using FastAPI in Python.
* Day 28: Tutorial Guide (Python Types Intro) [FastAPI](https://fastapi.tiangolo.com/python-types/)
  * On day 28, we delve into an essential aspect of Python programming - types. This tutorial guide provides an introduction to Python types, focusing particularly on their usage within the FastAPI framework. Understanding Python types is crucial for developing robust and maintainable code, and integrating this knowledge with FastAPI facilitates the creation of efficient and scalable web APIs. By exploring the intricacies of Python types within the context of FastAPI, we equip ourselves with powerful tools for building robust and type-safe applications. üêç‚ú®
* Day 29: Parking Space Counter
  * We implemented a parking space counter application using Python and OpenCV. This project enables users to define parking spaces on an image, count full and empty parking spots, and visualize the counts in real-time. The application leverages computer vision techniques to identify parking space boundaries and utilizes event handling to interactively mark full and empty spaces. This project serves as a practical example of applying Python and OpenCV for image processing and computer vision tasks, demonstrating their utility in real-world applications such as parking management systems. üÖøÔ∏èüöóüÖøÔ∏è
* Day 30: [TensorFlow](https://www.tensorflow.org/tutorials/keras/classification) Guide (Beginner ~ ML Basics with Keras)
  * Explore the fundamentals of machine learning with TensorFlow and Keras in this beginner's guide. This guide provides a comprehensive overview of TensorFlow, a powerful open-source machine learning framework developed by Google. Through practical examples and step-by-step tutorials, you'll learn how to build and train neural networks using Keras, a high-level neural networks API that runs on top of TensorFlow. From basic concepts to hands-on implementation, this guide is designed to introduce you to the essentials of machine learning and empower you to start building your own ML models with TensorFlow and Keras. ü§ñüìöüîç
* Day 31: Spam Emails Dataset [Kaggle](https://www.kaggle.com/datasets/venky73/spam-mails-dataset/code)
  * We explored a Spam Emails Dataset available on Kaggle. This dataset contains a collection of emails labeled as spam or ham (not spam). Leveraging this dataset, we embarked on a data analysis and preprocessing journey using Python and pandas. Through this process, we gained insights into the structure of the data and performed necessary preprocessing steps to prepare it for machine learning tasks. By delving into real-world data and preparing it for analysis, we honed our data manipulation and preprocessing skills, essential for any data science or machine learning project. üìßüîçüõ†Ô∏è
* Day 32: Dijkstra's Algorithm Implementation
  * We implemented the Dijkstra algorithm, which is a design algorithm used to find the shortest path between nodes in a graph. The implementation is made in Python and uses a linear array to precisely search the graph and calculate the shortest distance from the starting point to all other points. Dijkstra's algorithm is widely used in a variety of applications, including network protocol routing  and  video game routing. By applying this algorithm, we increased 's design understanding  and strengthened our algorithmic problem-solving skills. üìàüîçüí°
* Day 33: Technical Test "Add Two Numbers" and "FizzBuzz" [LeetCode](https://leetcode.com/problems/)
  * Add Two Numbers: We tackled the "Add Two Numbers" problem from LeetCode, which involves adding two non-empty linked lists representing non-negative integers. The digits are stored in reverse order, and each node contains a single digit. We implemented a Python solution that traverses both linked lists simultaneously, summing the corresponding digits and handling any carry. This problem enhances our understanding of linked list manipulation and problem-solving skills.
  [Problem Description](https://leetcode.com/problems/add-two-numbers/description/?source=submission-ac)
  
  * FizzBuzz: The second problem we solved was "FizzBuzz," also from LeetCode. This classic programming problem requires generating the FizzBuzz sequence up to a given number. We crafted a Python solution that iterates through the numbers from 1 to the given number, appending "Fizz" for multiples of 3, "Buzz" for multiples of 5, "FizzBuzz" for multiples of both 3 and 5, and the number itself if none of the conditions are met. This exercise reinforces our ability to write concise and efficient code to solve common programming challenges.
  [Problem Description](https://leetcode.com/problems/fizz-buzz/description/)
* Day 34: Quicksort
  * We implemented Quicksort, a divide-and-conquer algorithm used for sorting arrays or lists. Quicksort selects a pivot element, partitions the other elements into two sub-arrays based on whether they are less than or greater than the pivot, and recursively sorts the sub-arrays. Known for its efficiency, Quicksort is often used as a benchmark for comparison with other sorting algorithms, enhancing our understanding of algorithmic efficiency and problem-solving skills. üîÑüìäüîç
* Day 35: Live Weather Forecast Flask App
  * In today's project, we'll develop a live weather forecast Flask app. This app will take a city name as input and provide various weather characteristics such as temperature in Celsius and Fahrenheit, humidity, wind speed, and more.
* Day 36: Random Passwords Generator
  * Today, we created a Random Passwords Generator program. This program prompts the user to specify the desired length of the password and generates a strong password consisting of a mix of lowercase and uppercase letters, digits, and special characters. Additionally, we implemented a function to save the generated passwords to a CSV file for later use. This project enhances our understanding of string manipulation, random number generation, and file handling in Python, while also providing practical utility by creating a tool for generating secure passwords. üîíüí°üíª
* Day 37: Site Connectivity Checker
  * Today, we developed a Site Connectivity Checker application using Flask. This application allows users to input a URL and checks its connectivity by sending a request to the specified website. We enhanced the functionality by adding URL validation, error handling for various connection issues, and logging of activity to track the status of site connections over time. By building this project, we gained practical experience in web development with Flask, handling HTTP requests, error management, and logging, all of which are essential skills for creating robust web applications. üåêüîçüöÄ
* Day 38: Heart Attack Analysis & Prediction Dataset [Kaggle](https://www.kaggle.com/datasets/rashikrahmanpritom/heart-attack-analysis-prediction-dataset/data)
  * We explored the Heart Attack Analysis & Prediction Dataset available on Kaggle. This dataset provides valuable insights into factors contributing to heart attacks and includes various health parameters such as age, sex, cholesterol levels, blood pressure, and more. By analyzing this dataset, we aim to gain a deeper understanding of the relationships between different risk factors and the likelihood of a heart attack occurrence. Leveraging statistical analysis and machine learning techniques, we strive to develop predictive models that can assist in early detection and prevention efforts for cardiovascular diseases. This project underscores the importance of data-driven approaches in healthcare and reinforces our skills in data analysis, predictive modeling, and domain knowledge application. ‚ù§Ô∏èüìäüî¨
* Day 39: [TensorFlow](https://www.tensorflow.org/tutorials/keras/classification) Guide Basic text Classification (Beginner ~ ML Basics with Keras)
  * Continuing from Day 30, delve deeper into machine learning with TensorFlow and Keras by exploring basic text classification. In this guide, you'll learn how to apply machine learning concepts to classify text data using TensorFlow and Keras. By following step-by-step tutorials and practical examples, you'll understand the fundamentals of text classification, including preprocessing text data, building neural network models, and evaluating model performance. Whether you're new to machine learning or looking to expand your knowledge, this guide provides valuable insights and hands-on experience to enhance your skills in natural language processing and text classification tasks. ü§ñüìöüîç
* Day 40: Technical Test "Minimum Height Trees" and "Zigzag Conversion" [LeetCode](https://leetcode.com/problems/)
  * Minimum Height Trees: Today, we encountered the "Minimum Height Trees" problem on LeetCode. This problem revolves around identifying the roots of minimum height trees in an undirected graph, given the number of nodes and an array of edges representing connections between nodes. We crafted a Python solution employing graph traversal and manipulation techniques to determine the roots with minimum height efficiently. This challenge enhances our ability to work with graphs, analyze graph structures, and devise optimal algorithms for graph-related problems. [Problem Description](https://leetcode.com/problems/minimum-height-trees/description/)
  * Zigzag Conversion: In addition, we tackled the "Zigzag Conversion" problem on LeetCode. This problem involves converting a given string into a zigzag pattern with a specified number of rows and then reading the string line by line. We devised a Python solution that constructs the zigzag pattern by iteratively placing characters in the appropriate rows, simulating the pattern formation and reading process. Solving this problem reinforces our understanding of string manipulation techniques and enhances our problem-solving skills in handling complex pattern-based challenges. [Problem Description](https://leetcode.com/problems/zigzag-conversion/description/)
* Day 41: Tkinter - Map View
  * Explore Tkinter's capabilities in displaying interactive maps with the Tkinter MapView project. This Tkinter-based application allows users to visualize maps, search for addresses, and adjust zoom levels seamlessly within a GUI interface. By integrating functionalities such as address lookup, zoom control, and map display, this project showcases the potential of Tkinter for creating dynamic and user-friendly applications. Dive into the world of Tkinter and enhance your skills in GUI development with the MapView project. üó∫Ô∏èüñ•Ô∏èüîç
* Day 42: Tkinter - Digital Clock
  * Explore the world of GUI development with Tkinter by creating a digital clock application. In this project, I utilized Tkinter's functionalities to design an attractive and functional digital clock interface. By leveraging Python's time module and Tkinter's Label widget, I implemented a dynamic clock display that updates in real-time. Join me as I continue to delve into Tkinter and expand my skills in creating intuitive and visually appealing graphical user interfaces. ‚è∞üñ•Ô∏èüîß
* Day 43: PySpark (Quickstart: DataFrame)[https://spark.apache.org/docs/3.3.1/api/python/getting_started/quickstart_df.html]
  * Dive into the world of big data processing with PySpark as we explore the Quickstart guide for DataFrames. PySpark is a powerful tool for processing large-scale datasets using the Apache Spark framework. In this project, we'll delve into the basics of working with DataFrames, a distributed collection of data organized into named columns. By following the Quickstart guide, we'll learn how to create, manipulate, and analyze DataFrames efficiently. Join me on this journey as we harness the power of PySpark to tackle big data challenges with ease and scalability. üöÄüíªüîç
* Day 44: Daily Routine with Desktop Notifications
  * In this project, I crafted a personalized daily routine assistant utilizing desktop notifications. Leveraging Python libraries such as `win10toast` and `schedule`, I created a system that sends timely notifications for various activities throughout the day. Whether it's studying English, working on Python projects, taking short breaks, or even enjoying a joke break, this routine keeps me organized and on track. By scheduling notifications at specific times using the schedule module, I ensure I stay productive and maintain a healthy balance between work and relaxation. Join me as I automate my daily routine and optimize my productivity with desktop notifications! üìÖ‚è∞üñ•Ô∏è
* Day 45: Language Detection
  * Enhancing my text processing capabilities, I delved into language detection. Leveraging the langdetect and langcodes libraries in Python, I developed a program capable of identifying the language of input text. By utilizing the powerful language detection algorithms provided by these libraries, I crafted a user-friendly interface using Tkinter. This project allows users to input text and receive instant feedback on the detected language, aiding in various applications such as multilingual text analysis, translation services, and content filtering. Join me as I explore the fascinating world of language detection and broaden the scope of text processing possibilities! üåêüîçüìù
* Day 46: Technical Test "MedianSortedArrays" and "lengthOfLongestSubstring" [LeetCode](https://leetcode.com/problems/)
  * MedianSortedArrays: Today, we encountered the "Median of Two Sorted Arrays" problem on LeetCode. This problem involves finding the median of two sorted arrays, which are of different sizes, m and n. The challenge is to achieve a time complexity of O(log(m+n)). We tackled this problem by employing the binary search approach. By partitioning the arrays and comparing elements at partition points, we efficiently determine the median. Solving this problem enhances our understanding of algorithmic complexity and binary search techniques, crucial for tackling similar problems efficiently. [Problem Description](https://leetcode.com/problems/median-of-two-sorted-arrays/)

  * lengthOfLongestSubstring: In addition, we tackled the "Longest Substring Without Repeating Characters" problem on LeetCode. This problem requires finding the length of the longest substring within a given string that does not contain any repeating characters. We approached this problem using a sliding window technique, which allows us to efficiently traverse the string while keeping track of the characters encountered. By updating the window's boundaries based on repeating characters, we determine the longest substring without repetition. Solving this problem enhances our understanding of string manipulation and sliding window algorithms, essential for solving various string-related challenges. [Problem Description](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)
* Day 47: Currency Converter
  * Today, I embarked on a journey to create a currency converter application using Python. Leveraging the tkinter library for graphical user interface (GUI) development and the forex_python library for currency conversion functionality, I crafted a simple yet effective tool for converting between different currencies. This project involved setting up dropdown menus for selecting the source and target currencies, implementing an entry widget for inputting the amount to convert, and integrating a button to trigger the conversion process. By handling exceptions and displaying conversion results dynamically, I ensured a smooth user experience. Join me as I explore the world of currency conversion and develop a handy tool for everyday use! üí±üíºüîÄ
* Day 48: Perceptron
  * In today's project, I delved into the world of artificial neural networks by implementing a perceptron from scratch. The perceptron, a fundamental building block of neural networks, is a simple algorithm capable of learning binary classifiers. Leveraging the NumPy library for numerical operations, I crafted a perceptron class capable of training on labeled datasets and making predictions. By defining the perceptron's architecture, including input features, weights, and activation functions, I gained insight into the inner workings of neural networks. Through iterative training and weight updates based on prediction errors, the perceptron learns to separate linearly separable classes in feature space. This project serves as a foundational step towards understanding more complex neural network architectures and their applications in machine learning and artificial intelligence. Join me as I explore the basic principles of neural networks and implement a perceptron algorithm from scratch! üß†üíªü§ñ
* Day 49: Technical Test "Reverse Integer" and "Longest Palindromic Substring" [LeetCode](https://leetcode.com/problems/)
  * Today's technical challenge involves the "Reverse Integer" problem on LeetCode. This problem requires reversing the digits of a signed 32-bit integer. If the reversed integer overflows, the function should return 0. We'll tackle this problem by implementing a solution that handles both positive and negative integers, considering overflow conditions carefully. Solving this problem enhances our skills in handling numerical operations and edge cases effectively. [Problem Description](https://leetcode.com/problems/reverse-integer/description/)
  * "Longest Palindromic Substring": Additionally, we'll tackle the "Longest Palindromic Substring" problem on LeetCode. This problem involves finding the longest palindromic substring within a given string. We'll devise an algorithm to efficiently determine the longest palindrome, leveraging techniques such as dynamic programming or expanding around centers. By addressing this challenge, we deepen our understanding of string manipulation and algorithmic problem-solving strategies. [Problem Description](https://leetcode.com/problems/longest-palindromic-substring/description/)
* Day 50: Students Performance in Exams [Kaggle](https://www.kaggle.com/datasets/whenamancodes/students-performance-in-exams/data)
  * Today, we delve into the realm of educational data analysis by exploring a student performance dataset from Kaggle. This dataset offers valuable insights into factors that may influence student achievement in exams. By delving into this data, we can uncover patterns, trends, and relationships that can inform educational practices and improve student learning outcomes.
* Day 51: Interactive Menu for YouTube and Web Searches
  * Today's focus is on creating a music player application. Building a music player involves integrating functionalities to play, pause, skip, and control the playback of audio files. Additionally, we'll explore features such as creating playlists, displaying metadata, and providing a user-friendly interface for an immersive music listening experience. By developing a music player, we deepen our understanding of GUI frameworks, multimedia handling, and software design principles.
* Day 52: Task Manager Performance
  * Today's task revolves around analyzing the performance of a task manager application. Task managers play a crucial role in monitoring system resources, managing processes, and optimizing performance. Through this analysis, we aim to evaluate the efficiency, responsiveness, and resource utilization of the task manager under various conditions. By examining performance metrics such as CPU usage, memory consumption, and task responsiveness, we can identify areas for improvement and enhance the overall functionality of the task manager application.
* Day 53: Technical Test "Integer to Roman" and "Container With Most Water" [LeetCode](https://leetcode.com/problems/)
  * Integer to Roman:
    Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M. Implement a function to convert an integer into its corresponding Roman numeral representation.
    Given an integer, convert it to a Roman numeral. [Problem Description](https://leetcode.com/problems/integer-to-roman/)
  * Container With Most Water: You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store. [Problem Description](https://leetcode.com/problems/container-with-most-water/description/)
* Day 54: Background Remove Flask
  * Today's focus is on implementing a background removal functionality within a Flask web application. Background removal is a crucial task in image processing and computer vision, allowing users to isolate subjects from their backgrounds. By integrating this functionality into a web application using Flask, we aim to provide users with a convenient and accessible tool for background removal tasks. Throughout this process, we'll explore techniques for image manipulation, integration of third-party libraries, and web development with Flask. By building a background removal tool, we enhance our understanding of image processing algorithms, web application development, and practical applications of computer vision technology.
* Day 55: Multiple Files Renamer
  * Today's focus is on developing a multiple files renamer application. Renaming multiple files in bulk is a common task, especially when organizing files or preparing them for specific purposes. This application will provide users with the ability to select a folder containing files, specify renaming criteria, and execute the renaming process efficiently. By creating this utility, we aim to streamline file management tasks and enhance productivity for users dealing with large numbers of files. Throughout the development process, we'll explore file handling techniques, user interface design, and implementation of renaming algorithms to ensure a robust and user-friendly application.
* Day 56: Technical Test "threeSum" and "threeSumClosest" [LeetCode](https://leetcode.com/problems/)
  Today's focus is on solving technical problems related to array manipulation and algorithmic thinking. We'll tackle two problems from LeetCode:
  * threeSum: Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j, i != k`, and `j != k, and nums[i] + nums[j] + nums[k] == 0`. The solution set must not contain duplicate triplets. [Problem Description](https://leetcode.com/problems/3sum/description/)
  * threeSumClosest: Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. [Problem Description](https://leetcode.com/problems/3sum-closest/description/)
* Day 57: KeyLogger 
  * Today's focus is on developing a KeyLogger application. A KeyLogger is a program that records the keystrokes made by a user on their computer. It's commonly used for various purposes such as monitoring employee activity, parental control, or debugging software. Our KeyLogger application will capture keystrokes and store them in a log file, providing users with the ability to monitor keyboard activity. Through this project, we'll delve into event handling, file I/O operations, and potentially explore additional features such as email notifications for logged keystrokes, enhancing the utility and versatility of the KeyLogger.
* Day 58: Matrix Effect
  * Today's focus is on creating a Matrix Effect, inspired by the iconic "Matrix" movie. This project involves generating a cascading effect of characters resembling the falling code seen in the film. Through this project, we'll explore concepts such as terminal manipulation, randomization, and animation. By implementing this Matrix Effect, we aim to recreate the visually stunning display seen in the movie, offering a fun and engaging coding exercise.
* Day 59: Dice-Rolling [realpython.com](https://realpython.com/python-dice-roll/#step-1-code-the-tui-of-your-python-dice-rolling-app)
  * Today's focus is on implementing a Dice-Rolling application. This project involves creating a Python program to simulate rolling dice. We'll explore concepts such as random number generation, user input validation, and ASCII art for visual representation of dice faces. Additionally, we'll delve into creating a text-based user interface (TUI) for the application. By developing this Dice-Rolling application, we aim to provide users with a fun and interactive way to simulate rolling dice, suitable for various gaming and recreational purposes.
* Day 60: Technical Test "letterCombinations" and "4Sum" [LeetCode](https://leetcode.com/problems/)
  * **Letter Combinations of a Phone Number**: Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. [Problem Description](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)
  * **4Sum**: Given an array `nums` of n integers, return an array of all the unique quadruplets `[nums[a], nums[b], nums[c], nums[d]]` such that:
     - `0 <= a, b, c, d < n`
     - `a, b, c, and d` are distinct.
     - `nums[a] + nums[b] + nums[c] + nums[d] == target`
  You may return the answer in any order. [Problem Description](https://leetcode.com/problems/4sum/)
* Day 61: Anemia Types Classification [Kaggle](https://www.kaggle.com/datasets/ehababoelnaga/anemia-types-classification/data)
  * Today, we focus on anemia types classification using a dataset from Kaggle. This dataset contains CBC (Complete Blood Count) data labeled with the diagnosis of anemia type, collected from several CBCs and diagnosed manually. By analyzing this dataset, we aim to understand the relationships between CBC parameters and different types of anemia. This analysis can provide valuable insights for medical diagnosis and treatment strategies.
* Day 62: Cinema Management System using OOP
  * Today, we delve into a cinema project focusing on Object-Oriented Programming (OOP). The project involves designing classes to simulate various aspects of a cinema system, including movies, rooms, reservations, and the cinema itself. Through this project, we aim to implement key OOP principles such as encapsulation, inheritance, and polymorphism. By structuring the code in an object-oriented manner, we can create a modular and scalable system that effectively models the functionalities of a real-world cinema. This project provides an excellent opportunity to practice OOP concepts while developing a practical application.
* Day 63: Technical Test "removeNthFromEnd" and "isMatch" [LeetCode](https://leetcode.com/problems/).
  * Today's technical test on LeetCode involves two problems:
  * removeNthFromEnd: Given the head of a linked list, remove the nth node from the end of the list and return its head. This problem challenges your ability to manipulate linked lists efficiently. [Problem Description](https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/)
  * isMatch: Implement regular expression matching with support for '.' and '*', where '.' matches any single character and '*' matches zero or more of the preceding element. The matching should cover the entire input string (not partial). [Problem Description](https://leetcode.com/problems/regular-expression-matching/description/).
  
  These problems test your proficiency in data structures and algorithms, particularly in linked list manipulation and dynamic programming. Working on them will enhance your problem-solving skills and algorithmic thinking.
* Day 64: Contour Plots in Matplotlib - Visualize 3D Functions in 2D [NeuralNine](https://www.youtube.com/watch?v=DYn9HdTmt0E)
  * In today's session, we explore how to create contour plots in Matplotlib, a powerful visualization tool in Python. Contour plots allow us to represent 3D functions in 2D, providing a clear view of the function's behavior over a plane. We will generate 2D grids using `numpy.meshgrid` and define various 3D functions to visualize. The session includes creating both surface plots and filled contour plots using Matplotlib's `plot_surface` and `contourf` functions, respectively. This exercise will help you understand how to effectively visualize complex functions, enhancing your data presentation skills and making your plots more informative and visually appealing.
* Day 65: Technical Test "isValidParentheses" and "MergeTwoSortedLists" [LeetCode](https://leetcode.com/problems/).
  * isValidParentheses: Given a string `s` containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if:
      * Open brackets must be closed by the same type of brackets.
      * Open brackets must be closed in the correct order.
      * Every close bracket has a corresponding open bracket of the same type. 
      [Problem Description](https://leetcode.com/problems/valid-parentheses/description/)
  * MergeTwoSortedLists: Given the heads of two sorted linked lists `list1` and `list2`, merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. [Problem Description](https://leetcode.com/problems/merge-two-sorted-lists/description/)
* Day 66: Web Scraping Job Listings with Python
  * In today's session, we delve into the world of web scraping using Python. Our goal is to extract job listings from the Python.org jobs page and save the data into a CSV file. We will use the `requests` library to fetch the HTML content of the webpage and `BeautifulSoup` for parsing the HTML and extracting the job details. The details we will extract include the job title, company name, location, posting date, and job type. After extracting the data, we will write it into a CSV file using Python's `csv` module. This exercise will enhance your skills in web scraping, data extraction, and handling CSV files, providing a practical approach to gather and organize data from web sources.
* Day 67: [TensorFlow](https://www.tensorflow.org/tutorials/keras/regression) Regression (Beginner ~ ML Basics with Keras)
  * Today, we embark on a journey into the basics of regression analysis using TensorFlow and Keras. This tutorial covers the essential steps to build, train, and evaluate regression models. We will start by loading and cleaning the Auto MPG dataset, which includes features like 'Horsepower', 'Weight', and 'Acceleration'. After preprocessing the data, we'll split it into training and testing sets, and normalize it to improve model performance. You'll learn how to construct simple linear regression models, first with a single input and then with multiple inputs. Furthermore, we'll explore more complex models using deep neural networks (DNNs). This hands-on guide will help you understand the fundamentals of regression analysis, model training, evaluation, and making predictions, providing a strong foundation in machine learning with TensorFlow and Keras. üöóüìàü§ñ
* Day 68: Recursion "SierpinskiTriangle" and "FractalTree".
  * On day 68, we explore the concept of recursion through the creation of two classic fractals: the Sierpinski Triangle and the Fractal Tree. Both examples utilize Python's turtle graphics library to visualize the recursive processes.
    * Sierpinski Triangle: This fractal is formed by recursively subdividing an equilateral triangle into smaller triangles. Each subdivision step reduces the size of the triangles and changes their color based on the recursion depth. This exercise helps in understanding how recursion can break down complex problems into simpler, repeatable tasks.
    * Fractal Tree: This fractal simulates the natural growth patterns of a tree. Starting with a trunk, the tree branches into smaller sub-branches, each at a specific angle and length decrement. By adjusting the recursion depth, angle, and length decrement, different tree shapes and complexities can be generated. This project emphasizes the power of recursion in modeling natural phenomena and visualizing algorithmic patterns.
* Day 69: Ticket management GUI
  * On day 69, we delve into building a web-based Ticket Management System using Flask. This project includes two primary interfaces: one for clients to generate tickets for order claims, and another for providers to manage and track the tickets. The client-side allows users to enter their name, generate a ticket with a unique number, and record the time of generation. The provider-side interface displays the next ticket in the queue along with the current ticket being attended to and which counter is handling it. This system demonstrates the basics of web development with Flask, including form handling, data storage, and dynamic content rendering. By completing this project, you will gain practical experience in creating web applications, managing state, and ensuring smooth interactions between different user roles. üßæüñ•Ô∏è‚ú®
* Day 70: Scientific GUI Calculator
  * On day 70, we constructed a Graphical User Interface (GUI) for a scientific calculator using the tkinter library in Python. This calculator provides a wide range of mathematical functions, including basic arithmetic operations, trigonometric functions, logarithmic functions, and more. Users can input numerical values, perform calculations, and view results conveniently through the intuitive interface. The calculator's design incorporates various buttons for different mathematical operations, making it easy to use and navigate. By creating this project, you will enhance your skills in GUI development, event handling, and integrating complex mathematical operations into user-friendly applications. üßÆüíªüîç
* Day 71: Technical Test "generateParenthesis" and "mergeKLists" [LeetCode](https://leetcode.com/problems/).
  * generateParenthesis: Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
  [Problem Description](https://leetcode.com/problems/generate-parentheses/description/)
  * mergeKLists: You are given an array of `k` linked-lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.[Problem Description](https://leetcode.com/problems/merge-k-sorted-lists/description/)
* Day 72: Knight's Tour Problem Solver
  * On day 72, we explore the classic Knight's Tour problem using Python. This project involves developing an algorithm to find a sequence of moves that allows a knight to visit every square on an N x N chessboard exactly once. The solution employs backtracking to systematically search for a valid tour, ensuring that all board positions are covered without repetition. The implementation includes functions to validate moves, print the board, and recursively attempt to solve the tour from a given starting position. By tackling this problem, you will gain a deeper understanding of recursion, backtracking, and algorithmic problem-solving. This project is an excellent exercise in enhancing your skills in algorithm development and Python programming. ‚ôûüìêüí°
* Day 73: Tic-Tac-Toe Multiplayer [NeuralNine](https://youtu.be/s6HOPw_5XuY?si=ZlnrpRTxmJiYtGv8)
  * On day 73, we developed a multiplayer Tic-Tac-Toe game using Python. This project allows two players to connect over a network and play Tic-Tac-Toe in real-time. One player hosts the game, while the other player connects to it. The implementation includes setting up a server-client architecture using the socket library and managing game state and turns through a combination of functions for move validation, board updates, and win condition checks. The game uses threading to handle simultaneous communication between players. By completing this project, you will enhance your understanding of network programming, client-server communication, and basic game development in Python. üéÆüïπÔ∏èüíª
* Day 74: Technical Test "twoSum" and "myAtoi" [LeetCode](https://leetcode.com/problems/).
  * twoSum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.
  [Problem Description](https://leetcode.com/problems/two-sum/description/)
  * myAtoi: Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer. The function follows a specific algorithm to ignore leading whitespace, determine the sign, read digits, and handle integer overflow by clamping the result within the 32-bit signed integer range.
  [Problem Description](https://leetcode.com/problems/string-to-integer-atoi/description/)
* Day 75: Spotify Songs Album [Kaggle](https://www.kaggle.com/datasets/zeesolver/spotfy/data)
  * Today, we embark on a journey into the realm of music data analysis with a dataset sourced from Kaggle, focusing on Spotify songs albums. This dataset provides a comprehensive collection of information about various songs, including attributes such as danceability, energy, and acousticness. By delving into this dataset, we aim to uncover intriguing insights into the characteristics of popular songs, trends in music streaming, and the impact of different attributes on song popularity. Through exploratory data analysis and visualization techniques, we will unravel patterns, correlations, and unique features within the dataset, shedding light on the dynamic landscape of the music industry. Join us as we dissect this rich dataset to discover the rhythms and melodies that shape our musical experiences.
* Day 76: Bank Queue Management System
  * Today, we delve into the development of a robust bank queue management system designed for "Su ahorrito". This system aims to streamline the process of managing customer service operations, focusing on assigning and managing customer turns efficiently. Our system encompasses several key functionalities:
    - User Management: Create and manage user profiles, including user ID, name, and client type (General, Preferential1, Preferential2).
    - Turn Assignment: Automatically assign turns to users, categorizing each turn with a specific transaction type (Deposit, Withdrawal, Bill Payment).
    - Customer Service: Facilitate the process of attending to customers, ensuring that completed transactions are recorded and stored systematically.
    - Transaction Analysis: Calculate and display the percentage distribution of different transaction types, providing insights into customer needs and service trends.
    - Turn Management: Enable the removal of specific turns and display the number of turns assigned to each user.
    - Transaction History: Maintain and showcase a history of all completed transactions, ensuring transparency and record-keeping.
Through this project, we aim to enhance the efficiency of customer service in a banking environment by leveraging Python to build an intuitive and effective queue management system. Join us as we implement and explore this essential application, ensuring a smoother experience for both bank staff and customers.
* Day 77: Inventory Management GUI
Today, we embarked on the development of a Graphical User Interface (GUI) for an Inventory Management System. Leveraging the Flask web framework in Python, we crafted an intuitive interface that enables users to efficiently manage their inventory of products. The system offers a range of features to enhance inventory control and streamline operations, including:
  - **Product Management:** Users can easily add, edit, and delete products from the inventory, facilitating seamless product catalog management.
  - **Real-time Inventory Monitoring:** The application provides a comprehensive view of the current inventory status, allowing users to track product quantities and make informed decisions.
  - **Report Generation:** With built-in reporting capabilities, users can generate detailed reports on inventory status, product performance, and more, empowering data-driven decision-making.
  - **Low Stock Alerts:** The system automatically alerts users to products with low stock levels, helping prevent stockouts and optimize inventory replenishment.
  - **Data Export:** Users can export inventory data to CSV or Excel formats for further analysis or integration with external systems.

  By developing this Inventory Management GUI, we aimed to provide businesses with a powerful tool to effectively manage their inventory, improve efficiency, and optimize resource utilization. Join us as we continue to explore the intersection of technology and business operations, empowering organizations to thrive in today's dynamic marketplace. üì¶üíªüìä
* Day 78: Technical Test "swapPairs" and "reverseKGroup" [LeetCode](https://leetcode.com/problems/).
  * swapPairs: Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed) [Problem Description](https://leetcode.com/problems/swap-nodes-in-pairs/description/)
  * reverseKGroup: Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k, then the left-out nodes at the end should remain as they are. You may not alter the values in the list's nodes, only nodes themselves may be changed. [Problem Description](https://leetcode.com/problems/reverse-nodes-in-k-group/description/)
* Day 79: Minesweeper GUI Pygame
  * Today, we're diving into the development of a Minesweeper game with a Graphical User Interface (GUI) using Pygame. This classic game challenges players to uncover hidden mines on a grid-based board without detonating any of them. Our implementation leverages Pygame's intuitive interface to provide an engaging and immersive gaming experience. Players can reveal tiles, flag potential mines, and navigate through various difficulty levels or customize their game settings. Join us as we explore the world of game development with Python and Pygame, bringing the timeless excitement of Minesweeper to life in a modern and visually appealing format. üïπÔ∏èüí£üéÆ
* Day 80: Student Practice Management System
  * Today, we developed a Python-based system to manage student internships. This system features:
    - **Practice Registration**: Capture student details, company name, and practice duration.
    - **Internship Tracking**: Monitor ongoing practices with detailed views.
    - **Average Duration Calculation**: Display the average length of internships.
    - **Company-Specific Intern Count**: Determine the number of interns per company.
    - **Company Update for Practices**: Modify the company associated with a student's practice.
    - **User-Friendly Menu Interface**: Easily navigate and interact with the system.

  This system aims to streamline the management of student internships, benefiting both students and administrators. üéìüè¢üìä
* Day 81: Random Roulette
  * Today, we're building a Random Roulette web application using Flask. This app allows users to add and modify options for the roulette, and then spin to select a random option. With Flask's lightweight and flexible framework, we'll create an interactive and dynamic web interface where users can easily manage their options. The application features a simple design with an intuitive navigation system, ensuring a seamless user experience. Join us as we delve into web development with Flask, creating a fun and functional tool for making random selections. üé°üîÑ‚ú®
* Day 82: Test Projects "celsius_to_fahrenheit"
  * Today, we're focusing on writing unit tests for a simple function that converts temperatures from Celsius to Fahrenheit. Testing is a crucial part of software development, ensuring that our code works as expected and helps prevent bugs from creeping into our projects. We'll use Python's unittest module to create and run our tests. This exercise will help you understand the basics of writing tests and how to use them to verify the correctness of your code.
* Day 83: Technical Test "removeDuplicates" and "removeElement" [LeetCode](https://leetcode.com/problems/).
  * removeDuplicates: Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums. [Problem Description](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)
  * removeElement: Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val. [Problem Description](https://leetcode.com/problems/remove-element/description/)
* Day 84: Complaint Management System
  * Today, we developed a Python-based system to manage complaints for the General Prosecutor's Office. This system features:
    - **Complaint Creation**: Record details such as complainant, accused, date, type, and unique code.
    - **Complaint Deletion**: Remove complaints using a unique code.
    - **Sublist Creation**: Generate a sublist of complaints involving a specific person.
    - **Type-Based Percentage Calculation**: Calculate the percentage of each type of complaint.
    - **Complaint Display**: Show all registered complaints.
    - **Date Modification**: Update the date of a specific complaint.
    - **User-Friendly Menu Interface**: Easily navigate and interact with the system.

  This system is designed to streamline the management of complaints, making it easier for the General Prosecutor's Office to handle and organize them effectively. üìÖüìùüîç
* Day 85: Convert Word Files To PDF [NeuralNine](https://www.youtube.com/watch?v=i57uYpW5Ng8)
  * Today, we worked on a project to convert Word files (.docx) to PDF format. This project was inspired by a video tutorial from NeuralNine. While the tutorial provided the basic functionality for converting a single DOCX file to PDF, we expanded the project by adding several new features:
    - **Graphical User Interface (GUI)**: Using `tkinter`, we created an intuitive interface that allows users to easily select files and specify output options.
    - **Single File Conversion**: Users can convert a single DOCX file to PDF by selecting the file and choosing a destination.
    - **Multiple File Conversion**: Users can select multiple DOCX files and convert them all to PDF at once, saving the converted files in a specified directory.
    - **Error Handling**: The application includes robust error handling to inform users of any issues during the conversion process.
    - **User Notifications**: After a successful conversion, the application provides a notification to the user.
    
  These enhancements make the tool more user-friendly and versatile, offering a complete solution for converting Word documents to PDF efficiently.

* Day 86: Goldner-Harary Graph in 3D
  * Today, we explored the fascinating world of graph theory by creating and visualizing the Goldner-Harary graph in 3D. This project helped us understand the properties of planar graphs and verify Euler's formula. Here are the key features and steps we implemented:
    - **Graph Construction**: We created the Goldner-Harary graph, which consists of 11 vertices and 27 edges.
    - **3D Visualization**: Using `matplotlib` and `networkx`, we plotted the graph in a 3D space, providing a comprehensive visual representation of its structure.
    - **Planarity Check**: We verified the graph's planarity, confirming that it can be drawn on a plane without any edges crossing.
    - **Euler's Formula Verification**: We checked Euler's formula (v - e + f = 2) for the graph, ensuring it holds true for planar graphs.
    - **Graph Information**: We displayed essential information about the graph, including the number of vertices, edges, and faces.
    
  This project not only enhanced our understanding of graph theory but also provided practical experience with 3D data visualization techniques. The Goldner-Harary graph, with its complex structure, served as an excellent example for studying planar graphs and their properties. üåêüìäüîç
* Day 87: Building Management System
  * Today, we developed a Python-based Building Management System. This system offers functionalities such as generating invoices, making payments, and tracking property ownership. Key features include:
    - **Invoice Generation**: Automatically generate monthly invoices for property owners.
    - **Payment Processing**: Record and manage payments made by proprietors.
    - **Account Statements**: Generate account statements for proprietors, detailing payments and dues.
    - **Delinquency Monitoring**: Identify delinquent apartments based on overdue balances.
    
  This system streamlines property management tasks, enhancing efficiency and organization. üè¢üíºüí∞
* Day 88: Technical Test "strStr" and "divide" [LeetCode](https://leetcode.com/problems/).
  * strStr: Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. This classic problem tests your ability to efficiently search substrings within a larger string. [Problem Description](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)
  * divide: Given two integers, dividend and divisor, divide them without using multiplication, division, and mod operator. Ensure the result is truncated toward zero. This problem challenges you to implement efficient division using basic arithmetic operations. [Problem Description](https://leetcode.com/problems/divide-two-integers/description/)
* Day 89: Dragon Ball Radar Animation with DBSCAN Clustering
  * Today, we crafted an animated Dragon Ball radar using Python, leveraging DBSCAN clustering to detect clusters of Dragon Balls. Here's a breakdown of what we accomplished:
    - **Radar Animation**: We animated a radar line sweeping through 360 degrees, simulating the iconic Dragon Ball radar from the anime series.
    - **DBSCAN Clustering**: Utilizing the DBSCAN algorithm, we clustered randomly generated Dragon Ball positions, mimicking their distribution across the radar's range.
    - **Cluster Visualization**: Each cluster of Dragon Balls was represented by a yellow point on the radar, with the number of Dragon Balls in each cluster displayed alongside.
    - **Interactive Animation**: The animation included blinking points and text to add dynamism and visual appeal to the radar display.

  This project blends entertainment with data science, offering a playful yet educational exploration of clustering algorithms and animated visualizations. üêâüîç‚ú®
* Day 90: Pong Game Development in Python
  * Today, we developed a classic Pong game using Python and the Pygame library. Here's a summary of our progress:
    - **Game Mechanics**: We implemented the basic mechanics of Pong, including ball movement, paddle control, and collision detection.
    - **Scoring System**: A scoring system was added, with the game ending when a player reaches 5 points. The score is displayed on the screen, and a winning message is shown at the end.
    - **Paddle Customization**: The paddles were given distinct colors (red for the left paddle and blue for the right paddle) to enhance the visual appeal.
    - **Smooth Animation**: The game runs smoothly at 60 frames per second, providing a responsive and enjoyable gaming experience.

  This project demonstrates the fundamentals of game development in Python, showcasing the power and flexibility of Pygame for creating interactive applications. üéÆüöÄ‚ú®
* Day 91: Flask-based Online Survey Application
  Today, we created a Flask-based Online Survey Application. This project allows users to create surveys and participate in them. Key functionalities include:

    - **Survey Creation**: Users can create new surveys with customizable options.
    - **Survey Participation**: Other users can vote in existing surveys.
    - **Results Display**: The application displays results for each survey, showing the distribution of votes.
    
  This project aims to provide a straightforward platform for conducting surveys online, enhancing user engagement and feedback collection. üìäüñ•Ô∏è‚úÖ
* Day 92: Tower of Hanoi and N Queens Problem Solutions
  * Today, we implemented solutions to the classic Tower of Hanoi and N Queens problems in Python. Here's a summary of our progress:
    - **Tower of Hanoi**: We developed a recursive function to solve the Tower of Hanoi problem, which involves moving disks from one peg to another according to specific rules. The function efficiently moves disks from the source peg to the target peg using an auxiliary peg.
    - **N Queens Problem**: We implemented a backtracking algorithm to solve the N Queens problem, which involves placing N queens on an NxN chessboard such that no queen attacks another. The algorithm ensures that each queen is placed safely by checking for conflicts with other queens in the same row, column, or diagonal.

  These projects demonstrate the power of Python for solving complex problems and the importance of recursion and backtracking in solving these types of problems. üéØüëë

* Day 93: Word Search Puzzle GUI
  * Today, we created a graphical user interface (GUI) for a word search puzzle using Python's Tkinter library. Here's an overview of what we accomplished:
    - **Word Entry**: We added an input field for users to enter words (comma-separated) which will be hidden in the word search grid.
    - **Grid Generation**: We implemented a function to generate a grid filled with random letters, ensuring that the words are placed in random directions (horizontal, vertical, diagonal).
    - **Word Selection**: We enabled cell selection in the grid. Selected cells highlight in yellow until a word is completely formed. If the word is valid, the cells change to green, indicating that the word has been found. If not, the cells revert to their original state.
    - **Word List Display**: The words are displayed on the right side of the interface. Found words are struck through.
    - **Timer**: We added a configurable timer (5 to 10 minutes) that counts down. If the user doesn't find all the words within the time limit, a message prompts them to try again.
    - **Solve Button**: A centrally placed "Solve" button highlights all the words in the grid, assisting the user in finding the words.
    - **Completion and Reset**: Upon finding all the words or the timer running out, the user is prompted to play again, allowing the game to reset.

  This project demonstrates the integration of Python with Tkinter to create interactive applications, enhancing user experience and interface design. üß©üïπÔ∏è

* Day 94: Technical Test "findSubstring" and "nextPermutation" [LeetCode](https://leetcode.com/problems/).
  * findSubstring: Given a string `s` and an array of strings `words`, find all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once and without any intervening characters. [Problem Description](https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/)
  * nextPermutation: Implement the next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order). The replacement must be in place and use only constant extra memory. [Problem Description](https://leetcode.com/problems/next-permutation/description/)
* Day 95: PhishGuard - Anti-Phishing Email and Website Filter
  * Today, we developed a phishing protection filter called **PhishGuard** using Python. Here's an overview of what we accomplished:
    - **Keyword Detection**: Implemented a function to identify phishing keywords in email content.
    - **URL Analysis**: Extracted and analyzed URLs from emails, checking them against a list of known phishing domains.
    - **Email Filtering**: Created a filter to process a list of emails, blocking those identified as phishing attempts.
    - **Hotmail Example**: Tested the filter with example Hotmail emails to demonstrate its effectiveness.
      
  This project highlights how Python can be used to enhance email security by detecting and blocking potential phishing attacks. üõ°Ô∏èüìß
* Day 96: World Clock GUI
  * Today, we developed a **World Clock GUI** using Python and Tkinter. Here's an overview of what we accomplished:
    - **Time Zone Updates**: Implemented a function to update and display the current time for multiple time zones including Colombia, New York, China, Germany, and Norway.
    - **GUI Design**: Created a user-friendly graphical interface with labeled clocks for each time zone, enhancing the visual appeal and usability.
    - **Icon and Flags**: Added an application icon and country flags to represent each time zone, providing a clear and engaging visual representation.
    - **Dynamic Updates**: Ensured the clock times are updated dynamically every second, keeping the displayed times accurate.

  This project showcases how Python can be used to create a functional and visually appealing world clock application. üïíüåç
* Day 97: Pipelines for inference [ü§ó Transformers](https://huggingface.co/docs/transformers/pipeline_tutorial)
  * Today, I explored the powerful pipeline feature from the Hugging Face Transformers library to perform automatic speech recognition (ASR) and text generation tasks. Here's a summary of what I accomplished:
    - **Automatic Speech Recognition**: Utilized the `pipeline()` function for ASR to transcribe audio files into text. Implemented and tested the OpenAI Whisper model for improved accuracy.
    - **Batch Processing**: Leveraged batch processing to handle multiple audio files efficiently, enhancing the pipeline's performance on a GPU.
    - **Task-Specific Parameters**: Experimented with parameters such as `return_timestamps` for subtitling and `chunk_length_s` for processing long audio files, demonstrating the flexibility of the pipeline.
    - **Device Management**: Configured the pipeline to run on the appropriate device (CPU or GPU) based on availability, optimizing computational resources.
    - **Dataset Integration**: Integrated the pipeline with datasets to perform inference on large datasets, showing the capability of the pipeline to handle extensive data inputs seamlessly.

  This project highlights the versatility and ease of using Hugging Face's pipeline feature for various NLP and ASR tasks, showcasing the practical applications of machine learning models in real-world scenarios.
* Day 98: Vehicle Management System
  * Today, I developed a Vehicle Management System to help the Universidad de Envigado manage the vehicles that enter and exit the campus. The system identifies each vehicle by its license plate and entry date. Here's a summary of what I accomplished:
    - **Vehicle Entry**: Implemented functionality to add a vehicle to the active vehicles list and log its entry time.
    - **Vehicle Exit**: Created a method to remove a vehicle from the active list and log its exit in the history.
    - **Date-Specific Entry Count**: Added a feature to determine the number of vehicles that entered the campus on a specific date.
    - **Entry Count by Vehicle**: Developed a function to list the number of times a specific vehicle has entered the campus.
    - **User-Friendly Menu**: Designed an interactive menu for users to manage vehicle entries and exits, check vehicle counts, and handle inputs gracefully, including validation for empty inputs.

  This project showcases the application of object-oriented programming principles to solve real-world problems, providing an efficient solution for managing campus vehicle traffic. The user-friendly interface ensures ease of use, while robust input validation enhances reliability.
* Day 99: üå¨Ô∏è Asthma Disease Dataset üå¨Ô∏è [Kaggle](https://www.kaggle.com/datasets/rabieelkharoua/asthma-disease-dataset/data)
  * Today, I worked with the Asthma Disease Dataset from Kaggle, aiming to analyze and model the factors contributing to asthma diagnosis. Here's a summary of what I accomplished:
    - **Data Exploration and Cleaning**: Conducted an initial exploration of the dataset to understand its structure and identify missing values. Cleaned the data by handling missing values and irrelevant columns.
    - **Feature Analysis**: Performed an exploratory data analysis (EDA) to visualize distributions of numerical features, correlations, and demographic insights. Created plots to understand the relationships between various factors and asthma diagnosis.
    - **Descriptive Statistics**: Calculated and interpreted key statistics for age distribution, gender, ethnicity, and education level among diagnosed and non-diagnosed patients.
    - **Pie Charts and Histograms**: Generated pie charts for categorical variables like ethnicity, gender, and education level. Plotted histograms for age distribution of diagnosed patients to identify trends.
    - **Correlation Heatmap**: Created a heatmap to visualize correlations between numerical features, helping to identify significant relationships.
    - **Model Training and Evaluation**: Developed and evaluated several machine learning models, including Logistic Regression, Random Forest, Gradient Boosting, Support Vector Machine, XGBoost, and K-Nearest Neighbors. Assessed model performance using accuracy and ROC AUC scores.
    - **Scaling and Splitting Data**: Preprocessed the data by scaling features and splitting it into training and testing sets to ensure robust model evaluation.

  This project highlights the importance of data preprocessing, exploratory analysis, and model evaluation in the context of medical data. The insights and models developed can help in understanding the factors influencing asthma diagnosis and potentially aid in early detection and prevention strategies.
* Day 100: üéÆ 2048 Game with Flask üéÆ

  * Today, I created a web-based 2048 game using Flask. The project involved building the game logic, setting up a server, and creating a responsive user interface. Here's a summary of what I accomplished:
    - **Flask Application Setup**: Initialized a Flask application to handle game logic and API endpoints. Defined routes for starting a new game, making moves, and autoplay functionality.
    - **Game Logic Implementation**: Developed functions to initialize the game board, add new tiles, and perform moves in all directions (left, right, up, down). Ensured that the game logic correctly merges tiles and adds new ones after each move.
    - **Autoplay Feature**: Implemented an autoplay feature that simulates moves automatically until the game ends. This feature helps demonstrate the game mechanics and provides a way to observe strategies for achieving higher scores.
    - **Game Over Check**: Added functionality to detect when the game is over, offering the option to restart the game and encouraging continuous play.
    - **User Interface Design**: Created a responsive UI using HTML and CSS, ensuring the game board is centered and visually appealing. Applied a dark background for better visibility and user experience.
    - **Styling with CSS**: Separated CSS into an external file, focusing on clean design and readability. Styled the board and cells to clearly display game states and centered numbers within their cells.
    - **JavaScript Integration**: Moved JavaScript code to an external file for better organization. Handled user input for moves, board rendering, and autoplay functionality.
    - **Restart Option**: Added a restart button to allow users to start a new game when the current game ends.
    - **Enhanced User Experience**: Improved the overall user experience by ensuring smooth interactions, clear game states, and responsive design elements.

  This project demonstrates the integration of front-end and back-end technologies to create an interactive web application. It highlights the importance of clean code organization, user-centric design, and robust game logic implementation. The 2048 game serves as a fun and engaging way to explore web development with Flask.

* Day 101: Technical Test "longestValidParentheses" and "search" [LeetCode](https://leetcode.com/problems/).
  * longestValidParentheses: Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. [Problem Description](https://leetcode.com/problems/longest-valid-parentheses/description/)
  * search: Given an array of integers `nums` sorted in ascending order, which is possibly rotated at an unknown pivot, and an integer `target`, find the index of `target` in `nums` or return -1 if it is not in `nums`. The algorithm must run in O(log n) time complexity. [Problem Description](https://leetcode.com/problems/search-in-rotated-sorted-array/description/)

* Day 102: üç¶ Object-Oriented Programming in Python with Ice Cream Example üç¶

  * Today, I explored the fundamentals of Object-Oriented Programming (OOP) in Python using a fun and relatable example: an ice cream shop. This project highlights the six basic principles of OOP‚Äîinheritance, cohesion, abstraction, polymorphism, coupling, and encapsulation. Here's a summary of what I accomplished:

    - **Abstraction and Encapsulation**: Created an abstract base class `IceCream` to represent the common attributes and behaviors of all ice creams. Encapsulated the flavor and price attributes to protect them from direct modification.
    - **Inheritance**: Developed two subclasses, `ScoopIceCream` and `Sundae`, inheriting from the `IceCream` class. These subclasses extend the base class by adding specific attributes like the number of scoops and toppings.
    - **Polymorphism**: Implemented a function `print_ice_cream_details` that takes any `IceCream` object and prints its details. This demonstrates how different ice cream objects can be handled through a single interface.
    - **Cohesion**: Ensured each class has a single, well-defined responsibility. For example, `ScoopIceCream` handles the specifics of scoop-based ice cream, while `Sundae` manages sundae-specific attributes.
    - **Coupling**: Maintained loose coupling between classes to ensure that changes in one class minimally affect others. This was achieved through well-defined interfaces and clear separation of responsibilities.
    - **Encapsulation**: Used private attributes to encapsulate the internal state of the objects, providing getter methods to access the values.
* Day 103: [TensorFlow](https://www.tensorflow.org/tutorials/keras/text_classification_with_hub) Text classification with TF Hub

  * Today, I explored text classification using TensorFlow Hub and TensorFlow Datasets. This project focused on building a neural network model to classify movie reviews as positive or negative. Here's a summary of what I accomplished:

    - **Data Loading and Preparation**: Utilized TensorFlow Datasets to download and prepare the IMDB dataset, splitting it into training, validation, and test sets.
    - **Exploration**: Examined the dataset to understand its structure and content. Each example in the dataset consists of a movie review (text) and a corresponding label (0 for negative, 1 for positive).
    - **Text Embedding**: Leveraged a pre-trained text embedding from TensorFlow Hub to convert sentences into embedding vectors. This approach simplifies text preprocessing, benefits from transfer learning, and provides a fixed-size output.
    - **Model Building**: Constructed a neural network model using Keras Sequential API. The model includes:
      - A TensorFlow Hub layer for text embedding.
      - A Dense layer with 16 hidden units and ReLU activation.
      - A Dense output layer with a single unit for binary classification.
    - **Loss Function and Optimizer**: Configured the model with the `binary_crossentropy` loss function and the Adam optimizer. This setup is suitable for binary classification tasks.
    - **Model Training**: Trained the model for 10 epochs using mini-batches of 512 samples, monitoring the loss and accuracy on the validation set.
    - **Model Evaluation**: Evaluated the model on the test set to measure its performance, reporting both loss and accuracy.

  This project demonstrates the application of TensorFlow and TensorFlow Hub for natural language processing tasks. It highlights the importance of using pre-trained models for efficient text embedding and the benefits of a well-structured neural network for text classification.
* Day 104: Battleship Game with Flask
  * Today, I developed a Battleship game using Flask, a micro web framework for Python. This project involved creating a web-based version of the classic Battleship game, where users can guess the locations of ships on a grid. Here's a summary of what I accomplished:

    - **Setting Up Flask Application**: Initialized a Flask project, set up routes, and managed sessions to maintain game state between requests.
    - **Game Logic Implementation**: Implemented the core game logic in Python, including functions for creating ships, processing user guesses, and checking for game over conditions.
    - **Session Management**: Utilized Flask sessions to store the hidden and guess boards, ensuring the game state is preserved between user interactions.
    - **User Interface**: Developed HTML templates using Jinja2 to render the game board and provide a user-friendly interface. Included labels for rows and columns to guide the user.
    - **Game Mechanics**: Added functionality to handle user guesses, update the game board, and provide feedback on hits and misses. Also implemented logic to reveal ship locations if the user runs out of turns.

  This project showcases how to build a simple yet interactive web application with Flask. It emphasizes the importance of session management in web applications and demonstrates how to create a dynamic user interface with Jinja2 templates. Additionally, it illustrates the implementation of classic game mechanics in a web-based environment.

* Day 105: Technical Test "searchRange" and "searchInsert" [LeetCode](https://leetcode.com/problems/).

  - **searchRange**: Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given target value. If the target is not found in the array, return [-1, -1]. The algorithm must run in O(log n) time complexity.
  [Problem Description](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/)
    
  - **searchInsert**: Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. The algorithm must run in O(log n) time complexity. [Problem Description](https://leetcode.com/problems/search-insert-position/description/)
* Day 106: Create a Multipage App with Streamlit [Streamlit Tutorial](https://docs.streamlit.io/get-started/tutorials/create-a-multipage-app)
  * Today, I focused on building a multipage web application using Streamlit, a popular open-source app framework for Machine Learning and Data Science projects. This project involved creating a web application that can navigate between different pages, each displaying unique content or functionality. Here's a summary of what I accomplished:

    - **Setting Up Streamlit Environment**: Installed Streamlit and set up the development environment.
    - **Creating Pages**: Developed multiple pages for the application, each serving a distinct purpose. For example, a home page, a data visualization page, and a user input page.
    - **Navigation Implementation**: Implemented a navigation system to switch between different pages. Used Streamlit‚Äôs built-in components to create a user-friendly interface for navigation.
    - **Dynamic Content**: Ensured each page displays dynamic content based on user interactions. For instance, visualizations that update based on user input or data selections.
    - **User Interface Design**: Designed the layout and style of the application to make it intuitive and visually appealing. Leveraged Streamlit‚Äôs layout options and widgets to enhance the user experience.

  This project showcases the versatility of Streamlit in creating interactive and multipage web applications. It emphasizes the ease of setting up a multi-page structure and the ability to integrate dynamic content seamlessly. This was an excellent exercise in web development and user interface design, demonstrating how to build comprehensive applications using Streamlit.
* Day 107: Twenty One Card Game GUI
  * Today, I developed a Twenty-One card game (similar to Blackjack) in Python. This project involved creating the core game logic, displaying cards, handling user interactions, and implementing the rules of the game. Here's a summary of what I accomplished:

    - **Card Display Function**: Created a function to display cards in a visually appealing format using ASCII art. This function helps players see their cards and the dealer's cards clearly.
    - **Random Card Generation**: Implemented a function to generate random cards, ensuring a mix of suits and values for each game.
    - **Card Value Calculation**: Developed a function to calculate the value of each card, considering the special case for Aces, which can be worth either 1 or 11 points.
    - **Game Logic**: Implemented the main game loop, handling the player's turn and the dealer's turn, including decision-making processes and win/lose conditions.
    - **User Interaction**: Added functionality for user input to decide whether to continue playing or stop, and to determine if the player wants to try again after a game ends.

  This project demonstrates the implementation of a classic card game using Python, focusing on interactive gameplay and dynamic card management. It emphasizes the importance of user-friendly design and accurate game mechanics.